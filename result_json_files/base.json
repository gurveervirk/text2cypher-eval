[
    {
        "question": "Which 5 countries have the most filings as originators in the last quarter of any year?",
        "schema": "Node properties:\n- **Country**\n  - `location`: POINT \n  - `code`: STRING Example: \"AFG\"\n  - `name`: STRING Example: \"Afghanistan\"\n  - `tld`: STRING Example: \"AF\"\n- **Filing**\n  - `begin`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-09-05T00:00:00Z\n  - `end`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-11-03T00:00:00Z\n  - `originator_bank_id`: STRING Example: \"cimb-bank-berhad\"\n  - `sar_id`: STRING Example: \"3297\"\n  - `beneficiary_bank`: STRING Example: \"Barclays Bank Plc\"\n  - `filer_org_name_id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `originator_bank_country`: STRING Example: \"Singapore\"\n  - `beneficiary_bank_country`: STRING Example: \"United Kingdom\"\n  - `filer_org_name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `originator_iso`: STRING Example: \"SGP\"\n  - `beneficiary_bank_id`: STRING Example: \"barclays-bank-plc-london-england-gbr\"\n  - `origin_lat`: STRING Example: \"1.3667\"\n  - `origin_lng`: STRING Example: \"103.8\"\n  - `end_date_format`: STRING Example: \"2015-09-25T00:00:00Z\"\n  - `begin_date_format`: STRING Example: \"2015-03-25T00:00:00Z\"\n  - `originator_bank`: STRING Example: \"CIMB Bank Berhad\"\n  - `beneficiary_lat`: STRING Example: \"54\"\n  - `beneficiary_iso`: STRING Example: \"GBR\"\n  - `beneficiary_lng`: STRING Example: \"-2\"\n  - `begin_date`: STRING Example: \"Mar 25, 2015\"\n  - `id`: STRING Example: \"223254\"\n  - `end_date`: STRING Example: \"Sep 25, 2015\"\n  - `amount`: INTEGER Min: 1.18, Max: 2721000000\n  - `number`: INTEGER Min: 1, Max: 174\n- **Entity**\n  - `id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `location`: POINT \n  - `name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `country`: STRING Example: \"CHN\"\nRelationship properties:\n\nThe relationships:\n(:Filing)-[:BENEFITS]->(:Entity)\n(:Filing)-[:CONCERNS]->(:Entity)\n(:Filing)-[:ORIGINATOR]->(:Entity)\n(:Entity)-[:FILED]->(:Filing)\n(:Entity)-[:COUNTRY]->(:Country)",
        "gold_cypher": "MATCH (f:Filing)-[:ORIGINATOR]->(e:Entity)-[:COUNTRY]->(c:Country) WHERE (f.begin >= datetime({year: 2000, month: 10, day: 1}) AND f.begin <= datetime({year: 2000, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2001, month: 10, day: 1}) AND f.begin <= datetime({year: 2001, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2002, month: 10, day: 1}) AND f.begin <= datetime({year: 2002, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2003, month: 10, day: 1}) AND f.begin <= datetime({year: 2003, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2004, month: 10, day: 1}) AND f.begin <= datetime({year: 2004, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2005, month: 10, day: 1}) AND f.begin <= datetime({year: 2005, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2006, month: 10, day: 1}) AND f.begin <= datetime({year: 2006, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2007, month: 10, day: 1}) AND f.begin <= datetime({year: 2007, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2008, month: 10, day: 1}) AND f.begin <= datetime({year: 2008, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2009, month: 10, day: 1}) AND f.begin <= datetime({year: 2009, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2010, month: 10, day: 1}) AND f.begin <= datetime({year: 2010, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2011, month: 10, day: 1}) AND f.begin <= datetime({year: 2011, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2012, month: 10, day: 1}) AND f.begin <= datetime({year: 2012, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2013, month: 10, day: 1}) AND f.begin <= datetime({year: 2013, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2014, month: 10, day: 1}) AND f.begin <= datetime({year: 2014, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2015, month: 10, day: 1}) AND f.begin <= datetime({year: 2015, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2016, month: 10, day: 1}) AND f.begin <= datetime({year: 2016, month: 12, day: 31}))    OR (f.begin >= datetime({year: 2017, month: 10, day: 1}) AND f.begin <= datetime({year: 2017, month: 12, day: 31})) RETURN c.name AS country, COUNT(f) AS filings ORDER BY filings DESC LIMIT 5",
        "database": "fincen",
        "full_responses": [
            "To answer the question \"Which 5 countries have the most filings as originators in the last quarter of any year?\", you can use the following Cypher query:\n\n```cypher\nMATCH (originator:Filing)-[:ORIGINATOR]->(country:Country)\nWHERE originator.begin >= '2020-10-01T00:00:00Z' AND originator.begin <= '2020-12-31T00:00:00Z'\nRETURN country.code AS code, COUNT(originator) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5;\n```\n\n### Explanation:\n- **MATCH (originator:Filing)-[:ORIGINATOR]->(country:Country)**: This part of the query matches all relationships of type `ORIGINATOR` where the `originator` node is a `Filing` node and the `country` node is a `Country` node.\n- **WHERE originator.begin >= '2020-10-01T00:00:00Z' AND originator.begin <= '2020-12-31T00:00:00Z'**: This condition filters the filings to only include those that occurred in the last quarter of 2020 (October to December). You can adjust the date range as needed for the last quarter of any year.\n- **RETURN country.code AS code, COUNT(originator) AS filing_count**: This part of the query returns the country code and the count of filings for each country.\n- **ORDER BY filing_count DESC**: This orders the results by the count of filings in descending order to get the countries with the most filings at the top.\n- **LIMIT 5**: This limits the results to the top 5 countries with the most filings.",
            "```cypher\nMATCH (f:Filing)\nWHERE f.begin >= '2023-04-01T00:00:00Z' AND f.begin <= '2023-09-01T00:00:00Z'\nWITH f.originator_bank_country AS country, COUNT(f) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5\n```\n\nThis query filters filings to include only those from the last quarter of 2023, where the `begin` date is within the specified range. It then groups the results by the `originator_bank_country` and counts the number of filings for each country. The results are ordered by the filing count in descending order, and the top 5 countries with the most filings are returned.",
            "```cypher\nMATCH (f:Filing)-[o:ORIGINATOR]->(e:Entity)-[c:COUNTRY]->(c:Country)\nWHERE f.begin >= '2023-04-01T00:00:00Z' AND f.begin < '2023-10-01T00:00:00Z'\nRETURN c.name, COUNT(f) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5;\n```",
            "To answer this question, we need to focus on the `Filing` nodes and their relationships to the `Country` nodes. Specifically, we are interested in filings where the originator is from the last quarter of any year. Here's how we can write the Cypher query to achieve this:\n\n1. **Identify the last quarter of any year**: This can be done by using the `end_date` property to filter filings that fall within the last quarter of the year.\n\n2. **Count the filings by country**: We will count the number of filings for each country that meet the criteria.\n\n3. **Order and limit the results**: We will order the results by the count of filings in descending order and limit the output to the top 5 countries.\n\nHere's the Cypher query:\n\n```cypher\nMATCH (f:Filing)-[:ORIGINATOR]->(c:Country)\nWHERE f.end_date >= '2000-10-01T00:00:00Z' AND f.end_date <= '2017-12-31T23:59:59Z'\nRETURN c.name AS country, COUNT(*) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5;\n```\n\n### Explanation:\n- **MATCH (f:Filing)-[:ORIGINATOR]->(c:Country)**: This matches the `Filing` nodes that are originators of other nodes.\n- **WHERE f.end_date >= '2000-10-01T00:00:00Z' AND f.end_date <= '2017-12-31T23:59:59Z'**: This filters the filings to include only those that fall within the last quarter of any year, i.e., October 1, 2000, to December 31, 2017.\n- **RETURN c.name AS country, COUNT(*) AS filing_count**: This returns the country name and the count of filings for each country.\n- **ORDER BY filing_count DESC**: This orders the results by the count of filings in descending order.\n- **LIMIT 5**: This limits the output to the top 5 countries.",
            "```cypher\nMATCH (f:Filing)-[o:ORIGINATOR]->(c:Country)\nWHERE f.begin >= '2017-07-01T00:00:00Z' AND f.begin < '2017-10-01T00:00:00Z'\nWITH c.code AS country, count(f) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5\n```"
        ],
        "generated_cyphers": [
            "To answer the question \"Which 5 countries have the most filings as originators in the last quarter of any year?\", you can use the following Cypher query:\n\n```cypher\nMATCH (originator:Filing)-[:ORIGINATOR]->(country:Country)\nWHERE originator.begin >= '2020-10-01T00:00:00Z' AND originator.begin <= '2020-12-31T00:00:00Z'\nRETURN country.code AS code, COUNT(originator) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5;\n```\n\n### Explanation:\n- **MATCH (originator:Filing)-[:ORIGINATOR]->(country:Country)**: This part of the query matches all relationships of type `ORIGINATOR` where the `originator` node is a `Filing` node and the `country` node is a `Country` node.\n- **WHERE originator.begin >= '2020-10-01T00:00:00Z' AND originator.begin <= '2020-12-31T00:00:00Z'**: This condition filters the filings to only include those that occurred in the last quarter of 2020 (October to December). You can adjust the date range as needed for the last quarter of any year.\n- **RETURN country.code AS code, COUNT(originator) AS filing_count**: This part of the query returns the country code and the count of filings for each country.\n- **ORDER BY filing_count DESC**: This orders the results by the count of filings in descending order to get the countries with the most filings at the top.\n- **LIMIT 5**: This limits the results to the top 5 countries with the most filings.",
            "```cypher\nMATCH (f:Filing)\nWHERE f.begin >= '2023-04-01T00:00:00Z' AND f.begin <= '2023-09-01T00:00:00Z'\nWITH f.originator_bank_country AS country, COUNT(f) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5\n```\n\nThis query filters filings to include only those from the last quarter of 2023, where the `begin` date is within the specified range. It then groups the results by the `originator_bank_country` and counts the number of filings for each country. The results are ordered by the filing count in descending order, and the top 5 countries with the most filings are returned.",
            "```cypher\nMATCH (f:Filing)-[o:ORIGINATOR]->(e:Entity)-[c:COUNTRY]->(c:Country)\nWHERE f.begin >= '2023-04-01T00:00:00Z' AND f.begin < '2023-10-01T00:00:00Z'\nRETURN c.name, COUNT(f) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5;\n```",
            "To answer this question, we need to focus on the `Filing` nodes and their relationships to the `Country` nodes. Specifically, we are interested in filings where the originator is from the last quarter of any year. Here's how we can write the Cypher query to achieve this:\n\n1. **Identify the last quarter of any year**: This can be done by using the `end_date` property to filter filings that fall within the last quarter of the year.\n\n2. **Count the filings by country**: We will count the number of filings for each country that meet the criteria.\n\n3. **Order and limit the results**: We will order the results by the count of filings in descending order and limit the output to the top 5 countries.\n\nHere's the Cypher query:\n\n```cypher\nMATCH (f:Filing)-[:ORIGINATOR]->(c:Country)\nWHERE f.end_date >= '2000-10-01T00:00:00Z' AND f.end_date <= '2017-12-31T23:59:59Z'\nRETURN c.name AS country, COUNT(*) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5;\n```\n\n### Explanation:\n- **MATCH (f:Filing)-[:ORIGINATOR]->(c:Country)**: This matches the `Filing` nodes that are originators of other nodes.\n- **WHERE f.end_date >= '2000-10-01T00:00:00Z' AND f.end_date <= '2017-12-31T23:59:59Z'**: This filters the filings to include only those that fall within the last quarter of any year, i.e., October 1, 2000, to December 31, 2017.\n- **RETURN c.name AS country, COUNT(*) AS filing_count**: This returns the country name and the count of filings for each country.\n- **ORDER BY filing_count DESC**: This orders the results by the count of filings in descending order.\n- **LIMIT 5**: This limits the output to the top 5 countries.",
            "```cypher\nMATCH (f:Filing)-[o:ORIGINATOR]->(c:Country)\nWHERE f.begin >= '2017-07-01T00:00:00Z' AND f.begin < '2017-10-01T00:00:00Z'\nWITH c.code AS country, count(f) AS filing_count\nORDER BY filing_count DESC\nLIMIT 5\n```"
        ]
    },
    {
        "question": "What are the details of entities that have an incorporation date in 2006?",
        "schema": "Node properties:\n- **Entity**\n  - `countries`: STRING Example: \"Hong Kong\"\n  - `ibcRUC`: STRING Example: \"25221\"\n  - `valid_until`: STRING Example: \"The Panama Papers data is current through 2015\"\n  - `country_codes`: STRING Example: \"HKG\"\n  - `service_provider`: STRING Available options: ['Appleby', 'Portcullis Trustnet', 'Mossack Fonseca', 'Commonwealth Trust Limited']\n  - `address`: STRING Example: \"ORION HOUSE SERVICES (HK) LIMITED ROOM 1401; 14/F.\"\n  - `inactivation_date`: STRING Example: \"18-FEB-2013\"\n  - `struck_off_date`: STRING Example: \"15-FEB-2013\"\n  - `status`: STRING Example: \"Defaulted\"\n  - `jurisdiction_description`: STRING Example: \"Samoa\"\n  - `incorporation_date`: STRING Example: \"23-MAR-2006\"\n  - `original_name`: STRING Example: \"TIANSHENG INDUSTRY AND TRADING CO., LTD.\"\n  - `jurisdiction`: STRING Example: \"SAM\"\n  - `name`: STRING Example: \"TIANSHENG INDUSTRY AND TRADING CO., LTD.\"\n  - `internal_id`: STRING Example: \"1001256\"\n  - `lastEditTimestamp`: STRING Example: \"1638311020926\"\n  - `node_id`: INTEGER Min: 10000001, Max: 10000005\n  - `sourceID`: STRING Example: \"Panama Papers\"\n  - `former_name`: STRING \n  - `company_type`: STRING \n  - `tax_stat_description`: STRING \n  - `note`: STRING \n  - `dorm_date`: STRING \n  - `type`: STRING \n  - `closed_date`: STRING \n  - `company_number`: STRING \n  - `comments`: STRING \n  - `entity_number`: STRING \n- **Intermediary**\n  - `countries`: STRING Example: \"South Africa\"\n  - `lastEditTimestamp`: STRING Example: \"1638311034131\"\n  - `address`: STRING Example: \"MICHAEL PAPAGEORGE; MR. 106 NICHOLSON STREET BROOK\"\n  - `valid_until`: STRING Example: \"The Panama Papers  data is current through 2015\"\n  - `country_codes`: STRING Example: \"ZAF\"\n  - `name`: STRING Example: \"MICHAEL PAPAGEORGE, MR.\"\n  - `status`: STRING Available options: ['UNRECOVERABLE ACCOUNTS', 'CLIENT IN REPRESENTATIVE TERRITORY', 'ACTIVE', 'INACTIVE', 'SUSPENDED', 'DELINQUENT', 'PROSPECT', 'SUSPENDED LEGAL', 'ACTIVE LEGAL']\n  - `node_id`: INTEGER Min: 11000001, Max: 11000005\n  - `sourceID`: STRING Available options: ['Pandora Papers - Alem\u00e1n, Cordero, Galindo & Lee (Alcogal)', 'Paradise Papers - Appleby', 'Paradise Papers - Barbados corporate registry', 'Bahamas Leaks', 'Panama Papers', 'Paradise Papers - Nevis corporate registry', 'Paradise Papers - Bahamas corporate registry', 'Offshore Leaks', 'Paradise Papers - Aruba corporate registry']\n  - `internal_id`: STRING Example: \"10001\"\n  - `registered_office`: STRING \n- **Officer**\n  - `valid_until`: STRING Example: \"The Panama Papers data is current through 2015\"\n  - `name`: STRING Example: \"KIM SOO IN\"\n  - `sourceID`: STRING Example: \"Panama Papers\"\n  - `icij_id`: STRING Example: \"E72326DEA50F1A9C2876E112AAEB42BC\"\n  - `node_id`: INTEGER Min: 12000001, Max: 12000005\n  - `lastEditTimestamp`: STRING Example: \"1638311034062\"\n  - `country_codes`: STRING Example: \"KOR\"\n  - `countries`: STRING Example: \"South Korea\"\n  - `note`: STRING \n- **Address**\n  - `original_address`: STRING Example: \"ANNEX FREDERICK & SHIRLEY STS, P. O. BOX N-4805 NA\"\n  - `lastEditTimestamp`: STRING Example: \"1638311020926\"\n  - `countries`: STRING Example: \"Bahamas\"\n  - `address`: STRING Example: \"ANNEX FREDERICK & SHIRLEY STS, P.O. BOX N-4805, NA\"\n  - `valid_until`: STRING Example: \"The Bahamas Leaks data is current through early 20\"\n  - `icij_id`: STRING Example: \"7C1AAD6896EFDED57D680B82E7ADF7AB\"\n  - `node_id`: INTEGER Min: 24000001, Max: 24000005\n  - `sourceID`: STRING Example: \"Bahamas Leaks\"\n  - `country_codes`: STRING Example: \"BHS\"\n  - `name`: STRING \n  - `addressID`: STRING \n  - `country_code`: STRING \n  - `country`: STRING \n- **Other**\n  - `lastEditTimestamp`: STRING Available options: ['1638311068329', '1638311074502', '1638311074946', '1638311075268', '1638311075503']\n  - `incorporation_date`: STRING Example: \"18-MAY-1983\"\n  - `struck_off_date`: STRING Example: \"31-DEC-2002\"\n  - `jurisdiction`: STRING Available options: ['AW']\n  - `jurisdiction_description`: STRING Available options: ['Aruba']\n  - `valid_until`: STRING Available options: ['Aruba corporate registry data is current through 2', 'Appleby data is current through 2014']\n  - `sourceID`: STRING Available options: ['Paradise Papers - Aruba corporate registry', 'Paradise Papers - Appleby']\n  - `name`: STRING Example: \"ANTAM ENTERPRISES N.V.\"\n  - `type`: STRING Available options: ['LIMITED LIABILITY COMPANY', 'SOLE OWNERSHIP', 'FOREIGN FORMED CORPORATION']\n  - `node_id`: INTEGER Min: 80000012, Max: 85050056\n  - `closed_date`: STRING Example: \"28-NOV-2012\"\n  - `note`: STRING Available options: ['Closed date stands for Cancelled date.', 'Closed date stands for Liquidation date.']\n  - `countries`: STRING Example: \"Bermuda;Isle of Man\"\n  - `country_codes`: STRING Example: \"BMU;IMN\"\nRelationship properties:\n- **registered_address**\n  - `link: STRING` Example: \"registered address\"\n  - `sourceID: STRING` Example: \"Panama Papers\"\n  - `valid_until: STRING` \n- **intermediary_of**\n  - `valid_until: STRING` Example: \"The Panama Papers data is current through 2015\"\n  - `sourceID: STRING` Example: \"Panama Papers\"\n  - `link: STRING` Example: \"intermediary of\"\n  - `end_date: STRING` \n  - `start_date: STRING` \n- **officer_of**\n  - `link: STRING` Example: \"shareholder of\"\n  - `valid_until: STRING` Example: \"The Panama Papers data is current through 2015\"\n  - `sourceID: STRING` Example: \"Panama Papers\"\n  - `start_date: STRING` Example: \"19-NOV-1999\"\n  - `end_date: STRING` Example: \"04-JUL-2000\"\n  - `status: STRING` \n- **similar**\n  - `link: STRING` Example: \"similar name and address as\"\n- **same_as**\n  - `link: STRING` Available options: ['same name and registration date as', 'same address as', 'same as']\n- **same_name_as**\n  - `sourceID: STRING` Example: \"Bahamas Leaks\"\n  - `link: STRING` Example: \"same name as\"\n  - `valid_until: STRING` Example: \"The Bahamas Leaks data is current through early 20\"\n- **same_company_as**\n  - `valid_until: STRING` Example: \"The Bahamas Leaks data is current through early 20\"\n  - `sourceID: STRING` Example: \"Bahamas Leaks\"\n  - `link: STRING` Example: \"same company as\"\n- **same_id_as**\n  - `sourceID: STRING` Available options: ['Paradise Papers - Malta corporate registry']\n  - `link: STRING` Available options: ['same id as']\n  - `valid_until: STRING` Available options: ['Malta corporate registry data is current through 2']\n- **connected_to**\n  - `valid_until: STRING` Example: \"Aruba corporate registry data is current through 2\"\n  - `link: STRING` Example: \"connected to\"\n  - `sourceID: STRING` Example: \"Paradise Papers - Aruba corporate registry\"\nThe relationships:\n(:Entity)-[:same_as]->(:Entity)\n(:Entity)-[:registered_address]->(:Address)\n(:Entity)-[:same_company_as]->(:Entity)\n(:Entity)-[:same_name_as]->(:Other)\n(:Entity)-[:same_name_as]->(:Entity)\n(:Intermediary)-[:intermediary_of]->(:Entity)\n(:Intermediary)-[:registered_address]->(:Address)\n(:Intermediary)-[:officer_of]->(:Entity)\n(:Intermediary)-[:similar]->(:Officer)\n(:Intermediary)-[:same_name_as]->(:Intermediary)\n(:Intermediary)-[:same_name_as]->(:Officer)\n(:Intermediary)-[:same_as]->(:Officer)\n(:Officer)-[:officer_of]->(:Entity)\n(:Officer)-[:officer_of]->(:Other)\n(:Officer)-[:registered_address]->(:Address)\n(:Officer)-[:similar]->(:Officer)\n(:Officer)-[:similar]->(:Intermediary)\n(:Officer)-[:same_name_as]->(:Officer)\n(:Officer)-[:connected_to]->(:Entity)\n(:Officer)-[:same_id_as]->(:Officer)\n(:Address)-[:same_as]->(:Address)\n(:Other)-[:registered_address]->(:Address)\n(:Other)-[:connected_to]->(:Entity)\n(:Other)-[:same_name_as]->(:Entity)\n(:Other)-[:same_name_as]->(:Officer)\n(:Other)-[:same_name_as]->(:Other)",
        "gold_cypher": "MATCH (e:Entity) WHERE e.incorporation_date CONTAINS '2006' RETURN e.name AS entity_name, e.countries AS countries, e.ibcRUC AS ibcRUC, e.valid_until AS valid_until,         e.country_codes AS country_codes, e.service_provider AS service_provider, e.address AS address,         e.inactivation_date AS inactivation_date, e.struck_off_date AS struck_off_date, e.status AS status,         e.jurisdiction_description AS jurisdiction_description, e.incorporation_date AS incorporation_date,         e.original_name AS original_name, e.jurisdiction AS jurisdiction, e.internal_id AS internal_id,         e.lastEditTimestamp AS lastEditTimestamp, e.node_id AS node_id, e.sourceID AS sourceID,         e.former_name AS former_name, e.company_type AS company_type, e.tax_stat_description AS tax_stat_description,         e.note AS note, e.dorm_date AS dorm_date, e.type AS type, e.closed_date AS closed_date,         e.company_number AS company_number, e.comments AS comments, e.entity_number AS entity_number",
        "database": "offshoreleaks",
        "full_responses": [
            "```cypher\nMATCH (e:Entity {incorporation_date: '2006'})\nRETURN e\n```",
            "To find the details of entities that have an incorporation date in 2006, you can use the following Cypher query:\n\n```cypher\nMATCH (entity:Entity)\nWHERE TO_DATE(entity.incorporation_date) = DATE('2006-01-01')\nRETURN entity\n```\n\nThis query matches all nodes of type `Entity` and filters them to include only those with an `incorporation_date` that matches `2006-01-01`. The `TO_DATE` function is used to convert the string `incorporation_date` to a date format for comparison.",
            "```cypher\nMATCH (e:Entity)\nWHERE e.incorporation_date = '2006'\nRETURN e\n```",
            "To find the details of entities that have an incorporation date in 2006, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity {incorporation_date: '2006-MAR-23'})\nRETURN e.name, e.entity_number, e.incorporation_date, e.company_type, e.jurisdiction, e.jurisdiction_description, e.address, e.service_provider, e.valid_until, e.inactivation_date, e.struck_off_date, e.status, e.dorm_date, e.closed_date, e.company_number, e.comments, e.sourceID;\n```\n\nThis query matches all nodes of type `Entity` where the `incorporation_date` is '2006-MAR-23' and returns the specified properties of those nodes.",
            "To find the details of entities that have an incorporation date in 2006, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity)\nWHERE e.incorporation_date = '2006'\nRETURN e\n```\n\nThis query matches all nodes of type `Entity` where the `incorporation_date` property is exactly '2006' and returns those nodes."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (e:Entity {incorporation_date: '2006'})\nRETURN e\n```",
            "To find the details of entities that have an incorporation date in 2006, you can use the following Cypher query:\n\n```cypher\nMATCH (entity:Entity)\nWHERE TO_DATE(entity.incorporation_date) = DATE('2006-01-01')\nRETURN entity\n```\n\nThis query matches all nodes of type `Entity` and filters them to include only those with an `incorporation_date` that matches `2006-01-01`. The `TO_DATE` function is used to convert the string `incorporation_date` to a date format for comparison.",
            "```cypher\nMATCH (e:Entity)\nWHERE e.incorporation_date = '2006'\nRETURN e\n```",
            "To find the details of entities that have an incorporation date in 2006, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity {incorporation_date: '2006-MAR-23'})\nRETURN e.name, e.entity_number, e.incorporation_date, e.company_type, e.jurisdiction, e.jurisdiction_description, e.address, e.service_provider, e.valid_until, e.inactivation_date, e.struck_off_date, e.status, e.dorm_date, e.closed_date, e.company_number, e.comments, e.sourceID;\n```\n\nThis query matches all nodes of type `Entity` where the `incorporation_date` is '2006-MAR-23' and returns the specified properties of those nodes.",
            "To find the details of entities that have an incorporation date in 2006, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity)\nWHERE e.incorporation_date = '2006'\nRETURN e\n```\n\nThis query matches all nodes of type `Entity` where the `incorporation_date` property is exactly '2006' and returns those nodes."
        ]
    },
    {
        "question": "What are the top 3 beneficiary banks by the number of filings involving transactions from Europe?",
        "schema": "Node properties:\n- **Country**\n  - `location`: POINT \n  - `code`: STRING Example: \"AFG\"\n  - `name`: STRING Example: \"Afghanistan\"\n  - `tld`: STRING Example: \"AF\"\n- **Filing**\n  - `begin`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-09-05T00:00:00Z\n  - `end`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-11-03T00:00:00Z\n  - `originator_bank_id`: STRING Example: \"cimb-bank-berhad\"\n  - `sar_id`: STRING Example: \"3297\"\n  - `beneficiary_bank`: STRING Example: \"Barclays Bank Plc\"\n  - `filer_org_name_id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `originator_bank_country`: STRING Example: \"Singapore\"\n  - `beneficiary_bank_country`: STRING Example: \"United Kingdom\"\n  - `filer_org_name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `originator_iso`: STRING Example: \"SGP\"\n  - `beneficiary_bank_id`: STRING Example: \"barclays-bank-plc-london-england-gbr\"\n  - `origin_lat`: STRING Example: \"1.3667\"\n  - `origin_lng`: STRING Example: \"103.8\"\n  - `end_date_format`: STRING Example: \"2015-09-25T00:00:00Z\"\n  - `begin_date_format`: STRING Example: \"2015-03-25T00:00:00Z\"\n  - `originator_bank`: STRING Example: \"CIMB Bank Berhad\"\n  - `beneficiary_lat`: STRING Example: \"54\"\n  - `beneficiary_iso`: STRING Example: \"GBR\"\n  - `beneficiary_lng`: STRING Example: \"-2\"\n  - `begin_date`: STRING Example: \"Mar 25, 2015\"\n  - `id`: STRING Example: \"223254\"\n  - `end_date`: STRING Example: \"Sep 25, 2015\"\n  - `amount`: INTEGER Min: 1.18, Max: 2721000000\n  - `number`: INTEGER Min: 1, Max: 174\n- **Entity**\n  - `id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `location`: POINT \n  - `name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `country`: STRING Example: \"CHN\"\nRelationship properties:\n\nThe relationships:\n(:Filing)-[:BENEFITS]->(:Entity)\n(:Filing)-[:CONCERNS]->(:Entity)\n(:Filing)-[:ORIGINATOR]->(:Entity)\n(:Entity)-[:FILED]->(:Filing)\n(:Entity)-[:COUNTRY]->(:Country)",
        "gold_cypher": "MATCH (f:Filing)-[:BENEFITS]->(e:Entity)-[:COUNTRY]->(c:Country) WHERE c.name IN [\"Albania\", \"Andorra\", \"Armenia\", \"Austria\", \"Azerbaijan\", \"Belarus\", \"Belgium\", \"Bosnia and Herzegovina\", \"Bulgaria\", \"Croatia\", \"Cyprus\", \"Czech Republic\", \"Denmark\", \"Estonia\", \"Finland\", \"France\", \"Georgia\", \"Germany\", \"Greece\", \"Hungary\", \"Iceland\", \"Ireland\", \"Italy\", \"Kazakhstan\", \"Kosovo\", \"Latvia\", \"Liechtenstein\", \"Lithuania\", \"Luxembourg\", \"Malta\", \"Moldova\", \"Monaco\", \"Montenegro\", \"Netherlands\", \"North Macedonia\", \"Norway\", \"Poland\", \"Portugal\", \"Romania\", \"Russia\", \"San Marino\", \"Serbia\", \"Slovakia\", \"Slovenia\", \"Spain\", \"Sweden\", \"Switzerland\", \"Turkey\", \"Ukraine\", \"United Kingdom\", \"Vatican City\"] RETURN f.beneficiary_bank AS BeneficiaryBank, COUNT(f) AS NumberOfFilings ORDER BY NumberOfFilings DESC LIMIT 3",
        "database": "fincen",
        "full_responses": [
            "To answer the question \"What are the top 3 beneficiary banks by the number of filings involving transactions from Europe?\", we need to:\n\n1. Identify the countries in Europe.\n2. Count the number of filings involving transactions from these countries.\n3. Sort the results by the number of filings in descending order.\n4. Limit the results to the top 3 banks.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (f:Filing)-[r:BENEFITS]->(b:Entity)\nWHERE b.location IS NOT NULL AND r.originator_bank_country IN ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'ES', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', '",
            "To answer this question, we need to identify beneficiary banks that have filed filings from Europe and then count the number of filings for each beneficiary bank. Finally, we will order these counts in descending order and select the top 3. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (e:Entity)-[:FILED]->(f:Filing)-[:BENEFITS]->(b:Entity)\nWHERE b.country = 'EU'\nRETURN b.name AS beneficiary_bank, COUNT(f.id) AS filing_count\nORDER BY filing_count DESC\nLIMIT 3;\n```\n\nThis query works as follows:\n- It starts from the `Entity` node and traverses to `Filing` through the `FILED` relationship.\n- It then traverses from `Filing` to `Entity` through the `BENEFITS` relationship.\n- It filters the `Entity` nodes in the `BENEFITS` relationship to only include those where the `country` is 'EU'.\n- It counts the number of filings for each beneficiary bank and orders the results by the count in descending order.\n- Finally, it limits the results to the top 3 beneficiary banks.",
            "To answer the question, we need to identify the top 3 beneficiary banks by the number of filings involving transactions from Europe. This involves querying the database to count the number of filings for each beneficiary bank and then ordering these counts in descending order.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Entity)-[r:BENEFITS]->(f:Filing)\nWHERE b.country IN ['IT', 'ES', 'FR', 'DE']  -- Countries in Europe\nRETURN b.name AS BeneficiaryBank, COUNT(f) AS FilingsCount\nORDER BY FilingsCount DESC\nLIMIT 3;\n```\n\n### Explanation:\n1. **MATCH (b:Entity)-[r:BENEFITS]->(f:Filing)**: This part of the query matches all relationships between entities (`Entity`) and filings (`Filing`) where the relationship is `BENEFITS`.\n2. **WHERE b.country IN ['IT', 'ES', 'FR', 'DE']**: This filters the entities to only include those from countries in Europe.\n3. **RETURN b.name AS BeneficiaryBank, COUNT(f) AS FilingsCount**: This selects the beneficiary bank's name and counts the number of filings associated with each bank.\n4. **ORDER BY FilingsCount DESC**: This orders the results by the number of filings in descending order.\n5. **LIMIT 3**: This limits the results to the top 3 beneficiary banks.\n\nThis query will return the names of the top 3 beneficiary banks in Europe along with the number of filings they have, sorted by the number of filings in descending order.",
            "To answer the question \"What are the top 3 beneficiary banks by the number of filings involving transactions from Europe?\", you can use the following Cypher query:\n\n```cypher\nMATCH (f:Filing)-[:BENEFITS]->(b:Entity)-[:COUNTRY]->(c:Country)\nWHERE c.name IN ['United Kingdom', 'Sweden', 'Netherlands', 'France', 'Germany', 'Denmark', 'Belgium', 'Ireland', 'Switzerland', 'Italy', 'Poland', 'Portugal', 'Austria', 'Romania', 'Spain', 'Hungary', 'Czech Republic', 'Slovakia', 'Slovenia', 'Norway', 'Estonia', 'Latvia', 'Lithuania', 'Luxembourg', 'Cyprus', 'Moldova', 'Malta', 'Finland', 'Greece', 'Belarus', 'Monaco', 'Malta', 'Luxembourg', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco',",
            "To answer the question about the top 3 beneficiary banks by the number of filings involving transactions from Europe, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Country {country: 'EUR'})<-[:COUNTRY]-(f:Filing)-[:BENEFITS]->(e:Entity)\nWHERE e.country = 'EUR'\nRETURN e.name AS beneficiary_bank_name, COUNT(f) AS filing_count\nORDER BY filing_count DESC\nLIMIT 3;\n```\n\nThis query does the following:\n1. Matches countries that are in Europe (i.e., `country: 'EUR'`).\n2. Finds filings that involve these European countries.\n3. Counts the number of filings for each beneficiary bank that is also in Europe.\n4. Orders the results by the count of filings in descending order.\n5. Limits the result to the top 3 beneficiary banks."
        ],
        "generated_cyphers": [
            "To answer the question \"What are the top 3 beneficiary banks by the number of filings involving transactions from Europe?\", we need to:\n\n1. Identify the countries in Europe.\n2. Count the number of filings involving transactions from these countries.\n3. Sort the results by the number of filings in descending order.\n4. Limit the results to the top 3 banks.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (f:Filing)-[r:BENEFITS]->(b:Entity)\nWHERE b.location IS NOT NULL AND r.originator_bank_country IN ['AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'ES', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'PL', 'PT', 'RO', 'SK', 'SI', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', 'ES', '",
            "To answer this question, we need to identify beneficiary banks that have filed filings from Europe and then count the number of filings for each beneficiary bank. Finally, we will order these counts in descending order and select the top 3. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (e:Entity)-[:FILED]->(f:Filing)-[:BENEFITS]->(b:Entity)\nWHERE b.country = 'EU'\nRETURN b.name AS beneficiary_bank, COUNT(f.id) AS filing_count\nORDER BY filing_count DESC\nLIMIT 3;\n```\n\nThis query works as follows:\n- It starts from the `Entity` node and traverses to `Filing` through the `FILED` relationship.\n- It then traverses from `Filing` to `Entity` through the `BENEFITS` relationship.\n- It filters the `Entity` nodes in the `BENEFITS` relationship to only include those where the `country` is 'EU'.\n- It counts the number of filings for each beneficiary bank and orders the results by the count in descending order.\n- Finally, it limits the results to the top 3 beneficiary banks.",
            "To answer the question, we need to identify the top 3 beneficiary banks by the number of filings involving transactions from Europe. This involves querying the database to count the number of filings for each beneficiary bank and then ordering these counts in descending order.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Entity)-[r:BENEFITS]->(f:Filing)\nWHERE b.country IN ['IT', 'ES', 'FR', 'DE']  -- Countries in Europe\nRETURN b.name AS BeneficiaryBank, COUNT(f) AS FilingsCount\nORDER BY FilingsCount DESC\nLIMIT 3;\n```\n\n### Explanation:\n1. **MATCH (b:Entity)-[r:BENEFITS]->(f:Filing)**: This part of the query matches all relationships between entities (`Entity`) and filings (`Filing`) where the relationship is `BENEFITS`.\n2. **WHERE b.country IN ['IT', 'ES', 'FR', 'DE']**: This filters the entities to only include those from countries in Europe.\n3. **RETURN b.name AS BeneficiaryBank, COUNT(f) AS FilingsCount**: This selects the beneficiary bank's name and counts the number of filings associated with each bank.\n4. **ORDER BY FilingsCount DESC**: This orders the results by the number of filings in descending order.\n5. **LIMIT 3**: This limits the results to the top 3 beneficiary banks.\n\nThis query will return the names of the top 3 beneficiary banks in Europe along with the number of filings they have, sorted by the number of filings in descending order.",
            "To answer the question \"What are the top 3 beneficiary banks by the number of filings involving transactions from Europe?\", you can use the following Cypher query:\n\n```cypher\nMATCH (f:Filing)-[:BENEFITS]->(b:Entity)-[:COUNTRY]->(c:Country)\nWHERE c.name IN ['United Kingdom', 'Sweden', 'Netherlands', 'France', 'Germany', 'Denmark', 'Belgium', 'Ireland', 'Switzerland', 'Italy', 'Poland', 'Portugal', 'Austria', 'Romania', 'Spain', 'Hungary', 'Czech Republic', 'Slovakia', 'Slovenia', 'Norway', 'Estonia', 'Latvia', 'Lithuania', 'Luxembourg', 'Cyprus', 'Moldova', 'Malta', 'Finland', 'Greece', 'Belarus', 'Monaco', 'Malta', 'Luxembourg', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco', 'Monaco',",
            "To answer the question about the top 3 beneficiary banks by the number of filings involving transactions from Europe, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Country {country: 'EUR'})<-[:COUNTRY]-(f:Filing)-[:BENEFITS]->(e:Entity)\nWHERE e.country = 'EUR'\nRETURN e.name AS beneficiary_bank_name, COUNT(f) AS filing_count\nORDER BY filing_count DESC\nLIMIT 3;\n```\n\nThis query does the following:\n1. Matches countries that are in Europe (i.e., `country: 'EUR'`).\n2. Finds filings that involve these European countries.\n3. Counts the number of filings for each beneficiary bank that is also in Europe.\n4. Orders the results by the count of filings in descending order.\n5. Limits the result to the top 3 beneficiary banks."
        ]
    },
    {
        "question": "\"provide all exposed ports and the processes behind , for the ip '10.3.0.254', check multiple possible paths if the result is empty\"",
        "schema": "Node properties:\nDataCenter {name: STRING, location: STRING}\nRouter {name: STRING, zone: INTEGER}\nEgress {name: STRING}\nInterface {ip: STRING}\nNetwork {ip: STRING, size: INTEGER, zone: INTEGER}\nZone {ip: STRING, size: INTEGER, zone: INTEGER}\nRack {name: STRING, zone: INTEGER, rack: INTEGER}\nSwitch {ip: STRING, rack: INTEGER}\nType {id: INTEGER, type: STRING, ram: INTEGER, name: STRING, disk: INTEGER, cpu: INTEGER}\nMachine {name: STRING}\nSoftware {name: STRING, versions: LIST, ports: LIST, dependencies: LIST}\nOS {name: STRING, startTime: INTEGER}\nService {pid: INTEGER, name: STRING, startTime: INTEGER}\nApplication {name: STRING, startTime: INTEGER, pid: INTEGER}\nVersion {name: STRING}\nProcess {name: STRING, startTime: INTEGER, pid: INTEGER}\nPort {port: INTEGER}\nRelationship properties:\n\nThe relationships:\n(:DataCenter)-[:CONTAINS]->(:Rack)\n(:DataCenter)-[:CONTAINS]->(:Router)\n(:DataCenter)-[:CONTAINS]->(:Egress)\n(:Router)-[:ROUTES]->(:Interface)\n(:Egress)-[:ROUTES]->(:Interface)\n(:Interface)-[:EXPOSES]->(:Port)\n(:Interface)-[:CONNECTS]->(:Interface)\n(:Network)-[:ROUTES]->(:Interface)\n(:Zone)-[:ROUTES]->(:Interface)\n(:Rack)-[:HOLDS]->(:Machine)\n(:Rack)-[:HOLDS]->(:Switch)\n(:Switch)-[:ROUTES]->(:Interface)\n(:Machine)-[:RUNS]->(:OS)\n(:Machine)-[:RUNS]->(:Process)\n(:Machine)-[:RUNS]->(:Application)\n(:Machine)-[:RUNS]->(:Service)\n(:Machine)-[:ROUTES]->(:Interface)\n(:Machine)-[:TYPE]->(:Type)\n(:Software)-[:VERSION]->(:Version)\n(:Software)-[:DEPENDS_ON]->(:Version)\n(:Software)-[:DEPENDS_ON]->(:Software)\n(:Software)-[:DEPENDS_ON]->(:Application)\n(:Software)-[:DEPENDS_ON]->(:Service)\n(:OS)-[:INSTANCE]->(:Version)\n(:Service)-[:INSTANCE]->(:Software)\n(:Service)-[:INSTANCE]->(:Service)\n(:Service)-[:INSTANCE]->(:Application)\n(:Service)-[:INSTANCE]->(:Version)\n(:Service)-[:LISTENS]->(:Port)\n(:Application)-[:LISTENS]->(:Port)\n(:Application)-[:INSTANCE]->(:Software)\n(:Application)-[:INSTANCE]->(:Application)\n(:Application)-[:DEPENDS_ON]->(:Service)\n(:Application)-[:DEPENDS_ON]->(:Process)\n(:Version)-[:PREVIOUS]->(:Version)\n(:Process)-[:INSTANCE]->(:Software)\n(:Process)-[:INSTANCE]->(:Application)\n(:Process)-[:INSTANCE]->(:Version)\n(:Process)-[:INSTANCE]->(:Service)\n(:Process)-[:LISTENS]->(:Port)\n(:Process)-[:DEPENDS_ON]->(:Service)\n(:Process)-[:DEPENDS_ON]->(:Process)",
        "gold_cypher": "MATCH (i:Interface {ip: '10.3.0.254'})-[:EXPOSES]->(p:Port) OPTIONAL MATCH (i)<-[:ROUTES]-(:Router)-[:ROUTES]->(i2:Interface)-[:EXPOSES]->(p2:Port) OPTIONAL MATCH (i)<-[:ROUTES]-(:Egress)-[:ROUTES]->(i3:Interface)-[:EXPOSES]->(p3:Port) OPTIONAL MATCH (i)<-[:ROUTES]-(:Network)-[:ROUTES]->(i4:Interface)-[:EXPOSES]->(p4:Port) OPTIONAL MATCH (i)<-[:ROUTES]-(:Zone)-[:ROUTES]->(i5:Interface)-[:EXPOSES]->(p5:Port) OPTIONAL MATCH (i)<-[:ROUTES]-(:Switch)-[:ROUTES]->(i6:Interface)-[:EXPOSES]->(p6:Port) OPTIONAL MATCH (i)<-[:ROUTES]-(:Machine)-[:ROUTES]->(i7:Interface)-[:EXPOSES]->(p7:Port) WITH p, p2, p3, p4, p5, p6, p7 UNWIND [p, p2, p3, p4, p5, p6, p7] AS port MATCH (port)<-[:LISTENS]-(proc:Process) RETURN DISTINCT port.port AS ExposedPort, proc.name AS ProcessName, proc.pid AS ProcessID",
        "database": "network",
        "full_responses": [
            "To find all exposed ports and the processes behind the IP address `10.3.0.254`, you need to query the Neo4j database for the paths involving that IP address. The query will traverse the relationships to find interfaces that expose ports, and then follow the process instances to get the process names.\n\nHere is the Cypher query to achieve this:\n\n```cypher\nMATCH path = (i:Interface)-[r:EXPOSES]->(p:Port)-[o:INSTANCE]->(process:Process)\nWHERE i.ip = '10.3.0.254'\nRETURN DISTINCT p.port, process.name\n```\n\n### Explanation:\n- `MATCH path = (i:Interface)-[r:EXPOSES]->(p:Port)-[o:INSTANCE]->(process:Process)`: This pattern matches paths from an `Interface` to a `Port` through an `EXPOSES` relationship, and then from the `Port` to a `Process` through an `INSTANCE` relationship.\n- `WHERE i.ip = '10.3.0.254'`: This condition filters the results to only include paths where the interface's IP matches `10.3.0.254`.\n- `RETURN DISTINCT p.port, process.name`: This returns the distinct ports and the names of the processes behind those ports.\n\nThis query will return all exposed ports and the corresponding process names for the specified IP address. If there are no paths found, it will return an empty result set.",
            "To answer the question, we need to find all exposed ports and the processes running on the machine with the IP address '10.3.0.254'. Since the question mentions multiple possible paths, we will use a `UNWIND` clause to explore all paths from the machine to the ports.\n\nHere's the Cypher query:\n\n```cypher\nMATCH (m:Machine)-[r:RUNS]->(os:OS)-[p:INSTANCE]->(software:Software)\nWHERE m.ip = '10.3.0.254'\nWITH os, software\nUNWIND [\n  (os)-[i:ROUTES]->(i)-[p:EXPOSES]->(port:Port)\n] AS path\nRETURN path, software\n```\n\nThis query does the following:\n1. Finds all machines with the IP address '10.3.0.254'.\n2. Retrieves the OS instance running on the machine.\n3. Retrieves the software instances running on the machine.\n4. Uses a `UNWIND` clause to explore all paths from the OS to the ports (via interfaces).\n5. Returns each path along with the software instance.\n\nThis will provide all exposed ports and the processes behind the machine with IP '10.3.0.254'. If there are multiple paths, all of them will be included in the results.",
            "To answer this question, we need to find all exposed ports and the processes running on the machine with the IP address '10.3.0.254'. We can achieve this by tracing the path from the IP address to the exposed ports and then to the processes running on those interfaces. Here's the Cypher query to do that:\n\n```cypher\nMATCH (i:Interface)-[exposed:EXPOSES]->(p:Port)\nWHERE i.ip = '10.3.0.254'\nMATCH (i)-[routes:ROUTES]->(m:Machine)\nMATCH (m)-[runs:RUNS]->(os:OS)\nMATCH (m)-[runs:RUNS]->(process:Process)\nWHERE runs.startTime > 0\nRETURN p.port, process.pid, process.name\n```\n\n### Explanation:\n1. **MATCH (i:Interface)-[exposed:EXPOSES]->(p:Port)**: This pattern finds all interfaces that expose ports and matches the specific IP address '10.3.0.254'.\n2. **MATCH (i)-[routes:ROUTES]->(m:Machine)**: This pattern traces the route from the interface to the machine.\n3. **MATCH (m)-[runs:RUNS]->(os:OS)**: This pattern traces the route from the machine to the operating system (OS).\n4. **MATCH (m)-[runs:RUNS]->(process:Process)**: This pattern traces the route from the machine to the process.\n5. **WHERE runs.startTime > 0**: This ensures that only running processes are selected.\n6. **RETURN p.port, process.pid, process.name**: This returns the port number, process ID, and process name for each result.\n\nThis query will provide all exposed ports and the processes running on the machine with the IP address '10.3.0.254'. If no results are found, it will return an empty set.",
            "To find all exposed ports and the processes running on a specific IP address (`10.3.0.254`), you can use a combination of path queries and Cypher's pattern matching capabilities. The query will traverse the graph from the IP address to the processes running on it, collecting the exposed ports along the way.\n\nHere's the Cypher query:\n\n```cypher\nMATCH (i:Interface)-[r:EXPOSES]-(p:Port)-[r2:ROUTES]-(m:Machine)-[r3:RUNS]->(o:OS)\nWHERE i.ip = '10.3.0.254'\nRETURN p.port AS exposedPort, o.name AS processName\n```\n\n### Explanation:\n- **MATCH**: We start by matching the `Interface` node with the IP address `10.3.0.254`.\n- **[r:EXPOSES]**: We follow the `EXPOSES` relationship to the `Port` node, which represents the exposed port.\n- **[r2:ROUTES]**: We then follow the `ROUTES` relationship from the `Port` to the `Interface` to ensure we're on the correct path.\n- **[r3:RUNS]**: We continue following the `RUNS` relationship from the `Interface` to the `Machine` to trace the path from the IP to the machine.\n- **(o:OS)**: Finally, we match the `OS` node to get the name of the process running on the machine.\n\nThis query will return all exposed ports and the processes running on the machine with the IP address `10.3.0.254`. If there are multiple paths, it will return all of them.",
            "To answer the question, we need to find all exposed ports and the processes that run on them for the IP address `10.3.0.254`. We'll use a combination of Cypher queries to traverse the graph and find the necessary information. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (i:Interface)-[ex:EXPOSES]-(p:Port)\nWHERE i.ip = '10.3.0.254'\nRETURN p.port AS exposed_port, i.pid AS process_id\n```\n\nThis query does the following:\n1. `MATCH (i:Interface)-[ex:EXPOSES]-(p:Port)`: This pattern matches all `Interface` nodes that expose a `Port` and returns the `Port` and `Interface` nodes.\n2. `WHERE i.ip = '10.3.0.254'`: This filters the matches to only include the `Interface` with the IP address `10.3.0.254`.\n3. `RETURN p.port AS exposed_port, i.pid AS process_id`: This returns the port number and the process ID associated with the matched `Interface` node.\n\nThis query will return all exposed ports and the processes that run on them for the specified IP address. If no results are found, the query will return an empty result set."
        ],
        "generated_cyphers": [
            "To find all exposed ports and the processes behind the IP address `10.3.0.254`, you need to query the Neo4j database for the paths involving that IP address. The query will traverse the relationships to find interfaces that expose ports, and then follow the process instances to get the process names.\n\nHere is the Cypher query to achieve this:\n\n```cypher\nMATCH path = (i:Interface)-[r:EXPOSES]->(p:Port)-[o:INSTANCE]->(process:Process)\nWHERE i.ip = '10.3.0.254'\nRETURN DISTINCT p.port, process.name\n```\n\n### Explanation:\n- `MATCH path = (i:Interface)-[r:EXPOSES]->(p:Port)-[o:INSTANCE]->(process:Process)`: This pattern matches paths from an `Interface` to a `Port` through an `EXPOSES` relationship, and then from the `Port` to a `Process` through an `INSTANCE` relationship.\n- `WHERE i.ip = '10.3.0.254'`: This condition filters the results to only include paths where the interface's IP matches `10.3.0.254`.\n- `RETURN DISTINCT p.port, process.name`: This returns the distinct ports and the names of the processes behind those ports.\n\nThis query will return all exposed ports and the corresponding process names for the specified IP address. If there are no paths found, it will return an empty result set.",
            "To answer the question, we need to find all exposed ports and the processes running on the machine with the IP address '10.3.0.254'. Since the question mentions multiple possible paths, we will use a `UNWIND` clause to explore all paths from the machine to the ports.\n\nHere's the Cypher query:\n\n```cypher\nMATCH (m:Machine)-[r:RUNS]->(os:OS)-[p:INSTANCE]->(software:Software)\nWHERE m.ip = '10.3.0.254'\nWITH os, software\nUNWIND [\n  (os)-[i:ROUTES]->(i)-[p:EXPOSES]->(port:Port)\n] AS path\nRETURN path, software\n```\n\nThis query does the following:\n1. Finds all machines with the IP address '10.3.0.254'.\n2. Retrieves the OS instance running on the machine.\n3. Retrieves the software instances running on the machine.\n4. Uses a `UNWIND` clause to explore all paths from the OS to the ports (via interfaces).\n5. Returns each path along with the software instance.\n\nThis will provide all exposed ports and the processes behind the machine with IP '10.3.0.254'. If there are multiple paths, all of them will be included in the results.",
            "To answer this question, we need to find all exposed ports and the processes running on the machine with the IP address '10.3.0.254'. We can achieve this by tracing the path from the IP address to the exposed ports and then to the processes running on those interfaces. Here's the Cypher query to do that:\n\n```cypher\nMATCH (i:Interface)-[exposed:EXPOSES]->(p:Port)\nWHERE i.ip = '10.3.0.254'\nMATCH (i)-[routes:ROUTES]->(m:Machine)\nMATCH (m)-[runs:RUNS]->(os:OS)\nMATCH (m)-[runs:RUNS]->(process:Process)\nWHERE runs.startTime > 0\nRETURN p.port, process.pid, process.name\n```\n\n### Explanation:\n1. **MATCH (i:Interface)-[exposed:EXPOSES]->(p:Port)**: This pattern finds all interfaces that expose ports and matches the specific IP address '10.3.0.254'.\n2. **MATCH (i)-[routes:ROUTES]->(m:Machine)**: This pattern traces the route from the interface to the machine.\n3. **MATCH (m)-[runs:RUNS]->(os:OS)**: This pattern traces the route from the machine to the operating system (OS).\n4. **MATCH (m)-[runs:RUNS]->(process:Process)**: This pattern traces the route from the machine to the process.\n5. **WHERE runs.startTime > 0**: This ensures that only running processes are selected.\n6. **RETURN p.port, process.pid, process.name**: This returns the port number, process ID, and process name for each result.\n\nThis query will provide all exposed ports and the processes running on the machine with the IP address '10.3.0.254'. If no results are found, it will return an empty set.",
            "To find all exposed ports and the processes running on a specific IP address (`10.3.0.254`), you can use a combination of path queries and Cypher's pattern matching capabilities. The query will traverse the graph from the IP address to the processes running on it, collecting the exposed ports along the way.\n\nHere's the Cypher query:\n\n```cypher\nMATCH (i:Interface)-[r:EXPOSES]-(p:Port)-[r2:ROUTES]-(m:Machine)-[r3:RUNS]->(o:OS)\nWHERE i.ip = '10.3.0.254'\nRETURN p.port AS exposedPort, o.name AS processName\n```\n\n### Explanation:\n- **MATCH**: We start by matching the `Interface` node with the IP address `10.3.0.254`.\n- **[r:EXPOSES]**: We follow the `EXPOSES` relationship to the `Port` node, which represents the exposed port.\n- **[r2:ROUTES]**: We then follow the `ROUTES` relationship from the `Port` to the `Interface` to ensure we're on the correct path.\n- **[r3:RUNS]**: We continue following the `RUNS` relationship from the `Interface` to the `Machine` to trace the path from the IP to the machine.\n- **(o:OS)**: Finally, we match the `OS` node to get the name of the process running on the machine.\n\nThis query will return all exposed ports and the processes running on the machine with the IP address `10.3.0.254`. If there are multiple paths, it will return all of them.",
            "To answer the question, we need to find all exposed ports and the processes that run on them for the IP address `10.3.0.254`. We'll use a combination of Cypher queries to traverse the graph and find the necessary information. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (i:Interface)-[ex:EXPOSES]-(p:Port)\nWHERE i.ip = '10.3.0.254'\nRETURN p.port AS exposed_port, i.pid AS process_id\n```\n\nThis query does the following:\n1. `MATCH (i:Interface)-[ex:EXPOSES]-(p:Port)`: This pattern matches all `Interface` nodes that expose a `Port` and returns the `Port` and `Interface` nodes.\n2. `WHERE i.ip = '10.3.0.254'`: This filters the matches to only include the `Interface` with the IP address `10.3.0.254`.\n3. `RETURN p.port AS exposed_port, i.pid AS process_id`: This returns the port number and the process ID associated with the matched `Interface` node.\n\nThis query will return all exposed ports and the processes that run on them for the specified IP address. If no results are found, the query will return an empty result set."
        ]
    },
    {
        "question": "What are the top 3 beneficiary entities in transactions from Asia?",
        "schema": "Node properties:\n- **Country**\n  - `location`: POINT \n  - `code`: STRING Example: \"AFG\"\n  - `name`: STRING Example: \"Afghanistan\"\n  - `tld`: STRING Example: \"AF\"\n- **Filing**\n  - `begin`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-09-05T00:00:00Z\n  - `end`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-11-03T00:00:00Z\n  - `originator_bank_id`: STRING Example: \"cimb-bank-berhad\"\n  - `sar_id`: STRING Example: \"3297\"\n  - `beneficiary_bank`: STRING Example: \"Barclays Bank Plc\"\n  - `filer_org_name_id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `originator_bank_country`: STRING Example: \"Singapore\"\n  - `beneficiary_bank_country`: STRING Example: \"United Kingdom\"\n  - `filer_org_name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `originator_iso`: STRING Example: \"SGP\"\n  - `beneficiary_bank_id`: STRING Example: \"barclays-bank-plc-london-england-gbr\"\n  - `origin_lat`: STRING Example: \"1.3667\"\n  - `origin_lng`: STRING Example: \"103.8\"\n  - `end_date_format`: STRING Example: \"2015-09-25T00:00:00Z\"\n  - `begin_date_format`: STRING Example: \"2015-03-25T00:00:00Z\"\n  - `originator_bank`: STRING Example: \"CIMB Bank Berhad\"\n  - `beneficiary_lat`: STRING Example: \"54\"\n  - `beneficiary_iso`: STRING Example: \"GBR\"\n  - `beneficiary_lng`: STRING Example: \"-2\"\n  - `begin_date`: STRING Example: \"Mar 25, 2015\"\n  - `id`: STRING Example: \"223254\"\n  - `end_date`: STRING Example: \"Sep 25, 2015\"\n  - `amount`: INTEGER Min: 1.18, Max: 2721000000\n  - `number`: INTEGER Min: 1, Max: 174\n- **Entity**\n  - `id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `location`: POINT \n  - `name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `country`: STRING Example: \"CHN\"\nRelationship properties:\n\nThe relationships:\n(:Filing)-[:BENEFITS]->(:Entity)\n(:Filing)-[:CONCERNS]->(:Entity)\n(:Filing)-[:ORIGINATOR]->(:Entity)\n(:Entity)-[:FILED]->(:Filing)\n(:Entity)-[:COUNTRY]->(:Country)",
        "gold_cypher": "MATCH (f:Filing)-[:BENEFITS]->(e:Entity)-[:COUNTRY]->(c:Country) WHERE c.name IN ['China', 'India', 'Indonesia', 'Pakistan', 'Bangladesh', 'Japan', 'Philippines', 'Vietnam', 'Turkey', 'Iran', 'Thailand', 'Myanmar', 'South Korea', 'Iraq', 'Afghanistan', 'Saudi Arabia', 'Uzbekistan', 'Malaysia', 'Yemen', 'Nepal', 'North Korea', 'Sri Lanka', 'Kazakhstan', 'Syria', 'Cambodia', 'Jordan', 'Azerbaijan', 'United Arab Emirates', 'Tajikistan', 'Israel', 'Laos', 'Lebanon', 'Kyrgyzstan', 'Turkmenistan', 'Singapore', 'Oman', 'State of Palestine', 'Kuwait', 'Georgia', 'Mongolia', 'Armenia', 'Qatar', 'Bahrain', 'Timor-Leste', 'Cyprus', 'Bhutan', 'Maldives', 'Brunei'] WITH e, count(f) AS transactions ORDER BY transactions DESC LIMIT 3 RETURN e.name AS EntityName, transactions",
        "database": "fincen",
        "full_responses": [
            "```cypher\nMATCH (f:Filing)-[:BENEFITS]->(b:Entity)\nWHERE b.country = 'AUS' OR b.country = 'IND' OR b.country = 'MYS' OR b.country = 'NPL' OR b.country = 'SGP' OR b.country = 'TWN' OR b.country = 'THA'\nRETURN b.name AS beneficiary_name, COUNT(*) AS transaction_count\nORDER BY transaction_count DESC\nLIMIT 3\n```",
            "To answer the question \"What are the top 3 beneficiary entities in transactions from Asia?\", you can use the following Cypher query. This query will aggregate the filings by beneficiary country and then order the results by the number of filings in descending order to find the top 3 beneficiary entities.\n\n```cypher\nMATCH (f: Filing)-[r:BENEFITS]->(b: Entity)\nWHERE b.country = 'CHN' OR b.country = 'JP' OR b.country = 'RU' OR b.country = 'IN' OR b.country = 'KH'\nRETURN b.name AS BeneficiaryEntity, COUNT(r) AS NumberOfFilings\nORDER BY NumberOfFilings DESC\nLIMIT 3;\n```\n\nThis query does the following:\n- Matches all relationships of type `BENEFITS` from filings to beneficiary entities.\n- Filters the beneficiaries to include only those from Asia (China, Japan, Russia, India, and Cambodia).\n- Counts the number of filings for each beneficiary entity.\n- Orders the results by the number of filings in descending order.\n- Limits the results to the top 3 entities.",
            "To find the top 3 beneficiary entities in transactions from Asia, you can use the following Cypher query:\n\n```cypher\nMATCH (f: Filing)-[b: BENEFITS]->(e: Entity)-[c: COUNTRY]->(co: Country)\nWHERE co.name = 'Asia'\nRETURN e.name AS Beneficiary, COUNT(f) AS TransactionCount\nORDER BY TransactionCount DESC\nLIMIT 3;\n```\n\nThis query does the following:\n- `MATCH (f: Filing)-[b: BENEFITS]->(e: Entity)-[c: COUNTRY]->(co: Country)`: Matches filings that have a benefit to entities and those entities have a country relationship, where the country is 'Asia'.\n- `WHERE co.name = 'Asia'`: Filters the results to only include filings from countries in Asia.\n- `RETURN e.name AS Beneficiary, COUNT(f) AS TransactionCount`: Returns the name of the beneficiary entity and the count of transactions for each beneficiary.\n- `ORDER BY TransactionCount DESC`: Orders the results by the count of transactions in descending order.\n- `LIMIT 3`: Limits the results to the top 3 beneficiaries.",
            "```cypher\nMATCH (f:Filing)-[r:BENEFITS]->(b:Entity)\nWITH b, r.amount AS amount\nWHERE b.country IN [\"AFG\", \"IND\", \"CHN\"]  -- Adding more countries if needed\nRETURN b.name AS beneficiary, SUM(amount) AS total_amount\nORDER BY total_amount DESC\nLIMIT 3\n```",
            "```cypher\nMATCH (f: Filing)-[r:BENEFITS]->(e:Entity)\nWITH e.name AS entityName, COUNT(f) AS transactionCount\nWHERE e.location.country IN ['CHN', 'KOR', 'IND', 'PRK', 'JPN', 'THA', 'MMR', 'MYA', 'CYP', 'LAO']\nORDER BY transactionCount DESC\nLIMIT 3\n```\n\nThis query matches all filings that have a beneficiary entity and counts the number of transactions for each beneficiary entity. It then filters the results to include only entities located in Asia (countries with codes 'CHN', 'KOR', 'IND', 'PRK', 'JPN', 'THA', 'MMR', 'MYA', 'CYP', 'LAO'). It orders the results by the number of transactions in descending order and limits the output to the top 3 entities."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (f:Filing)-[:BENEFITS]->(b:Entity)\nWHERE b.country = 'AUS' OR b.country = 'IND' OR b.country = 'MYS' OR b.country = 'NPL' OR b.country = 'SGP' OR b.country = 'TWN' OR b.country = 'THA'\nRETURN b.name AS beneficiary_name, COUNT(*) AS transaction_count\nORDER BY transaction_count DESC\nLIMIT 3\n```",
            "To answer the question \"What are the top 3 beneficiary entities in transactions from Asia?\", you can use the following Cypher query. This query will aggregate the filings by beneficiary country and then order the results by the number of filings in descending order to find the top 3 beneficiary entities.\n\n```cypher\nMATCH (f: Filing)-[r:BENEFITS]->(b: Entity)\nWHERE b.country = 'CHN' OR b.country = 'JP' OR b.country = 'RU' OR b.country = 'IN' OR b.country = 'KH'\nRETURN b.name AS BeneficiaryEntity, COUNT(r) AS NumberOfFilings\nORDER BY NumberOfFilings DESC\nLIMIT 3;\n```\n\nThis query does the following:\n- Matches all relationships of type `BENEFITS` from filings to beneficiary entities.\n- Filters the beneficiaries to include only those from Asia (China, Japan, Russia, India, and Cambodia).\n- Counts the number of filings for each beneficiary entity.\n- Orders the results by the number of filings in descending order.\n- Limits the results to the top 3 entities.",
            "To find the top 3 beneficiary entities in transactions from Asia, you can use the following Cypher query:\n\n```cypher\nMATCH (f: Filing)-[b: BENEFITS]->(e: Entity)-[c: COUNTRY]->(co: Country)\nWHERE co.name = 'Asia'\nRETURN e.name AS Beneficiary, COUNT(f) AS TransactionCount\nORDER BY TransactionCount DESC\nLIMIT 3;\n```\n\nThis query does the following:\n- `MATCH (f: Filing)-[b: BENEFITS]->(e: Entity)-[c: COUNTRY]->(co: Country)`: Matches filings that have a benefit to entities and those entities have a country relationship, where the country is 'Asia'.\n- `WHERE co.name = 'Asia'`: Filters the results to only include filings from countries in Asia.\n- `RETURN e.name AS Beneficiary, COUNT(f) AS TransactionCount`: Returns the name of the beneficiary entity and the count of transactions for each beneficiary.\n- `ORDER BY TransactionCount DESC`: Orders the results by the count of transactions in descending order.\n- `LIMIT 3`: Limits the results to the top 3 beneficiaries.",
            "```cypher\nMATCH (f:Filing)-[r:BENEFITS]->(b:Entity)\nWITH b, r.amount AS amount\nWHERE b.country IN [\"AFG\", \"IND\", \"CHN\"]  -- Adding more countries if needed\nRETURN b.name AS beneficiary, SUM(amount) AS total_amount\nORDER BY total_amount DESC\nLIMIT 3\n```",
            "```cypher\nMATCH (f: Filing)-[r:BENEFITS]->(e:Entity)\nWITH e.name AS entityName, COUNT(f) AS transactionCount\nWHERE e.location.country IN ['CHN', 'KOR', 'IND', 'PRK', 'JPN', 'THA', 'MMR', 'MYA', 'CYP', 'LAO']\nORDER BY transactionCount DESC\nLIMIT 3\n```\n\nThis query matches all filings that have a beneficiary entity and counts the number of transactions for each beneficiary entity. It then filters the results to include only entities located in Asia (countries with codes 'CHN', 'KOR', 'IND', 'PRK', 'JPN', 'THA', 'MMR', 'MYA', 'CYP', 'LAO'). It orders the results by the number of transactions in descending order and limits the output to the top 3 entities."
        ]
    },
    {
        "question": "What is the most common sentiment expressed in reviews for each business (positive, negative, or neutral)?",
        "schema": "Node properties:\n- **Business**\n  - `address`: STRING Available options: ['301 E Main St', '200 W Pine St', '313 N 1st St W', '1151 W Broadway St', '201 E Front St', '723 California Dr', '121 W Broadway St', '716 N San Mateo Dr', '111 E 5th Ave']\n  - `location`: POINT \n  - `city`: STRING Available options: ['Missoula', 'Burlingame', 'San Mateo']\n  - `state`: STRING Available options: ['MT', 'CA']\n  - `businessId`: STRING Available options: ['b5', 'b3', 'b1', 'b2', 'b4', 'b7', 'b6', 'b8', 'b9']\n  - `name`: STRING Available options: ['Missoula Public Library', \"Ninja Mike's\", 'KettleHouse Brewing Co.', 'Imagine Nation Brewing', 'Market on Front', 'Hanabi', 'Zootown Brew', \"Ducky's Car Wash\", 'Neo4j']\n- **User**\n  - `name`: STRING Available options: ['Will', 'Bob', 'Jenny', 'Angie']\n  - `userId`: STRING Available options: ['u1', 'u2', 'u3', 'u4']\n- **Review**\n  - `date`: DATE Min: 2015-08-29, Max: 2018-09-10\n  - `text`: STRING Available options: ['Not a great selection of books, but fortunately th', \"Best breakfast sandwich at the Farmer's Market. Al\", 'Great IPA selection!', \"Awesome full-service car wash. Love Ducky's!\", \"The world's leading graph database HQ!\"]\n  - `stars`: FLOAT Min: 3.0, Max: 5.0\n  - `reviewId`: STRING Example: \"r7\"\n- **Category**\n  - `name`: STRING Example: \"Library\"\nRelationship properties:\n\nThe relationships:\n(:Business)-[:IN_CATEGORY]->(:Category)\n(:User)-[:WROTE]->(:Review)\n(:Review)-[:REVIEWS]->(:Business)",
        "gold_cypher": "WITH [1, 2] AS negativeStars, [4, 5] AS positiveStars MATCH (b:Business)<-[:REVIEWS]-(r:Review) WITH b, r, CASE      WHEN r.stars IN negativeStars THEN \"negative\"     WHEN r.stars IN positiveStars THEN \"positive\"     ELSE \"neutral\"  END AS sentiment WITH b, sentiment, count(*) AS sentimentCount WITH b, collect({sentiment: sentiment, count: sentimentCount}) AS sentimentCounts RETURN b.name AS businessName,         reduce(            mostCommon = {sentiment: \"none\", count: 0},             sentimentCount IN sentimentCounts |             CASE                 WHEN sentimentCount.count > mostCommon.count THEN sentimentCount                 ELSE mostCommon             END        ) AS mostCommonSentiment",
        "database": "grandstack",
        "full_responses": [
            "To answer the question \"What is the most common sentiment expressed in reviews for each business (positive, negative, or neutral)?\", we need to analyze the sentiment of each review and then group the reviews by business to find the most common sentiment for each. Here's how you can write the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWITH b, rv\nOPTIONAL MATCH (rv)-[sentiment:HAS_SENTIMENT {sentimentType: 'Positive'}]->(score:Score)\nOPTIONAL MATCH (rv)-[sentiment:HAS_SENTIMENT {sentimentType: 'Negative'}]->(score:Score)\nOPTIONAL MATCH (rv)-[sentiment:HAS_SENTIMENT {sentimentType: 'Neutral'}]->(score:Score)\nWITH b, rv, coalesce(score.stars, 0) AS stars, sentiment.sentimentType AS sentimentType\nRETURN b.businessId AS businessId, sentimentType, stars\nORDER BY b.businessId, stars DESC, sentimentType\nGROUP BY b.businessId, stars, sentimentType\n```\n\n### Explanation:\n1. **MATCH (b:Business)-[r:REVIEWS]->(rv:Review)**: This pattern matches businesses and their reviews.\n2. **OPTIONAL MATCH**: This is used to handle cases where a review might not have a sentiment assigned. The `coalesce` function is used to handle the case where no sentiment is found, filling it with 0.\n3. **WITH b, rv, coalesce(score.stars, 0) AS stars, sentiment.sentimentType AS sentimentType**: This part is used to group the results by business and sentiment type, and it assigns the stars of the review to the sentiment.\n4. **RETURN b.businessId AS businessId, sentimentType, stars**: This part specifies the fields to return.\n5. **ORDER BY b.businessId, stars DESC, sentimentType**: This is used to order the results by business, then by the sentiment score in descending order, and finally by the sentiment type.\n6. **GROUP BY b.businessId, stars, sentimentType**: This is used to group the results by business, stars, and sentiment type to calculate the most common sentiment for each business.\n\nThis query will give you the most common sentiment expressed in reviews for each business, grouped by stars.",
            "To determine the most common sentiment expressed in reviews for each business, you can use the following Cypher query. This query calculates the sentiment score for each review and then aggregates the sentiment scores to determine the most common sentiment for each business.\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWITH b, rev, CASE WHEN rev.stars >= 4 THEN 1 ELSE 0 END AS positive, CASE WHEN rev.stars <= 2 THEN -1 ELSE 0 END AS negative\nRETURN b.businessId AS businessId, b.name AS businessName, SUM(positive) AS positiveCount, SUM(negative) AS negativeCount\nORDER BY positiveCount DESC, negativeCount DESC;\n```\n\n### Explanation:\n1. **MATCH (b:Business)-[r:REVIEWS]->(rev:Review)**: This pattern matches businesses and their reviews.\n2. **WITH b, rev, CASE WHEN rev.stars >= 4 THEN 1 ELSE 0 END AS positive, CASE WHEN rev.stars <= 2 THEN -1 ELSE 0 END AS negative**: This clause calculates the sentiment score for each review:\n   - If the review stars are 4 or above, the sentiment is +1.\n   - If the review stars are 2 or below, the sentiment is -1.\n   - If the review stars are between 3 and 4, the sentiment is 0.\n3. **RETURN b.businessId AS businessId, b.name AS businessName, SUM(positive) AS positiveCount, SUM(negative) AS negativeCount**: This clause returns the business ID, name, and the count of positive and negative sentiments for each business.\n4. **ORDER BY positiveCount DESC, negativeCount DESC**: This orders the results by the count of positive and negative sentiments in descending order, so the most common sentiment is at the top.\n\nThis query will give you the most common sentiment expressed in reviews for each business, either positive, negative, or neutral.",
            "To determine the most common sentiment expressed in reviews for each business, you can use the following Cypher query. This query will calculate the sentiment score for each business and then identify the most common sentiment based on these scores.\n\n```cypher\nWITH \n  (CASE WHEN stars >= 4 THEN 1 ELSE 0 END) AS positive,\n  (CASE WHEN stars <= 2 THEN -1 ELSE 0 END) AS negative,\n  stars AS neutral,\n  b.name AS business_name,\n  r.text AS review_text\nFROM Review r\nJOIN Business b ON r.business_id = b.business_id\nGROUP BY business_name, review_text, positive, negative, neutral\nORDER BY business_name, positive DESC, negative DESC, neutral DESC\nLIMIT 10;\n\nWITH \n  (CASE WHEN positive > negative THEN 'Positive' WHEN negative > positive THEN 'Negative' ELSE 'Neutral' END) AS sentiment,\n  business_name\nFROM (\n  WITH \n    (CASE WHEN stars >= 4 THEN 1 ELSE 0 END) AS positive,\n    (CASE WHEN stars <= 2 THEN -1 ELSE 0 END) AS negative,\n    stars AS neutral,\n    b.name AS business_name,\n    r.text AS review_text\n  FROM Review r\n  JOIN Business b ON r.business_id = b.business_id\n  GROUP BY business_name, review_text, positive, negative, neutral\n  ORDER BY business_name, positive DESC, negative DESC, neutral DESC\n  LIMIT 10\n) AS result\nGROUP BY sentiment, business_name\nORDER BY sentiment DESC\nLIMIT 1;\n```\n\nThis query first calculates the sentiment score for each business by assigning a value of 1 for positive reviews, -1 for negative reviews, and 0 for neutral reviews based on the review stars. It then groups the results by business name and sentiment, ordering them to find the most common sentiment for each business. The second part of the query uses these results to identify the overall most common sentiment across all businesses.",
            "To determine the most common sentiment expressed in reviews for each business, you can use the following Cypher query. This query will aggregate the reviews for each business and count the occurrences of positive, negative, and neutral sentiments.\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(review:Review)\nWITH b, review.text AS reviewText\nWHERE reviewText =~ '.*\\\\bpositive\\\\b.*' OR reviewText =~ '.*\\\\bnegative\\\\b.*' OR reviewText =~ '.*\\\\bneutral\\\\b.*'\nRETURN b.name AS businessName, COUNT(CASE WHEN reviewText =~ '.*\\\\bpositive\\\\b.*' THEN 1 ELSE NULL END) AS positiveCount,\n       COUNT(CASE WHEN reviewText =~ '.*\\\\bnegative\\\\b.*' THEN 1 ELSE NULL END) AS negativeCount,\n       COUNT(CASE WHEN reviewText =~ '.*\\\\bneutral\\\\b.*' THEN 1 ELSE NULL END) AS neutralCount\nORDER BY businessName;\n```\n\n### Explanation:\n- **MATCH (b:Business)-[r:REVIEWS]->(review:Review)**: This pattern matches each business node and its associated reviews.\n- **WITH b, review.text AS reviewText**: This collects the business name and the text of each review for further processing.\n- **WHERE reviewText =~ '.*\\\\bpositive\\\\b.*' OR reviewText =~ '.*\\\\bnegative\\\\b.*' OR reviewText =~ '.*\\\\bneutral\\\\b.*'**: This filters the reviews to include only those that contain the words \"positive\", \"negative\", or \"neutral\".\n- **RETURN b.name AS businessName, COUNT(...)**: This returns the business name and counts the occurrences of positive, negative, and neutral sentiments.\n- **ORDER BY businessName**: This sorts the results by business name for easier readability.\n\nThis query will output the most common sentiment expressed in reviews for each business, categorized as positive, negative, or neutral.",
            "To determine the most common sentiment expressed in reviews for each business, you can use the following Cypher query. This query will calculate the sentiment polarity for each review and then group by business to find the most common sentiment.\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWITH b, rev.text AS reviewText\nUNWIND [\"positive\", \"negative\", \"neutral\"] AS sentiment\nWITH b, sentiment, COUNT(reviewText) AS count\nORDER BY count DESC\nLIMIT 1\nRETURN b.name AS BusinessName, sentiment AS MostCommonSentiment\n```\n\nThis query does the following:\n1. Matches businesses and reviews connected by the `REVIEWS` relationship.\n2. Unwinds the list of possible sentiments (`[\"positive\", \"negative\", \"neutral\"]`) to handle each sentiment separately.\n3. Counts the number of reviews for each sentiment for each business.\n4. Orders the results by the count of each sentiment in descending order.\n5. Limits the results to the most common sentiment for each business.\n6. Returns the business name and the most common sentiment."
        ],
        "generated_cyphers": [
            "To answer the question \"What is the most common sentiment expressed in reviews for each business (positive, negative, or neutral)?\", we need to analyze the sentiment of each review and then group the reviews by business to find the most common sentiment for each. Here's how you can write the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWITH b, rv\nOPTIONAL MATCH (rv)-[sentiment:HAS_SENTIMENT {sentimentType: 'Positive'}]->(score:Score)\nOPTIONAL MATCH (rv)-[sentiment:HAS_SENTIMENT {sentimentType: 'Negative'}]->(score:Score)\nOPTIONAL MATCH (rv)-[sentiment:HAS_SENTIMENT {sentimentType: 'Neutral'}]->(score:Score)\nWITH b, rv, coalesce(score.stars, 0) AS stars, sentiment.sentimentType AS sentimentType\nRETURN b.businessId AS businessId, sentimentType, stars\nORDER BY b.businessId, stars DESC, sentimentType\nGROUP BY b.businessId, stars, sentimentType\n```\n\n### Explanation:\n1. **MATCH (b:Business)-[r:REVIEWS]->(rv:Review)**: This pattern matches businesses and their reviews.\n2. **OPTIONAL MATCH**: This is used to handle cases where a review might not have a sentiment assigned. The `coalesce` function is used to handle the case where no sentiment is found, filling it with 0.\n3. **WITH b, rv, coalesce(score.stars, 0) AS stars, sentiment.sentimentType AS sentimentType**: This part is used to group the results by business and sentiment type, and it assigns the stars of the review to the sentiment.\n4. **RETURN b.businessId AS businessId, sentimentType, stars**: This part specifies the fields to return.\n5. **ORDER BY b.businessId, stars DESC, sentimentType**: This is used to order the results by business, then by the sentiment score in descending order, and finally by the sentiment type.\n6. **GROUP BY b.businessId, stars, sentimentType**: This is used to group the results by business, stars, and sentiment type to calculate the most common sentiment for each business.\n\nThis query will give you the most common sentiment expressed in reviews for each business, grouped by stars.",
            "To determine the most common sentiment expressed in reviews for each business, you can use the following Cypher query. This query calculates the sentiment score for each review and then aggregates the sentiment scores to determine the most common sentiment for each business.\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWITH b, rev, CASE WHEN rev.stars >= 4 THEN 1 ELSE 0 END AS positive, CASE WHEN rev.stars <= 2 THEN -1 ELSE 0 END AS negative\nRETURN b.businessId AS businessId, b.name AS businessName, SUM(positive) AS positiveCount, SUM(negative) AS negativeCount\nORDER BY positiveCount DESC, negativeCount DESC;\n```\n\n### Explanation:\n1. **MATCH (b:Business)-[r:REVIEWS]->(rev:Review)**: This pattern matches businesses and their reviews.\n2. **WITH b, rev, CASE WHEN rev.stars >= 4 THEN 1 ELSE 0 END AS positive, CASE WHEN rev.stars <= 2 THEN -1 ELSE 0 END AS negative**: This clause calculates the sentiment score for each review:\n   - If the review stars are 4 or above, the sentiment is +1.\n   - If the review stars are 2 or below, the sentiment is -1.\n   - If the review stars are between 3 and 4, the sentiment is 0.\n3. **RETURN b.businessId AS businessId, b.name AS businessName, SUM(positive) AS positiveCount, SUM(negative) AS negativeCount**: This clause returns the business ID, name, and the count of positive and negative sentiments for each business.\n4. **ORDER BY positiveCount DESC, negativeCount DESC**: This orders the results by the count of positive and negative sentiments in descending order, so the most common sentiment is at the top.\n\nThis query will give you the most common sentiment expressed in reviews for each business, either positive, negative, or neutral.",
            "To determine the most common sentiment expressed in reviews for each business, you can use the following Cypher query. This query will calculate the sentiment score for each business and then identify the most common sentiment based on these scores.\n\n```cypher\nWITH \n  (CASE WHEN stars >= 4 THEN 1 ELSE 0 END) AS positive,\n  (CASE WHEN stars <= 2 THEN -1 ELSE 0 END) AS negative,\n  stars AS neutral,\n  b.name AS business_name,\n  r.text AS review_text\nFROM Review r\nJOIN Business b ON r.business_id = b.business_id\nGROUP BY business_name, review_text, positive, negative, neutral\nORDER BY business_name, positive DESC, negative DESC, neutral DESC\nLIMIT 10;\n\nWITH \n  (CASE WHEN positive > negative THEN 'Positive' WHEN negative > positive THEN 'Negative' ELSE 'Neutral' END) AS sentiment,\n  business_name\nFROM (\n  WITH \n    (CASE WHEN stars >= 4 THEN 1 ELSE 0 END) AS positive,\n    (CASE WHEN stars <= 2 THEN -1 ELSE 0 END) AS negative,\n    stars AS neutral,\n    b.name AS business_name,\n    r.text AS review_text\n  FROM Review r\n  JOIN Business b ON r.business_id = b.business_id\n  GROUP BY business_name, review_text, positive, negative, neutral\n  ORDER BY business_name, positive DESC, negative DESC, neutral DESC\n  LIMIT 10\n) AS result\nGROUP BY sentiment, business_name\nORDER BY sentiment DESC\nLIMIT 1;\n```\n\nThis query first calculates the sentiment score for each business by assigning a value of 1 for positive reviews, -1 for negative reviews, and 0 for neutral reviews based on the review stars. It then groups the results by business name and sentiment, ordering them to find the most common sentiment for each business. The second part of the query uses these results to identify the overall most common sentiment across all businesses.",
            "To determine the most common sentiment expressed in reviews for each business, you can use the following Cypher query. This query will aggregate the reviews for each business and count the occurrences of positive, negative, and neutral sentiments.\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(review:Review)\nWITH b, review.text AS reviewText\nWHERE reviewText =~ '.*\\\\bpositive\\\\b.*' OR reviewText =~ '.*\\\\bnegative\\\\b.*' OR reviewText =~ '.*\\\\bneutral\\\\b.*'\nRETURN b.name AS businessName, COUNT(CASE WHEN reviewText =~ '.*\\\\bpositive\\\\b.*' THEN 1 ELSE NULL END) AS positiveCount,\n       COUNT(CASE WHEN reviewText =~ '.*\\\\bnegative\\\\b.*' THEN 1 ELSE NULL END) AS negativeCount,\n       COUNT(CASE WHEN reviewText =~ '.*\\\\bneutral\\\\b.*' THEN 1 ELSE NULL END) AS neutralCount\nORDER BY businessName;\n```\n\n### Explanation:\n- **MATCH (b:Business)-[r:REVIEWS]->(review:Review)**: This pattern matches each business node and its associated reviews.\n- **WITH b, review.text AS reviewText**: This collects the business name and the text of each review for further processing.\n- **WHERE reviewText =~ '.*\\\\bpositive\\\\b.*' OR reviewText =~ '.*\\\\bnegative\\\\b.*' OR reviewText =~ '.*\\\\bneutral\\\\b.*'**: This filters the reviews to include only those that contain the words \"positive\", \"negative\", or \"neutral\".\n- **RETURN b.name AS businessName, COUNT(...)**: This returns the business name and counts the occurrences of positive, negative, and neutral sentiments.\n- **ORDER BY businessName**: This sorts the results by business name for easier readability.\n\nThis query will output the most common sentiment expressed in reviews for each business, categorized as positive, negative, or neutral.",
            "To determine the most common sentiment expressed in reviews for each business, you can use the following Cypher query. This query will calculate the sentiment polarity for each review and then group by business to find the most common sentiment.\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWITH b, rev.text AS reviewText\nUNWIND [\"positive\", \"negative\", \"neutral\"] AS sentiment\nWITH b, sentiment, COUNT(reviewText) AS count\nORDER BY count DESC\nLIMIT 1\nRETURN b.name AS BusinessName, sentiment AS MostCommonSentiment\n```\n\nThis query does the following:\n1. Matches businesses and reviews connected by the `REVIEWS` relationship.\n2. Unwinds the list of possible sentiments (`[\"positive\", \"negative\", \"neutral\"]`) to handle each sentiment separately.\n3. Counts the number of reviews for each sentiment for each business.\n4. Orders the results by the count of each sentiment in descending order.\n5. Limits the results to the most common sentiment for each business.\n6. Returns the business name and the most common sentiment."
        ]
    },
    {
        "question": "List the customers who have purchased products from the same supplier as 'Alfreds Futterkiste'.",
        "schema": "Node properties:\n- **Product**\n  - `productName`: STRING Example: \"Chai\"\n  - `quantityPerUnit`: STRING Example: \"10 boxes x 20 bags\"\n  - `unitsOnOrder`: INTEGER Min: 0, Max: 100\n  - `supplierID`: STRING Example: \"1\"\n  - `productID`: STRING Example: \"1\"\n  - `discontinued`: BOOLEAN \n  - `categoryID`: STRING Available options: ['1', '2', '7', '6', '8', '4', '3', '5']\n  - `reorderLevel`: INTEGER Min: 0, Max: 30\n  - `unitsInStock`: INTEGER Min: 0, Max: 125\n  - `unitPrice`: FLOAT Min: 2.5, Max: 263.5\n- **Category**\n  - `picture`: STRING Available options: ['0x151C2F00020000000D000E0014002100FFFFFFFF4269746D']\n  - `categoryID`: STRING Available options: ['1', '2', '3', '4', '5', '6', '7', '8']\n  - `description`: STRING Available options: ['Soft drinks, coffees, teas, beers, and ales', 'Sweet and savory sauces, relishes, spreads, and se', 'Desserts, candies, and sweet breads', 'Cheeses', 'Breads, crackers, pasta, and cereal', 'Prepared meats', 'Dried fruit and bean curd', 'Seaweed and fish']\n  - `categoryName`: STRING Available options: ['Beverages', 'Condiments', 'Confections', 'Dairy Products', 'Grains/Cereals', 'Meat/Poultry', 'Produce', 'Seafood']\n- **Supplier**\n  - `companyName`: STRING Example: \"Exotic Liquids\"\n  - `contactName`: STRING Example: \"Charlotte Cooper\"\n  - `homePage`: STRING Available options: ['NULL', '#CAJUN.HTM#', \"Mayumi's (on the World Wide Web)#http://www.micros\", '(03) 444-6588', 'Plutzer (on the World Wide Web)#http://www.microso', '(0544) 60603', '(1) 03.83.00.62', '(02) 555-4873', '(089) 6547667', '38.76.98.58']\n  - `phone`: STRING Example: \"(171) 555-2222\"\n  - `postalCode`: STRING Example: \"EC1 4SD\"\n  - `contactTitle`: STRING Example: \"Purchasing Manager\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"49 Gilbert St.\"\n  - `fax`: STRING Example: \"NULL\"\n  - `supplierID`: STRING Example: \"1\"\n  - `country`: STRING Example: \"UK\"\n  - `city`: STRING Example: \"London\"\n- **Customer**\n  - `fax`: STRING Example: \"030-0076545\"\n  - `companyName`: STRING Example: \"Alfreds Futterkiste\"\n  - `customerID`: STRING Example: \"ALFKI\"\n  - `phone`: STRING Example: \"030-0074321\"\n  - `contactName`: STRING Example: \"Maria Anders\"\n  - `contactTitle`: STRING Example: \"Sales Representative\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"Obere Str. 57\"\n  - `postalCode`: STRING Example: \"12209\"\n  - `country`: STRING Example: \"Germany\"\n  - `city`: STRING Example: \"Berlin\"\n- **Order**\n  - `shipName`: STRING Example: \"Vins et alcools Chevalier\"\n  - `requiredDate`: STRING Example: \"1996-08-01 00:00:00.000\"\n  - `shipCity`: STRING Example: \"Reims\"\n  - `employeeID`: STRING Available options: ['5', '6', '4', '3', '9', '1', '8', '2', '7']\n  - `shipPostalCode`: STRING Example: \"51100\"\n  - `shippedDate`: STRING Example: \"1996-07-16 00:00:00.000\"\n  - `freight`: STRING Example: \"32.38\"\n  - `orderDate`: STRING Example: \"1996-07-04 00:00:00.000\"\n  - `orderID`: STRING Example: \"10248\"\n  - `shipAddress`: STRING Example: \"59 rue de l'Abbaye\"\n  - `customerID`: STRING Example: \"VINET\"\n  - `shipCountry`: STRING Example: \"France\"\n  - `shipVia`: STRING Available options: ['3', '1', '2']\n  - `shipRegion`: STRING Example: \"NULL\"\nRelationship properties:\n- **ORDERS**\n  - `orderID: STRING` Example: \"10248\"\n  - `unitPrice: STRING` Example: \"34.80\"\n  - `productID: STRING` Example: \"72\"\n  - `quantity: INTEGER` Min: 1, Max:  130\n  - `discount: STRING` Example: \"0\"\nThe relationships:\n(:Product)-[:PART_OF]->(:Category)\n(:Supplier)-[:SUPPLIES]->(:Product)\n(:Customer)-[:PURCHASED]->(:Order)\n(:Order)-[:ORDERS]->(:Product)",
        "gold_cypher": "MATCH (targetCustomer:Customer {companyName: 'Alfreds Futterkiste'}) WITH targetCustomer.customerID AS targetCustomerID MATCH (targetCustomer:Customer {customerID: targetCustomerID})-[:PURCHASED]->(:Order)-[:ORDERS]->(product:Product)<-[:SUPPLIES]-(supplier:Supplier) WITH targetCustomerID, collect(DISTINCT supplier.supplierID) AS targetSupplierIDs MATCH (otherCustomer:Customer)-[:PURCHASED]->(:Order)-[:ORDERS]->(:Product)<-[:SUPPLIES]-(supplier:Supplier) WHERE supplier.supplierID IN targetSupplierIDs AND otherCustomer.companyName <> 'Alfreds Futterkiste' RETURN DISTINCT otherCustomer.companyName, otherCustomer.customerID",
        "database": "northwind",
        "full_responses": [
            "To answer the question \"List the customers who have purchased products from the same supplier as 'Alfreds Futterkiste',\" you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[:PURCHASED]->(o:Order)-[:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category)-[:SUPPLIES]->(sup:Supplier)\nWHERE c.companyName = 'Alfreds Futterkiste'\nRETURN DISTINCT c.customerID, c.companyName, c.contactName, c.address, c.city, c.country, c.region, c.fax, c.phone, c.contactTitle, o.orderID, o.orderDate, o.shipDate, o.shipAddress, o.shipCity, o.shipPostalCode, o.shipCountry, o.shipVia, o.shipRegion, p.productName, p.quantityPerUnit, p.unitsOnOrder, p.supplierID, p.productID, p.discontinued, p.categoryID, p.reorderLevel, p.unitsInStock, p.unitPrice\n```\n\nThis query does the following:\n1. Matches all customers (`c`) who have purchased products (`o`).\n2. Follows the relationship `PURCHASED` from customers to orders.\n3. Follows the relationship `ORDERS` from orders to products.\n4. Follows the relationship `PART_OF` from products to categories.\n5. Follows the relationship `SUPPLIES` from suppliers to products.\n6. Filters for customers whose company name is 'Alfreds Futterkiste'.\n7. Returns distinct customer details, including order details and product details, to list customers who have purchased products from the same supplier.",
            "```cypher\nMATCH (customer:Customer)-[p:PURCHASED]->(order:Order)-[o:ORDERS]->(product:Product)<-[s:PART_OF]->(category:Category)<-[sp:SUPPLIES]->(supplier:Supplier)\nWHERE customer.customerID = 'ALFKI' AND supplier.supplierID = supplier.supplierID\nRETURN DISTINCT customer.customerID, customer.companyName\n```",
            "```cypher\nMATCH (c1:Customer)-[p:PURCHASED]->(o:Order)-[ord:ORDERS]->(prod:Product)\nWHERE c1.companyName = 'Alfreds Futterkiste'\nMATCH (prod)-[:PART_OF]->(cat:Category)\nMATCH (cat)-[:SUPPLIES]->(s:Supplier)\nWHERE s.supplierID = s.supplierID\nRETURN DISTINCT c1.companyName AS CustomerName\n```",
            "To find the customers who have purchased products from the same supplier as 'Alfreds Futterkiste', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[o2:ORDERS]->(p2:Product)-[rel:PART_OF]->(cat:Category)-[supp:SUPPLIES]->(sup:Supplier)\nWHERE c.companyName = 'Alfreds Futterkiste' AND p2.supplierID = sup.supplierID\nRETURN DISTINCT c.customerID, c.companyName, c.contactName, c.contactTitle, c.address, c.city, c.country, c.fax, c.region\n```\n\nThis query does the following:\n1. Matches all customers (`c`), their orders (`o`), and the products (`p`) they purchased.\n2. Joins the relationships to find the products they purchased from the same supplier.\n3. Filters the results to only include the customer 'Alfreds Futterkiste'.\n4. Ensures that the products are from the same supplier as 'Alfreds Futterkiste'.\n5. Returns the distinct customer details of the customers who meet these criteria.",
            "```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[:ORDERS]->(pr:Product)-[:PART_OF]->(cat:Category)-[:SUPPLIES]->(s:Supplier)\nWHERE c.companyName = 'Alfreds Futterkiste' AND s.supplierID = s.supplierID\nRETURN DISTINCT c.customerID, c.companyName, c.contactName, c.contactTitle, c.address, c.city, c.postalCode, c.country, c.region\n```"
        ],
        "generated_cyphers": [
            "To answer the question \"List the customers who have purchased products from the same supplier as 'Alfreds Futterkiste',\" you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[:PURCHASED]->(o:Order)-[:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category)-[:SUPPLIES]->(sup:Supplier)\nWHERE c.companyName = 'Alfreds Futterkiste'\nRETURN DISTINCT c.customerID, c.companyName, c.contactName, c.address, c.city, c.country, c.region, c.fax, c.phone, c.contactTitle, o.orderID, o.orderDate, o.shipDate, o.shipAddress, o.shipCity, o.shipPostalCode, o.shipCountry, o.shipVia, o.shipRegion, p.productName, p.quantityPerUnit, p.unitsOnOrder, p.supplierID, p.productID, p.discontinued, p.categoryID, p.reorderLevel, p.unitsInStock, p.unitPrice\n```\n\nThis query does the following:\n1. Matches all customers (`c`) who have purchased products (`o`).\n2. Follows the relationship `PURCHASED` from customers to orders.\n3. Follows the relationship `ORDERS` from orders to products.\n4. Follows the relationship `PART_OF` from products to categories.\n5. Follows the relationship `SUPPLIES` from suppliers to products.\n6. Filters for customers whose company name is 'Alfreds Futterkiste'.\n7. Returns distinct customer details, including order details and product details, to list customers who have purchased products from the same supplier.",
            "```cypher\nMATCH (customer:Customer)-[p:PURCHASED]->(order:Order)-[o:ORDERS]->(product:Product)<-[s:PART_OF]->(category:Category)<-[sp:SUPPLIES]->(supplier:Supplier)\nWHERE customer.customerID = 'ALFKI' AND supplier.supplierID = supplier.supplierID\nRETURN DISTINCT customer.customerID, customer.companyName\n```",
            "```cypher\nMATCH (c1:Customer)-[p:PURCHASED]->(o:Order)-[ord:ORDERS]->(prod:Product)\nWHERE c1.companyName = 'Alfreds Futterkiste'\nMATCH (prod)-[:PART_OF]->(cat:Category)\nMATCH (cat)-[:SUPPLIES]->(s:Supplier)\nWHERE s.supplierID = s.supplierID\nRETURN DISTINCT c1.companyName AS CustomerName\n```",
            "To find the customers who have purchased products from the same supplier as 'Alfreds Futterkiste', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[o2:ORDERS]->(p2:Product)-[rel:PART_OF]->(cat:Category)-[supp:SUPPLIES]->(sup:Supplier)\nWHERE c.companyName = 'Alfreds Futterkiste' AND p2.supplierID = sup.supplierID\nRETURN DISTINCT c.customerID, c.companyName, c.contactName, c.contactTitle, c.address, c.city, c.country, c.fax, c.region\n```\n\nThis query does the following:\n1. Matches all customers (`c`), their orders (`o`), and the products (`p`) they purchased.\n2. Joins the relationships to find the products they purchased from the same supplier.\n3. Filters the results to only include the customer 'Alfreds Futterkiste'.\n4. Ensures that the products are from the same supplier as 'Alfreds Futterkiste'.\n5. Returns the distinct customer details of the customers who meet these criteria.",
            "```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[:ORDERS]->(pr:Product)-[:PART_OF]->(cat:Category)-[:SUPPLIES]->(s:Supplier)\nWHERE c.companyName = 'Alfreds Futterkiste' AND s.supplierID = s.supplierID\nRETURN DISTINCT c.customerID, c.companyName, c.contactName, c.contactTitle, c.address, c.city, c.postalCode, c.country, c.region\n```"
        ]
    },
    {
        "question": "Find the actors who have starred in movies with a runtime longer than their age at the time of filming.",
        "schema": "Node properties:\n- **Movie**\n  - `url`: STRING Example: \"https://themoviedb.org/movie/862\"\n  - `runtime`: INTEGER Min: 2, Max: 910\n  - `revenue`: INTEGER Min: 1, Max: 2787965087\n  - `imdbRating`: FLOAT Min: 1.6, Max: 9.6\n  - `released`: STRING Example: \"1995-11-22\"\n  - `countries`: LIST Min Size: 1, Max Size: 16\n  - `languages`: LIST Min Size: 1, Max Size: 19\n  - `plot`: STRING Example: \"A cowboy doll is profoundly threatened and jealous\"\n  - `imdbVotes`: INTEGER Min: 13, Max: 1626900\n  - `imdbId`: STRING Example: \"0114709\"\n  - `year`: INTEGER Min: 1902, Max: 2016\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/uXDf\"\n  - `movieId`: STRING Example: \"1\"\n  - `tmdbId`: STRING Example: \"862\"\n  - `title`: STRING Example: \"Toy Story\"\n  - `budget`: INTEGER Min: 1, Max: 380000000\n- **Genre**\n  - `name`: STRING Example: \"Adventure\"\n- **User**\n  - `userId`: STRING Example: \"1\"\n  - `name`: STRING Example: \"Omar Huffman\"\n- **Actor**\n  - `url`: STRING Example: \"https://themoviedb.org/person/1271225\"\n  - `name`: STRING Example: \"Fran\u00e7ois Lallement\"\n  - `tmdbId`: STRING Example: \"1271225\"\n  - `bornIn`: STRING Example: \"France\"\n  - `bio`: STRING Example: \"\u200bFrom Wikipedia, the free encyclopedia  Lillian Di\"\n  - `died`: DATE Example: \"1954-01-01\"\n  - `born`: DATE Example: \"1877-02-04\"\n  - `imdbId`: STRING Example: \"2083046\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/6DCW\"\n- **Director**\n  - `url`: STRING Example: \"https://themoviedb.org/person/88953\"\n  - `bornIn`: STRING Example: \"Burchard, Nebraska, USA\"\n  - `born`: DATE Min: 1861-12-08, Max: 2018-05-01\n  - `died`: DATE Min: 1930-08-26, Max: 2976-09-29\n  - `tmdbId`: STRING Example: \"88953\"\n  - `imdbId`: STRING Example: \"0516001\"\n  - `name`: STRING Example: \"Harold Lloyd\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/er4Z\"\n  - `bio`: STRING Example: \"Harold Lloyd has been called the cinema\u2019s \u201cfirst m\"\n- **Person**\n  - `url`: STRING Example: \"https://themoviedb.org/person/1271225\"\n  - `died`: DATE Example: \"1954-01-01\"\n  - `bornIn`: STRING Example: \"France\"\n  - `born`: DATE Example: \"1877-02-04\"\n  - `imdbId`: STRING Example: \"2083046\"\n  - `name`: STRING Example: \"Fran\u00e7ois Lallement\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/6DCW\"\n  - `tmdbId`: STRING Example: \"1271225\"\n  - `bio`: STRING Example: \"\u200bFrom Wikipedia, the free encyclopedia  Lillian Di\"\nRelationship properties:\n- **RATED**\n  - `rating: FLOAT` Example: \"2.0\"\n  - `timestamp: INTEGER` Example: \"1260759108\"\n- **ACTED_IN**\n  - `role: STRING` Example: \"Officer of the Marines (uncredited)\"\n- **DIRECTED**\n  - `role: STRING` \nThe relationships:\n(:Movie)-[:IN_GENRE]->(:Genre)\n(:User)-[:RATED]->(:Movie)\n(:Actor)-[:ACTED_IN]->(:Movie)\n(:Actor)-[:DIRECTED]->(:Movie)\n(:Director)-[:DIRECTED]->(:Movie)\n(:Director)-[:ACTED_IN]->(:Movie)\n(:Person)-[:ACTED_IN]->(:Movie)\n(:Person)-[:DIRECTED]->(:Movie)",
        "gold_cypher": "MATCH (actor:Actor)-[:ACTED_IN]->(movie:Movie) WITH actor, movie, toInteger(substring(movie.released, 0, 4)) AS releaseYear WITH actor, movie, releaseYear, releaseYear - toInteger(substring(toString(actor.born), 0, 4)) AS ageAtFilming WHERE movie.runtime > ageAtFilming RETURN DISTINCT actor.name, movie.title UNION MATCH (actor:Person)-[:ACTED_IN]->(movie:Movie) WITH actor, movie, toInteger(substring(movie.released, 0, 4)) AS releaseYear WITH actor, movie, releaseYear, releaseYear - toInteger(substring(toString(actor.born), 0, 4)) AS ageAtFilming WHERE movie.runtime > ageAtFilming RETURN DISTINCT actor.name, movie.title",
        "database": "recommendations",
        "full_responses": [
            "To find actors who have starred in movies with a runtime longer than their age at the time of filming, we need to consider the following steps:\n\n1. Calculate the age of an actor at the time they directed or acted in a movie.\n2. Compare the runtime of the movie to the actor's age.\n3. Filter actors based on the condition that the movie runtime is longer than the actor's age.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (actor:Actor)-[r:ACTED_IN|DIRECTED]->(movie:Movie)\nWITH actor, movie, \n       (CASE\n          WHEN r.role = 'Director' THEN r.timestamp\n          ELSE movie.released\n        END) AS movie_release_date,\n       (CASE\n          WHEN r.role = 'Director' THEN r.timestamp\n          ELSE movie.released\n        END) - birthDate AS age\nWHERE movie_runtime > age\nRETURN DISTINCT actor.name\nORDER BY actor.name\n```\n\n### Explanation:\n- **MATCH (actor:Actor)-[r:ACTED_IN|DIRECTED]->(movie:Movie)**: This matches all actors who have acted in or directed movies.\n- **WITH actor, movie, (CASE WHEN r.role = 'Director' THEN r.timestamp ELSE movie.released END) AS movie_release_date, (CASE WHEN r.role = 'Director' THEN r.timestamp ELSE movie.released END) - birthDate AS age**: This calculates the movie release date and the age of the actor at the time of filming. If the relationship is a `DIRECTED`, it uses the director's timestamp; otherwise, it uses the movie's released date.\n- **WHERE movie_runtime > age**: This filters the movies where the runtime is greater than the actor's age.\n- **RETURN DISTINCT actor.name ORDER BY actor.name**: This returns distinct actor names and orders them alphabetically.\n\nMake sure to replace `movie_runtime` with the actual property name for the movie runtime in your Neo4j schema.",
            "To answer the question \"Find the actors who have starred in movies with a runtime longer than their age at the time of filming,\" we need to follow these steps:\n\n1. Identify the actors who have acted in movies.\n2. Calculate the age of each actor when the movie was released.\n3. Filter the actors based on whether their age at the time of filming is less than the movie runtime.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (actor:Actor)-[r:ACTED_IN]-(movie:Movie)\nWHERE r.timestamp < movie.released\nWITH actor, r.timestamp, movie\nORDER BY actor.name\nMATCH (actor)-[director:DIRECTED]-(movie)\nWITH actor, r.timestamp, movie, director.born, director.died\nUNION\nMATCH (actor)-[director:DIRECTED]-(movie)\nWITH actor, r.timestamp, movie, director.born, director.died\nWHERE director.born < movie.released\nRETURN actor.name, director.name, TO_DATE(director.born).year - TO_DATE(movie.released).year - CASE WHEN TO_DATE(director.born).month > TO_DATE(movie.released).month THEN 1 ELSE 0 END - CASE WHEN TO_DATE(director.born).day > TO_DATE(movie.released).day THEN 1 ELSE 0 END AS age\nORDER BY age DESC\n```\n\n### Explanation:\n1. **MATCH (actor:Actor)-[r:ACTED_IN]-(movie:Movie)**: This part finds all actors who have acted in movies.\n2. **WHERE r.timestamp < movie.released**: This ensures that the movie release date is before the actor's acting role timestamp, which is necessary to filter out movies that have not yet been released.\n3. **WITH actor, r.timestamp, movie**: This collects the necessary information about the actor and the movie.\n4. **ORDER BY actor.name**: This orders the results by actor name for better readability.\n5. **MATCH (actor)-[director:DIRECTED]-(movie)**: This finds all directors who directed movies.\n6. **WITH actor, r.timestamp, movie, director.born, director.died**: This collects the necessary information about the actor, the movie, and the director.\n7. **UNION**: This combines the results from both directed by and acted in relationships.\n8. **ORDER BY age DESC**: This orders the results by age in descending order to list actors who are older than the movie runtime.\n\nThis query will return the names of actors who have starred in movies with a runtime longer than their age at the time of filming.",
            "To find actors who have starred in movies with a runtime longer than their age at the time of filming, you can use the following Cypher query. This query calculates the age of an actor at the time they appeared in a movie and filters actors based on whether their age is less than the movie's runtime.\n\n```cypher\nMATCH (actor:Actor)-[acted_in:ACTED_IN]->(movie:Movie)\nWITH actor, movie, YEAR(movie.released) AS releaseYear, TIMESTAMP() AS currentTime\nWITH actor, movie, releaseYear, currentTime, actor.born AS actorBirthYear\nWITH actor, movie, releaseYear, currentTime, TIMESTAMP() - actorBirthYear AS actorAgeAtRelease\nWITH actor, movie, releaseYear, currentTime, actorAgeAtRelease, movie.runtime\nWHERE actorAgeAtRelease < movie.runtime\nRETURN actor.name, movie.title, movie.runtime\nORDER BY actor.name ASC, movie.title ASC;\n```\n\n### Explanation:\n1. **MATCH**: This clause matches all nodes and relationships related to actors and movies.\n2. **WITH**: This clause is used to create temporary variables and perform calculations.\n   - `actor` and `movie` are matched pairs of nodes.\n   - `releaseYear` is the year the movie was released.\n   - `currentTime` is the current timestamp.\n   - `actorBirthYear` is the year the actor was born.\n   - `actorAgeAtRelease` is calculated as the current time minus the actor's birth year.\n   - `movie.runtime` is the runtime of the movie.\n3. **WHERE**: This clause filters actors whose age at the time of filming is less than the movie's runtime.\n4. **RETURN**: This clause returns the actor's name, the movie's title, and the movie's runtime.\n\nThis query assumes that the `released` property of the movie node is in a format that can be converted to a year. If the `released` property is not in a standard format, additional steps may be needed to extract the year.",
            "```cypher\nMATCH (actor:Actor)-[acted_in:ACTED_IN]->(movie:Movie)\nWHERE actor.born < (YEAR(movie.released) - actor.born) * 12 + MONTH(movie.released)\nRETURN actor.name\nORDER BY actor.name ASC\n```",
            "To find the actors who have starred in movies with a runtime longer than their age at the time of filming, you can use the following Cypher query:\n\n```cypher\nMATCH (a:Actor)-[r:ACTED_IN]->(m:Movie)\nWHERE r.timestamp < m.released AND r.timestamp + m.runtime < a.born\nRETURN DISTINCT a.name AS ActorName, a.born, m.runtime, a.bornIn\n```\n\nThis query does the following:\n- Matches any actor (`a`) who has acted in a movie (`m`).\n- Checks if the `timestamp` of the relationship (`r`) is before the movie's release date (`m.released`).\n- Calculates the age of the actor at the time the movie was released by adding the movie's runtime to the `timestamp`.\n- Filters actors whose age at the time of filming is greater than the movie's runtime.\n- Returns the name of the actor, their birth date, the movie's runtime, and their place of birth."
        ],
        "generated_cyphers": [
            "To find actors who have starred in movies with a runtime longer than their age at the time of filming, we need to consider the following steps:\n\n1. Calculate the age of an actor at the time they directed or acted in a movie.\n2. Compare the runtime of the movie to the actor's age.\n3. Filter actors based on the condition that the movie runtime is longer than the actor's age.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (actor:Actor)-[r:ACTED_IN|DIRECTED]->(movie:Movie)\nWITH actor, movie, \n       (CASE\n          WHEN r.role = 'Director' THEN r.timestamp\n          ELSE movie.released\n        END) AS movie_release_date,\n       (CASE\n          WHEN r.role = 'Director' THEN r.timestamp\n          ELSE movie.released\n        END) - birthDate AS age\nWHERE movie_runtime > age\nRETURN DISTINCT actor.name\nORDER BY actor.name\n```\n\n### Explanation:\n- **MATCH (actor:Actor)-[r:ACTED_IN|DIRECTED]->(movie:Movie)**: This matches all actors who have acted in or directed movies.\n- **WITH actor, movie, (CASE WHEN r.role = 'Director' THEN r.timestamp ELSE movie.released END) AS movie_release_date, (CASE WHEN r.role = 'Director' THEN r.timestamp ELSE movie.released END) - birthDate AS age**: This calculates the movie release date and the age of the actor at the time of filming. If the relationship is a `DIRECTED`, it uses the director's timestamp; otherwise, it uses the movie's released date.\n- **WHERE movie_runtime > age**: This filters the movies where the runtime is greater than the actor's age.\n- **RETURN DISTINCT actor.name ORDER BY actor.name**: This returns distinct actor names and orders them alphabetically.\n\nMake sure to replace `movie_runtime` with the actual property name for the movie runtime in your Neo4j schema.",
            "To answer the question \"Find the actors who have starred in movies with a runtime longer than their age at the time of filming,\" we need to follow these steps:\n\n1. Identify the actors who have acted in movies.\n2. Calculate the age of each actor when the movie was released.\n3. Filter the actors based on whether their age at the time of filming is less than the movie runtime.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (actor:Actor)-[r:ACTED_IN]-(movie:Movie)\nWHERE r.timestamp < movie.released\nWITH actor, r.timestamp, movie\nORDER BY actor.name\nMATCH (actor)-[director:DIRECTED]-(movie)\nWITH actor, r.timestamp, movie, director.born, director.died\nUNION\nMATCH (actor)-[director:DIRECTED]-(movie)\nWITH actor, r.timestamp, movie, director.born, director.died\nWHERE director.born < movie.released\nRETURN actor.name, director.name, TO_DATE(director.born).year - TO_DATE(movie.released).year - CASE WHEN TO_DATE(director.born).month > TO_DATE(movie.released).month THEN 1 ELSE 0 END - CASE WHEN TO_DATE(director.born).day > TO_DATE(movie.released).day THEN 1 ELSE 0 END AS age\nORDER BY age DESC\n```\n\n### Explanation:\n1. **MATCH (actor:Actor)-[r:ACTED_IN]-(movie:Movie)**: This part finds all actors who have acted in movies.\n2. **WHERE r.timestamp < movie.released**: This ensures that the movie release date is before the actor's acting role timestamp, which is necessary to filter out movies that have not yet been released.\n3. **WITH actor, r.timestamp, movie**: This collects the necessary information about the actor and the movie.\n4. **ORDER BY actor.name**: This orders the results by actor name for better readability.\n5. **MATCH (actor)-[director:DIRECTED]-(movie)**: This finds all directors who directed movies.\n6. **WITH actor, r.timestamp, movie, director.born, director.died**: This collects the necessary information about the actor, the movie, and the director.\n7. **UNION**: This combines the results from both directed by and acted in relationships.\n8. **ORDER BY age DESC**: This orders the results by age in descending order to list actors who are older than the movie runtime.\n\nThis query will return the names of actors who have starred in movies with a runtime longer than their age at the time of filming.",
            "To find actors who have starred in movies with a runtime longer than their age at the time of filming, you can use the following Cypher query. This query calculates the age of an actor at the time they appeared in a movie and filters actors based on whether their age is less than the movie's runtime.\n\n```cypher\nMATCH (actor:Actor)-[acted_in:ACTED_IN]->(movie:Movie)\nWITH actor, movie, YEAR(movie.released) AS releaseYear, TIMESTAMP() AS currentTime\nWITH actor, movie, releaseYear, currentTime, actor.born AS actorBirthYear\nWITH actor, movie, releaseYear, currentTime, TIMESTAMP() - actorBirthYear AS actorAgeAtRelease\nWITH actor, movie, releaseYear, currentTime, actorAgeAtRelease, movie.runtime\nWHERE actorAgeAtRelease < movie.runtime\nRETURN actor.name, movie.title, movie.runtime\nORDER BY actor.name ASC, movie.title ASC;\n```\n\n### Explanation:\n1. **MATCH**: This clause matches all nodes and relationships related to actors and movies.\n2. **WITH**: This clause is used to create temporary variables and perform calculations.\n   - `actor` and `movie` are matched pairs of nodes.\n   - `releaseYear` is the year the movie was released.\n   - `currentTime` is the current timestamp.\n   - `actorBirthYear` is the year the actor was born.\n   - `actorAgeAtRelease` is calculated as the current time minus the actor's birth year.\n   - `movie.runtime` is the runtime of the movie.\n3. **WHERE**: This clause filters actors whose age at the time of filming is less than the movie's runtime.\n4. **RETURN**: This clause returns the actor's name, the movie's title, and the movie's runtime.\n\nThis query assumes that the `released` property of the movie node is in a format that can be converted to a year. If the `released` property is not in a standard format, additional steps may be needed to extract the year.",
            "```cypher\nMATCH (actor:Actor)-[acted_in:ACTED_IN]->(movie:Movie)\nWHERE actor.born < (YEAR(movie.released) - actor.born) * 12 + MONTH(movie.released)\nRETURN actor.name\nORDER BY actor.name ASC\n```",
            "To find the actors who have starred in movies with a runtime longer than their age at the time of filming, you can use the following Cypher query:\n\n```cypher\nMATCH (a:Actor)-[r:ACTED_IN]->(m:Movie)\nWHERE r.timestamp < m.released AND r.timestamp + m.runtime < a.born\nRETURN DISTINCT a.name AS ActorName, a.born, m.runtime, a.bornIn\n```\n\nThis query does the following:\n- Matches any actor (`a`) who has acted in a movie (`m`).\n- Checks if the `timestamp` of the relationship (`r`) is before the movie's release date (`m.released`).\n- Calculates the age of the actor at the time the movie was released by adding the movie's runtime to the `timestamp`.\n- Filters actors whose age at the time of filming is greater than the movie's runtime.\n- Returns the name of the actor, their birth date, the movie's runtime, and their place of birth."
        ]
    },
    {
        "question": "List the characters who have interacted with 'Daenerys-Targaryen' in any book and have a 'degree' less than 5.",
        "schema": "Node properties:\n- **Character**\n  - `centrality`: FLOAT Min: 0.0, Max: 1.0\n  - `book45PageRank`: FLOAT Min: 0.15000000000000002, Max: 11.409916274911177\n  - `fastrf_embedding`: LIST Min Size: 10, Max Size: 10\n  - `book1BetweennessCentrality`: FLOAT Min: 0.0, Max: 4638.53495125504\n  - `book1PageRank`: FLOAT Min: 0.15000000000000002, Max: 8.164174336296284\n  - `louvain`: INTEGER Min: 0, Max: 10\n  - `community`: INTEGER Min: 504, Max: 795\n  - `degree`: FLOAT Min: 0.0, Max: 300.0\n  - `name`: STRING Example: \"Addam-Marbrand\"\n  - `pagerank`: FLOAT Min: 0.15000000000000002, Max: 9.473142454730429\nRelationship properties:\n- **INTERACTS**\n  - `weight: INTEGER` Min: 3, Max:  334\n- **INTERACTS1**\n  - `weight: INTEGER` Min: 3, Max:  291\n  - `book: INTEGER` Min: 1, Max:  1\n- **INTERACTS2**\n  - `weight: INTEGER` Min: 3, Max:  92\n  - `book: INTEGER` Min: 2, Max:  2\n- **INTERACTS3**\n  - `weight: INTEGER` Min: 3, Max:  95\n  - `book: INTEGER` Min: 3, Max:  3\n- **INTERACTS45**\n  - `weight: INTEGER` Min: 3, Max:  96\n  - `book: INTEGER` Min: 45, Max:  45\nThe relationships:\n(:Character)-[:INTERACTS45]->(:Character)\n(:Character)-[:INTERACTS]->(:Character)\n(:Character)-[:INTERACTS1]->(:Character)\n(:Character)-[:INTERACTS3]->(:Character)\n(:Character)-[:INTERACTS2]->(:Character)",
        "gold_cypher": "MATCH (dt:Character {name: 'Daenerys-Targaryen'}) CALL {   WITH dt   MATCH (dt)-[:INTERACTS]->(c:Character)   WHERE c.degree < 5   RETURN c.name AS name   UNION   WITH dt   MATCH (dt)-[:INTERACTS1]->(c:Character)   WHERE c.degree < 5   RETURN c.name AS name   UNION   WITH dt   MATCH (dt)-[:INTERACTS2]->(c:Character)   WHERE c.degree < 5   RETURN c.name AS name   UNION   WITH dt   MATCH (dt)-[:INTERACTS3]->(c:Character)   WHERE c.degree < 5   RETURN c.name AS name   UNION   WITH dt   MATCH (dt)-[:INTERACTS45]->(c:Character)   WHERE c.degree < 5   RETURN c.name AS name } RETURN DISTINCT name",
        "database": "gameofthrones",
        "full_responses": [
            "```cypher\nMATCH (c:Character)-[r:INTERACTS45]->(d:Character {name: 'Daenerys-Targaryen'})\nWHERE c.degree < 5\nRETURN c\n```",
            "```cypher\nMATCH (c:Character)-[r:INTERACTS45]->(d:Character)\nWHERE d.name = 'Daenerys-Targaryen' AND c.degree < 5\nRETURN DISTINCT c.name, c.degree, c.book45PageRank\nORDER BY c.book45PageRank DESC;\n```",
            "```cypher\nMATCH (ch1:Character {name: 'Daenerys-Targaryen'})-[:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(ch2:Character)\nWHERE ch2.degree < 5\nRETURN ch2.name\n```",
            "To list the characters who have interacted with 'Daenerys-Targaryen' in any book and have a 'degree' less than 5, you can use the following Cypher query:\n\n```cypher\nMATCH (c1:Character)-[r:INTERACTS*1..5]->(c2:Character)\nWHERE c1.name = 'Daenerys-Targaryen' AND c1.degree < 5\nRETURN DISTINCT c2.name\n```\n\n### Explanation:\n- `MATCH (c1:Character)-[r:INTERACTS*1..5]->(c2:Character)`: This pattern matches all paths where a character interacts with 'Daenerys-Targaryen' through 1 to 5 interactions.\n- `WHERE c1.name = 'Daenerys-Targaryen' AND c1.degree < 5`: Filters the results to include only those paths where 'Daenerys-Targaryen' has a degree less than 5.\n- `RETURN DISTINCT c2.name`: Returns the unique names of the characters that interacted with 'Daenerys-Targaryen' under the given conditions.",
            "```cypher\nMATCH (c1:Character)-[r:INTERACTS45|INTERACTS|INTERACTS1|INTERACTS3|INTERACTS2]->(c2:Character)\nWHERE c1.name = 'Daenerys-Targaryen' AND c1.degree < 5\nRETURN c2.name\n```"
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (c:Character)-[r:INTERACTS45]->(d:Character {name: 'Daenerys-Targaryen'})\nWHERE c.degree < 5\nRETURN c\n```",
            "```cypher\nMATCH (c:Character)-[r:INTERACTS45]->(d:Character)\nWHERE d.name = 'Daenerys-Targaryen' AND c.degree < 5\nRETURN DISTINCT c.name, c.degree, c.book45PageRank\nORDER BY c.book45PageRank DESC;\n```",
            "```cypher\nMATCH (ch1:Character {name: 'Daenerys-Targaryen'})-[:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(ch2:Character)\nWHERE ch2.degree < 5\nRETURN ch2.name\n```",
            "To list the characters who have interacted with 'Daenerys-Targaryen' in any book and have a 'degree' less than 5, you can use the following Cypher query:\n\n```cypher\nMATCH (c1:Character)-[r:INTERACTS*1..5]->(c2:Character)\nWHERE c1.name = 'Daenerys-Targaryen' AND c1.degree < 5\nRETURN DISTINCT c2.name\n```\n\n### Explanation:\n- `MATCH (c1:Character)-[r:INTERACTS*1..5]->(c2:Character)`: This pattern matches all paths where a character interacts with 'Daenerys-Targaryen' through 1 to 5 interactions.\n- `WHERE c1.name = 'Daenerys-Targaryen' AND c1.degree < 5`: Filters the results to include only those paths where 'Daenerys-Targaryen' has a degree less than 5.\n- `RETURN DISTINCT c2.name`: Returns the unique names of the characters that interacted with 'Daenerys-Targaryen' under the given conditions.",
            "```cypher\nMATCH (c1:Character)-[r:INTERACTS45|INTERACTS|INTERACTS1|INTERACTS3|INTERACTS2]->(c2:Character)\nWHERE c1.name = 'Daenerys-Targaryen' AND c1.degree < 5\nRETURN c2.name\n```"
        ]
    },
    {
        "question": "List the orders placed by customers who have placed orders for products in all categories except 'Seafood'.",
        "schema": "Node properties:\n- **Product**\n  - `productName`: STRING Example: \"Chai\"\n  - `quantityPerUnit`: STRING Example: \"10 boxes x 20 bags\"\n  - `unitsOnOrder`: INTEGER Min: 0, Max: 100\n  - `supplierID`: STRING Example: \"1\"\n  - `productID`: STRING Example: \"1\"\n  - `discontinued`: BOOLEAN \n  - `categoryID`: STRING Available options: ['1', '2', '7', '6', '8', '4', '3', '5']\n  - `reorderLevel`: INTEGER Min: 0, Max: 30\n  - `unitsInStock`: INTEGER Min: 0, Max: 125\n  - `unitPrice`: FLOAT Min: 2.5, Max: 263.5\n- **Category**\n  - `picture`: STRING Available options: ['0x151C2F00020000000D000E0014002100FFFFFFFF4269746D']\n  - `categoryID`: STRING Available options: ['1', '2', '3', '4', '5', '6', '7', '8']\n  - `description`: STRING Available options: ['Soft drinks, coffees, teas, beers, and ales', 'Sweet and savory sauces, relishes, spreads, and se', 'Desserts, candies, and sweet breads', 'Cheeses', 'Breads, crackers, pasta, and cereal', 'Prepared meats', 'Dried fruit and bean curd', 'Seaweed and fish']\n  - `categoryName`: STRING Available options: ['Beverages', 'Condiments', 'Confections', 'Dairy Products', 'Grains/Cereals', 'Meat/Poultry', 'Produce', 'Seafood']\n- **Supplier**\n  - `companyName`: STRING Example: \"Exotic Liquids\"\n  - `contactName`: STRING Example: \"Charlotte Cooper\"\n  - `homePage`: STRING Available options: ['NULL', '#CAJUN.HTM#', \"Mayumi's (on the World Wide Web)#http://www.micros\", '(03) 444-6588', 'Plutzer (on the World Wide Web)#http://www.microso', '(0544) 60603', '(1) 03.83.00.62', '(02) 555-4873', '(089) 6547667', '38.76.98.58']\n  - `phone`: STRING Example: \"(171) 555-2222\"\n  - `postalCode`: STRING Example: \"EC1 4SD\"\n  - `contactTitle`: STRING Example: \"Purchasing Manager\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"49 Gilbert St.\"\n  - `fax`: STRING Example: \"NULL\"\n  - `supplierID`: STRING Example: \"1\"\n  - `country`: STRING Example: \"UK\"\n  - `city`: STRING Example: \"London\"\n- **Customer**\n  - `fax`: STRING Example: \"030-0076545\"\n  - `companyName`: STRING Example: \"Alfreds Futterkiste\"\n  - `customerID`: STRING Example: \"ALFKI\"\n  - `phone`: STRING Example: \"030-0074321\"\n  - `contactName`: STRING Example: \"Maria Anders\"\n  - `contactTitle`: STRING Example: \"Sales Representative\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"Obere Str. 57\"\n  - `postalCode`: STRING Example: \"12209\"\n  - `country`: STRING Example: \"Germany\"\n  - `city`: STRING Example: \"Berlin\"\n- **Order**\n  - `shipName`: STRING Example: \"Vins et alcools Chevalier\"\n  - `requiredDate`: STRING Example: \"1996-08-01 00:00:00.000\"\n  - `shipCity`: STRING Example: \"Reims\"\n  - `employeeID`: STRING Available options: ['5', '6', '4', '3', '9', '1', '8', '2', '7']\n  - `shipPostalCode`: STRING Example: \"51100\"\n  - `shippedDate`: STRING Example: \"1996-07-16 00:00:00.000\"\n  - `freight`: STRING Example: \"32.38\"\n  - `orderDate`: STRING Example: \"1996-07-04 00:00:00.000\"\n  - `orderID`: STRING Example: \"10248\"\n  - `shipAddress`: STRING Example: \"59 rue de l'Abbaye\"\n  - `customerID`: STRING Example: \"VINET\"\n  - `shipCountry`: STRING Example: \"France\"\n  - `shipVia`: STRING Available options: ['3', '1', '2']\n  - `shipRegion`: STRING Example: \"NULL\"\nRelationship properties:\n- **ORDERS**\n  - `orderID: STRING` Example: \"10248\"\n  - `unitPrice: STRING` Example: \"34.80\"\n  - `productID: STRING` Example: \"72\"\n  - `quantity: INTEGER` Min: 1, Max:  130\n  - `discount: STRING` Example: \"0\"\nThe relationships:\n(:Product)-[:PART_OF]->(:Category)\n(:Supplier)-[:SUPPLIES]->(:Product)\n(:Customer)-[:PURCHASED]->(:Order)\n(:Order)-[:ORDERS]->(:Product)",
        "gold_cypher": "MATCH (c:Customer)-[:PURCHASED]->(o:Order) WITH c, collect(DISTINCT o) AS customerOrders MATCH (p:Product)-[:PART_OF]->(cat:Category) WHERE cat.categoryID <> '8' WITH c, customerOrders, collect(DISTINCT cat.categoryID) AS allCategoriesExceptSeafood MATCH (c)-[:PURCHASED]->(o:Order)-[:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category) WITH c, customerOrders, allCategoriesExceptSeafood, collect(DISTINCT cat.categoryID) AS customerOrderedCategories WHERE all(category IN allCategoriesExceptSeafood WHERE category IN customerOrderedCategories) UNWIND customerOrders AS order RETURN DISTINCT order",
        "database": "northwind",
        "full_responses": [
            "To list the orders placed by customers who have placed orders for products in all categories except 'Seafood', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[r:Purchased]->(o:Order)\nWHERE ALL(cat IN (SELECT DISTINCT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID",
            "```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[o1:ORDERS]->(p1:Product)\nWITH c, COLLECT(DISTINCT p1.categoryID) AS categories\nWHERE NOT 'Seafood' IN categories\nRETURN c.customerID, c.companyName, o.orderID, o.orderDate, o.requiredDate, o.shippedDate, o.freight\n```",
            "```cypher\nMATCH (c:Customer)-[pu:Purchased]->(o:Order)-[o2:ORDERS]->(p:Product)-[:PART_OF]->(ca:Category)\nWHERE ca.categoryName <> 'Seafood'\nWITH c, COLLECT(DISTINCT ca.categoryName) AS orderedCategories\nWHERE size(orderedCategories) = size((:Category)-[r:PART_OF]->(:Product))\nRETURN c.customerID, c.companyName, c.contactName, c.contactTitle\n```",
            "To answer the question, we need to find customers who have placed orders for products from all categories except 'Seafood'. Here's a Cypher query that accomplishes this:\n\n```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[ord:ORDERS]->(prod:Product)\nWHERE prod.categoryID <> '8'  // Exclude the 'Seafood' category\nGROUP BY c.customerID\nHAVING count(DISTINCT prod.categoryID) = count(:Category)\n```\n\n### Explanation:\n1. **MATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[ord:ORDERS]->(prod:Product)**: This pattern matches the relationships between customers, orders, products, and categories.\n2. **WHERE prod.categoryID <> '8'**: This condition excludes products from the 'Seafood' category.\n3. **GROUP BY c.customerID**: This groups the results by customer to ensure we are checking each customer individually.\n4. **HAVING count(DISTINCT prod.categoryID) = count(:Category)**: This checks if the number of distinct product categories for each customer is equal to the total number of categories, ensuring that the customer has placed orders for all categories except 'Seafood'.",
            "To find the orders placed by customers who have purchased products from all categories except 'Seafood', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)-[p:ORDERS]->(prod:Product)\nWITH c, ord, collect(prod.categoryID) AS prodCategories\nWHERE prodCategories EXCEPT ['8']  -- Exclude 'Seafood' category\nGROUP BY c.customerID\nHAVING count(DISTINCT prod.categoryID) = 7  -- Ensure all categories are included except 'Seafood'\nRETURN c.customerID, ord.orderID, ord.orderDate, ord.shipAddress\nORDER BY ord.orderDate DESC;\n```\n\nThis query does the following:\n1. Matches customers who have purchased orders.\n2. Collects the category IDs of the products they purchased.\n3. Filters out the 'Seafood' category from the collected categories.\n4. Groups the results by customer ID and ensures that all categories except 'Seafood' are included.\n5. Returns the customer ID, order ID, order date, and shipping address for customers who meet the criteria."
        ],
        "generated_cyphers": [
            "To list the orders placed by customers who have placed orders for products in all categories except 'Seafood', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[r:Purchased]->(o:Order)\nWHERE ALL(cat IN (SELECT DISTINCT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID FROM (SELECT categoryID",
            "```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[o1:ORDERS]->(p1:Product)\nWITH c, COLLECT(DISTINCT p1.categoryID) AS categories\nWHERE NOT 'Seafood' IN categories\nRETURN c.customerID, c.companyName, o.orderID, o.orderDate, o.requiredDate, o.shippedDate, o.freight\n```",
            "```cypher\nMATCH (c:Customer)-[pu:Purchased]->(o:Order)-[o2:ORDERS]->(p:Product)-[:PART_OF]->(ca:Category)\nWHERE ca.categoryName <> 'Seafood'\nWITH c, COLLECT(DISTINCT ca.categoryName) AS orderedCategories\nWHERE size(orderedCategories) = size((:Category)-[r:PART_OF]->(:Product))\nRETURN c.customerID, c.companyName, c.contactName, c.contactTitle\n```",
            "To answer the question, we need to find customers who have placed orders for products from all categories except 'Seafood'. Here's a Cypher query that accomplishes this:\n\n```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[ord:ORDERS]->(prod:Product)\nWHERE prod.categoryID <> '8'  // Exclude the 'Seafood' category\nGROUP BY c.customerID\nHAVING count(DISTINCT prod.categoryID) = count(:Category)\n```\n\n### Explanation:\n1. **MATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[ord:ORDERS]->(prod:Product)**: This pattern matches the relationships between customers, orders, products, and categories.\n2. **WHERE prod.categoryID <> '8'**: This condition excludes products from the 'Seafood' category.\n3. **GROUP BY c.customerID**: This groups the results by customer to ensure we are checking each customer individually.\n4. **HAVING count(DISTINCT prod.categoryID) = count(:Category)**: This checks if the number of distinct product categories for each customer is equal to the total number of categories, ensuring that the customer has placed orders for all categories except 'Seafood'.",
            "To find the orders placed by customers who have purchased products from all categories except 'Seafood', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)-[p:ORDERS]->(prod:Product)\nWITH c, ord, collect(prod.categoryID) AS prodCategories\nWHERE prodCategories EXCEPT ['8']  -- Exclude 'Seafood' category\nGROUP BY c.customerID\nHAVING count(DISTINCT prod.categoryID) = 7  -- Ensure all categories are included except 'Seafood'\nRETURN c.customerID, ord.orderID, ord.orderDate, ord.shipAddress\nORDER BY ord.orderDate DESC;\n```\n\nThis query does the following:\n1. Matches customers who have purchased orders.\n2. Collects the category IDs of the products they purchased.\n3. Filters out the 'Seafood' category from the collected categories.\n4. Groups the results by customer ID and ensures that all categories except 'Seafood' are included.\n5. Returns the customer ID, order ID, order date, and shipping address for customers who meet the criteria."
        ]
    },
    {
        "question": "Find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe.",
        "schema": "Node properties:\n- **Person**\n  - `name`: STRING Example: \"Julie Spellman Sweet\"\n  - `id`: STRING Example: \"Eaf0bpz6NNoqLVUCqNZPAew\"\n  - `summary`: STRING Example: \"CEO at Accenture\"\n- **Organization**\n  - `revenue`: FLOAT Example: \"1.2E8\"\n  - `motto`: STRING Example: \"\"\n  - `nbrEmployees`: INTEGER Example: \"375\"\n  - `isDissolved`: BOOLEAN \n  - `id`: STRING Example: \"E0ZU8eCc5OaqS1LU9qE3n3w\"\n  - `isPublic`: BOOLEAN \n  - `name`: STRING Example: \"New Energy Group\"\n  - `summary`: STRING Example: \"Software company based in Rome, Metropolitan City \"\n- **IndustryCategory**\n  - `name`: STRING Example: \"Electronic Products Manufacturers\"\n  - `id`: STRING Example: \"EUNd__O4zMNW81lAXNK2GNw\"\n- **City**\n  - `id`: STRING Example: \"EZHWv2xKgN92oYDKSjhJ2gw\"\n  - `summary`: STRING Example: \"City in and county seat of King County, Washington\"\n  - `name`: STRING Example: \"Seattle\"\n- **Country**\n  - `name`: STRING Example: \"United States of America\"\n  - `id`: STRING Example: \"E01d4EK33MmCosgI2KXa4-A\"\n  - `summary`: STRING Example: \"Country in North America\"\n- **Article**\n  - `id`: STRING Example: \"ART176872705964\"\n  - `sentiment`: FLOAT Example: \"0.856\"\n  - `author`: STRING Example: \"David Correa\"\n  - `siteName`: STRING Example: \"MrWeb\"\n  - `summary`: STRING Example: \"Boston and Mumbai-based consumer behavior analyses\"\n  - `date`: DATE_TIME Example: \"2022-03-10T00:00:00Z\"\n  - `title`: STRING Example: \"Funds for Consumer Behavior Specialist Infinite An\"\n- **Chunk**\n  - `text`: STRING Example: \"Boston and Mumbai-based consumer behavior analyses\"\n- **Fewshot**\n  - `Question`: STRING Available options: ['How is Emil Eifrem connected to Michael Hunger? ', 'What are the latest news regarding Google? ', 'Are there any news regarding return to office poli', 'What is Microsoft policy regarding to the return t', 'How many levels of subsidiaries does Blackstone ha', 'How many Telecommunications Companies are from Mal']\n  - `Cypher`: STRING Available options: ['MATCH (p1:Person {{name:\"Emil Eifrem\"}}), (p2:Pers', 'MATCH (o:Organization {{name:\"Google\"}})<-[:MENTIO', 'CALL apoc.ml.openai.embedding([\"Are there any news', 'CALL apoc.ml.openai.embedding([\"What is Microsoft ', 'MATCH p=(o:Organization {name:\"Blackstone\"})-[:HAS', 'MATCH (o:Organization) WHERE EXISTS {(o)-[:HAS_CAT']\n  - `id`: INTEGER Min: 2, Max: 7\nRelationship properties:\n\nThe relationships:\n(:Person)-[:HAS_PARENT]->(:Person)\n(:Person)-[:HAS_CHILD]->(:Person)\n(:Organization)-[:IN_CITY]->(:City)\n(:Organization)-[:HAS_CEO]->(:Person)\n(:Organization)-[:HAS_CATEGORY]->(:IndustryCategory)\n(:Organization)-[:HAS_SUBSIDIARY]->(:Organization)\n(:Organization)-[:HAS_SUPPLIER]->(:Organization)\n(:Organization)-[:HAS_INVESTOR]->(:Organization)\n(:Organization)-[:HAS_INVESTOR]->(:Person)\n(:Organization)-[:HAS_BOARD_MEMBER]->(:Person)\n(:Organization)-[:HAS_COMPETITOR]->(:Organization)\n(:City)-[:IN_COUNTRY]->(:Country)\n(:Article)-[:HAS_CHUNK]->(:Chunk)\n(:Article)-[:MENTIONS]->(:Organization)",
        "gold_cypher": "MATCH (org:Organization)-[:IN_CITY]->(city:City)-[:IN_COUNTRY]->(country:Country) WHERE country.name IN ['Austria', 'Belgium', 'Bulgaria', 'Croatia', 'Cyprus', 'Czech Republic', 'Denmark', 'Estonia', 'Finland', 'France', 'Germany', 'Greece', 'Hungary', 'Iceland', 'Ireland', 'Italy', 'Latvia', 'Lithuania', 'Luxembourg', 'Malta', 'Netherlands', 'Norway', 'Poland', 'Portugal', 'Romania', 'Slovakia', 'Slovenia', 'Spain', 'Sweden', 'Switzerland', 'Ukraine', 'United Kingdom'] MATCH (parentOrg:Organization)-[:HAS_SUBSIDIARY]->(org) MATCH (parentOrg)-[:HAS_CEO]->(ceo:Person) RETURN DISTINCT ceo",
        "database": "companies",
        "full_responses": [
            "To find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Organization)-[r:HAS_SUBSIDIARY]->(o:Organization)-[:HAS_CATEGORY]->(ic:IndustryCategory)-[:IN_COUNTRY]->(c:Country {name: \"Europe\"})\nWHERE ic.name = \"Electronic Products Manufacturers\"\nRETURN e.hasCEO AS CEOName\n```\n\nThis query performs the following steps:\n\n1. **Match Organizations**: It finds organizations that are subsidiaries of organizations (`e:Organization)-[r:HAS_SUBSIDIARY]->(o:Organization)`).\n2. **Check Country**: It filters these organizations to only those headquartered in Europe (`:IN_COUNTRY]->(c:Country {name: \"Europe\"})`).\n3. **Industry Category**: It ensures that the industries are in the \"Electronic Products Manufacturers\" category (`:HAS_CATEGORY]->(ic:IndustryCategory {name: \"Electronic Products Manufacturers\"})`).\n4. **Return CEOs**: It retrieves the CEOs of these organizations (`e.hasCEO AS CEOName`).",
            "To find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe, you can use the following Cypher query:\n\n```cypher\nMATCH p=(o1:Organization)-[r:HAS_SUBSIDIARY]->(o2:Organization)<-[r2:IN_CITY]->(c:City)<-[r3:IN_COUNTRY]->(country:Country {name: 'Europe'})\nWHERE r2.name = 'Europe'\nAND r3.name = 'Europe'\nMATCH (o2)<-[r4:HAS_CEO]->(ceo:Person)\nRETURN DISTINCT ceo.name\n```\n\nThis query works as follows:\n1. It starts by matching any organization (`o1`) that is a subsidiary of another organization (`o2`) and is located in a city (`c`) that is in a country (`country`) named 'Europe'.\n2. It then filters the results to ensure both `r2` and `r3` are directed towards Europe.\n3. Finally, it matches the CEO of the `o2` organization and returns their names, ensuring that each person is returned only once using `DISTINCT`.",
            "To find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Person)-[r:HAS_CEO]->(o:Organization)<-[r2:HAS_SUBSIDIARY]-(o2:Organization)\nWHERE o2 IN (SELECT o FROM Organization WHERE country.name = 'Europe')\nRETURN e.name AS CEOName\n```\n\nThis query does the following:\n1. Matches any person (`e`) who has a `HAS_CEO` relationship to an organization (`o`).\n2. Finds the organization that is a subsidiary of `o` (`o2`) and checks if `o2` is located in Europe by filtering the `country` nodes.\n3. Returns the names of the CEOs who meet these criteria.",
            "```cypher\nMATCH (o:Organization)-[:HAS_SUBSIDIARY]->(s:Organization)-[:IN_CITY]->(c:City)-[:IN_COUNTRY]->(ct:Country)\nWHERE ct.name = 'Europe'\nWITH s\nMATCH (p:Person)-[:HAS_CEO]->(s)\nRETURN DISTINCT p.name\n```",
            "To find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Organization)-[:HAS_SUBSIDIARY]->(o:Organization)-[:HAS_CEO]->(p:Person)\nWHERE o.location IN ['Europe']\nRETURN p.name, p.summary\n```\n\n### Explanation:\n- `MATCH (e:Organization)-[:HAS_SUBSIDIARY]->(o:Organization)-[:HAS_CEO]->(p:Person)`: This pattern matches organizations that are subsidiaries (`HAS_SUBSIDIARY`) of another organization (`HAS_CEO`), which ultimately leads to a person (`CEO`).\n- `WHERE o.location IN ['Europe']`: This condition filters the organizations to only include those located in Europe.\n- `RETURN p.name, p.summary`: This returns the names and summaries of the CEOs of these organizations."
        ],
        "generated_cyphers": [
            "To find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Organization)-[r:HAS_SUBSIDIARY]->(o:Organization)-[:HAS_CATEGORY]->(ic:IndustryCategory)-[:IN_COUNTRY]->(c:Country {name: \"Europe\"})\nWHERE ic.name = \"Electronic Products Manufacturers\"\nRETURN e.hasCEO AS CEOName\n```\n\nThis query performs the following steps:\n\n1. **Match Organizations**: It finds organizations that are subsidiaries of organizations (`e:Organization)-[r:HAS_SUBSIDIARY]->(o:Organization)`).\n2. **Check Country**: It filters these organizations to only those headquartered in Europe (`:IN_COUNTRY]->(c:Country {name: \"Europe\"})`).\n3. **Industry Category**: It ensures that the industries are in the \"Electronic Products Manufacturers\" category (`:HAS_CATEGORY]->(ic:IndustryCategory {name: \"Electronic Products Manufacturers\"})`).\n4. **Return CEOs**: It retrieves the CEOs of these organizations (`e.hasCEO AS CEOName`).",
            "To find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe, you can use the following Cypher query:\n\n```cypher\nMATCH p=(o1:Organization)-[r:HAS_SUBSIDIARY]->(o2:Organization)<-[r2:IN_CITY]->(c:City)<-[r3:IN_COUNTRY]->(country:Country {name: 'Europe'})\nWHERE r2.name = 'Europe'\nAND r3.name = 'Europe'\nMATCH (o2)<-[r4:HAS_CEO]->(ceo:Person)\nRETURN DISTINCT ceo.name\n```\n\nThis query works as follows:\n1. It starts by matching any organization (`o1`) that is a subsidiary of another organization (`o2`) and is located in a city (`c`) that is in a country (`country`) named 'Europe'.\n2. It then filters the results to ensure both `r2` and `r3` are directed towards Europe.\n3. Finally, it matches the CEO of the `o2` organization and returns their names, ensuring that each person is returned only once using `DISTINCT`.",
            "To find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Person)-[r:HAS_CEO]->(o:Organization)<-[r2:HAS_SUBSIDIARY]-(o2:Organization)\nWHERE o2 IN (SELECT o FROM Organization WHERE country.name = 'Europe')\nRETURN e.name AS CEOName\n```\n\nThis query does the following:\n1. Matches any person (`e`) who has a `HAS_CEO` relationship to an organization (`o`).\n2. Finds the organization that is a subsidiary of `o` (`o2`) and checks if `o2` is located in Europe by filtering the `country` nodes.\n3. Returns the names of the CEOs who meet these criteria.",
            "```cypher\nMATCH (o:Organization)-[:HAS_SUBSIDIARY]->(s:Organization)-[:IN_CITY]->(c:City)-[:IN_COUNTRY]->(ct:Country)\nWHERE ct.name = 'Europe'\nWITH s\nMATCH (p:Person)-[:HAS_CEO]->(s)\nRETURN DISTINCT p.name\n```",
            "To find all persons who are CEOs of organizations that are subsidiaries of organizations headquartered in Europe, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Organization)-[:HAS_SUBSIDIARY]->(o:Organization)-[:HAS_CEO]->(p:Person)\nWHERE o.location IN ['Europe']\nRETURN p.name, p.summary\n```\n\n### Explanation:\n- `MATCH (e:Organization)-[:HAS_SUBSIDIARY]->(o:Organization)-[:HAS_CEO]->(p:Person)`: This pattern matches organizations that are subsidiaries (`HAS_SUBSIDIARY`) of another organization (`HAS_CEO`), which ultimately leads to a person (`CEO`).\n- `WHERE o.location IN ['Europe']`: This condition filters the organizations to only include those located in Europe.\n- `RETURN p.name, p.summary`: This returns the names and summaries of the CEOs of these organizations."
        ]
    },
    {
        "question": "Find the actors who have starred in both animated and live-action movies.",
        "schema": "Node properties:\n- **Movie**\n  - `url`: STRING Example: \"https://themoviedb.org/movie/862\"\n  - `runtime`: INTEGER Min: 2, Max: 910\n  - `revenue`: INTEGER Min: 1, Max: 2787965087\n  - `imdbRating`: FLOAT Min: 1.6, Max: 9.6\n  - `released`: STRING Example: \"1995-11-22\"\n  - `countries`: LIST Min Size: 1, Max Size: 16\n  - `languages`: LIST Min Size: 1, Max Size: 19\n  - `plot`: STRING Example: \"A cowboy doll is profoundly threatened and jealous\"\n  - `imdbVotes`: INTEGER Min: 13, Max: 1626900\n  - `imdbId`: STRING Example: \"0114709\"\n  - `year`: INTEGER Min: 1902, Max: 2016\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/uXDf\"\n  - `movieId`: STRING Example: \"1\"\n  - `tmdbId`: STRING Example: \"862\"\n  - `title`: STRING Example: \"Toy Story\"\n  - `budget`: INTEGER Min: 1, Max: 380000000\n- **Genre**\n  - `name`: STRING Example: \"Adventure\"\n- **User**\n  - `userId`: STRING Example: \"1\"\n  - `name`: STRING Example: \"Omar Huffman\"\n- **Actor**\n  - `url`: STRING Example: \"https://themoviedb.org/person/1271225\"\n  - `name`: STRING Example: \"Fran\u00e7ois Lallement\"\n  - `tmdbId`: STRING Example: \"1271225\"\n  - `bornIn`: STRING Example: \"France\"\n  - `bio`: STRING Example: \"\u200bFrom Wikipedia, the free encyclopedia  Lillian Di\"\n  - `died`: DATE Example: \"1954-01-01\"\n  - `born`: DATE Example: \"1877-02-04\"\n  - `imdbId`: STRING Example: \"2083046\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/6DCW\"\n- **Director**\n  - `url`: STRING Example: \"https://themoviedb.org/person/88953\"\n  - `bornIn`: STRING Example: \"Burchard, Nebraska, USA\"\n  - `born`: DATE Min: 1861-12-08, Max: 2018-05-01\n  - `died`: DATE Min: 1930-08-26, Max: 2976-09-29\n  - `tmdbId`: STRING Example: \"88953\"\n  - `imdbId`: STRING Example: \"0516001\"\n  - `name`: STRING Example: \"Harold Lloyd\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/er4Z\"\n  - `bio`: STRING Example: \"Harold Lloyd has been called the cinema\u2019s \u201cfirst m\"\n- **Person**\n  - `url`: STRING Example: \"https://themoviedb.org/person/1271225\"\n  - `died`: DATE Example: \"1954-01-01\"\n  - `bornIn`: STRING Example: \"France\"\n  - `born`: DATE Example: \"1877-02-04\"\n  - `imdbId`: STRING Example: \"2083046\"\n  - `name`: STRING Example: \"Fran\u00e7ois Lallement\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/6DCW\"\n  - `tmdbId`: STRING Example: \"1271225\"\n  - `bio`: STRING Example: \"\u200bFrom Wikipedia, the free encyclopedia  Lillian Di\"\nRelationship properties:\n- **RATED**\n  - `rating: FLOAT` Example: \"2.0\"\n  - `timestamp: INTEGER` Example: \"1260759108\"\n- **ACTED_IN**\n  - `role: STRING` Example: \"Officer of the Marines (uncredited)\"\n- **DIRECTED**\n  - `role: STRING` \nThe relationships:\n(:Movie)-[:IN_GENRE]->(:Genre)\n(:User)-[:RATED]->(:Movie)\n(:Actor)-[:ACTED_IN]->(:Movie)\n(:Actor)-[:DIRECTED]->(:Movie)\n(:Director)-[:DIRECTED]->(:Movie)\n(:Director)-[:ACTED_IN]->(:Movie)\n(:Person)-[:ACTED_IN]->(:Movie)\n(:Person)-[:DIRECTED]->(:Movie)",
        "gold_cypher": "MATCH (animationGenre:Genre {name: 'Animation'})<-[:IN_GENRE]-(animatedMovies:Movie) WITH animationGenre, animatedMovies MATCH (animatedMovies)<-[:ACTED_IN]-(animatedActors:Actor) WITH animationGenre, animatedMovies, animatedActors MATCH (otherMovies:Movie) WHERE NOT (:Genre {name: 'Animation'})<-[:IN_GENRE]-(otherMovies) WITH animationGenre, animatedMovies, animatedActors, otherMovies MATCH (otherMovies)<-[:ACTED_IN]-(otherActors:Actor) WITH animationGenre, animatedMovies, animatedActors, otherMovies, otherActors WHERE animatedActors = otherActors RETURN DISTINCT animatedActors.name",
        "database": "recommendations",
        "full_responses": [
            "To find the actors who have starred in both animated and live-action movies, you can use a Cypher query that involves matching movies with the `IN_GENRE` relationship and then counting the number of movies each actor has acted in for each genre. Here's how you can write the query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.title =~ '(?i).*animated.*'\nWITH m\nMATCH (a:Actor)-[r:ACTED_IN]->(m)\nWITH a, COUNT(m) AS animatedCount\nMATCH (m:Movie)\nWHERE m.title =~ '(?i).*live-action.*'\nWITH a, animatedCount, m\nMATCH (a:Actor)-[r:ACTED_IN]->(m)\nWITH a, animatedCount, COUNT(m) AS liveActionCount\nRETURN a.name, animatedCount, liveActionCount\nWHERE animatedCount > 0 AND liveActionCount > 0\nORDER BY animatedCount DESC, liveActionCount DESC;\n```\n\n### Explanation:\n1. **MATCH (m:Movie)**: This matches all movies.\n2. **WHERE m.title =~ '(?i).*animated.*'**: This filters movies that contain the word \"animated\" (case-insensitive).\n3. **WITH m**: This captures the matched movies in a variable `m`.\n4. **MATCH (a:Actor)-[r:ACTED_IN]->(m)**: This finds all actors who acted in the filtered movies.\n5. **WITH a, COUNT(m) AS animatedCount**: This counts the number of movies each actor acted in for the \"animated\" genre and stores it in the variable `animatedCount`.\n6. **MATCH (m:Movie)**: This matches all movies again to find movies with the word \"live-action\".\n7. **WHERE m.title =~ '(?i).*live-action.*'**: This filters movies that contain the word \"live-action\" (case-insensitive).\n8. **WITH a, animatedCount, m**: This captures the matched movies in a variable `m`.\n9. **MATCH (a:Actor)-[r:ACTED_IN]->(m)**: This finds all actors who acted in the filtered movies.\n10. **WITH a, animatedCount, liveActionCount**: This counts the number of movies each actor acted in for the \"live-action\" genre and stores it in the variable `liveActionCount`.\n11. **RETURN a.name, animatedCount, liveActionCount**: This returns the actor's name and the counts for both genres.\n12. **WHERE animatedCount > 0 AND liveActionCount > 0**: This ensures that only actors who have acted in both genres are returned.\n13. **ORDER BY animatedCount DESC, liveActionCount DESC**: This orders the results by the number of movies each actor acted in, in descending order.\n\nThis query will return the names of actors who have acted in both animated and live-action movies, along with the number of movies they have acted in for each genre.",
            "To find the actors who have starred in both animated and live-action movies, you can use a combination of Cypher queries to identify movies in each genre and then find the common actors between these sets. Here's how you can do it:\n\n```cypher\nMATCH (m:Movie)-[r:IN_GENRE]->(g:Genre)\nWHERE g.name IN ['Animation', 'Action']\nWITH m.movieId AS movieIds\nCALL apoc.util.map('movieIds', (movieId) => {\n  MATCH (a:Actor)-[ri:ACTED_IN {movieId: movieId}]->(m)\n  RETURN a.name AS actorName\n})\nYIELD movieIds, actors\nUNWIND actors AS actor\nRETURN actor\n```\n\n### Explanation:\n1. **MATCH (m:Movie)-[r:IN_GENRE]->(g:Genre)**: This query matches movies that are in the 'Animation' or 'Action' genres.\n2. **WITH m.movieId AS movieIds**: This captures the movie IDs of the movies that meet the genre criteria.\n3. **CALL apoc.util.map('movieIds', (movieId) => {...})**: This uses the `apoc.util.map` function to iterate over each movie ID and find the actors who acted in each movie.\n4. **MATCH (a:Actor)-[ri:ACTED_IN {movieId: movieId}]->(m)**: This query finds the actors who acted in each movie.\n5. **RETURN actorName**: This returns the name of the actor.\n6. **YIELD movieIds, actors**: This yields the movie IDs and the list of actors for each movie ID.\n7. **UNWIND actors AS actor**: This unwinds the list of actors into a single list.\n8. **RETURN actor**: This returns the list of actors who have acted in both movies.\n\nThis query will return the names of the actors who have starred in both animated and live-action movies.",
            "To find the actors who have starred in both animated and live-action movies, you can use Cypher to query the relationships between actors and movies. Here's a query that accomplishes this:\n\n```cypher\nMATCH (a:Actor)-[r:ACTED_IN]->(m:Movie)\nWHERE m.genre IN ['Animation', 'Live Action']\nWITH a, r\nMATCH (a)-[r2:ACTED_IN]->(m2:Movie)\nWHERE m2.genre IN ['Animation', 'Live Action']\nAND r <> r2\nRETURN a.name\n```\n\n### Explanation:\n1. **MATCH (a:Actor)-[r:ACTED_IN]->(m:Movie)**: This part matches all actors who have acted in movies.\n2. **WHERE m.genre IN ['Animation', 'Live Action']**: This filters the movies to only include animated and live-action movies.\n3. **WITH a, r**: This binds the actor node `a` and the relationship `r` to a temporary variable for the first set of matches.\n4. **MATCH (a)-[r2:ACTED_IN]->(m2:Movie)**: This matches the same actor again to find other movies they have acted in.\n5. **WHERE m2.genre IN ['Animation', 'Live Action']**: This ensures the second movie is also animated or live-action.\n6. **AND r <> r2**: This filters out the same movie from the second match to ensure we are looking for distinct movies.\n7. **RETURN a.name**: This returns the names of the actors who have acted in both sets of movies.\n\nThis query will return the names of actors who have starred in movies that are both animated and live-action.",
            "To find the actors who have starred in both animated and live-action movies, you can use the following Cypher query:\n\n```cypher\nMATCH (a:Actor)-[r:ACTED_IN]->(m:Movie)-[g:IN_GENRE]->(:Genre {name: \"Animation\"})\nWITH a, r, g\nMATCH (a)-[r2:ACTED_IN]->(m2:Movie)-[g2:IN_GENRE]->(:Genre {name: \"Live Action\"})\nRETURN a.name AS ActorName\nORDER BY ActorName\n```\n\nThis query does the following:\n1. It finds all actors who have acted in movies of the \"Animation\" genre.\n2. It then finds all actors who have acted in movies of the \"Live Action\" genre.\n3. It returns the names of actors who appear in both sets of movies, ensuring no duplicates by using `WITH` to capture the initial set of actors and then reusing them in the second `MATCH` clause.",
            "To find the actors who have starred in both animated and live-action movies, you can use a combination of Cypher queries to identify movies in each genre and then find the intersection of the actors from those movies. Here's a Cypher query to achieve that:\n\n```cypher\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN"
        ],
        "generated_cyphers": [
            "To find the actors who have starred in both animated and live-action movies, you can use a Cypher query that involves matching movies with the `IN_GENRE` relationship and then counting the number of movies each actor has acted in for each genre. Here's how you can write the query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.title =~ '(?i).*animated.*'\nWITH m\nMATCH (a:Actor)-[r:ACTED_IN]->(m)\nWITH a, COUNT(m) AS animatedCount\nMATCH (m:Movie)\nWHERE m.title =~ '(?i).*live-action.*'\nWITH a, animatedCount, m\nMATCH (a:Actor)-[r:ACTED_IN]->(m)\nWITH a, animatedCount, COUNT(m) AS liveActionCount\nRETURN a.name, animatedCount, liveActionCount\nWHERE animatedCount > 0 AND liveActionCount > 0\nORDER BY animatedCount DESC, liveActionCount DESC;\n```\n\n### Explanation:\n1. **MATCH (m:Movie)**: This matches all movies.\n2. **WHERE m.title =~ '(?i).*animated.*'**: This filters movies that contain the word \"animated\" (case-insensitive).\n3. **WITH m**: This captures the matched movies in a variable `m`.\n4. **MATCH (a:Actor)-[r:ACTED_IN]->(m)**: This finds all actors who acted in the filtered movies.\n5. **WITH a, COUNT(m) AS animatedCount**: This counts the number of movies each actor acted in for the \"animated\" genre and stores it in the variable `animatedCount`.\n6. **MATCH (m:Movie)**: This matches all movies again to find movies with the word \"live-action\".\n7. **WHERE m.title =~ '(?i).*live-action.*'**: This filters movies that contain the word \"live-action\" (case-insensitive).\n8. **WITH a, animatedCount, m**: This captures the matched movies in a variable `m`.\n9. **MATCH (a:Actor)-[r:ACTED_IN]->(m)**: This finds all actors who acted in the filtered movies.\n10. **WITH a, animatedCount, liveActionCount**: This counts the number of movies each actor acted in for the \"live-action\" genre and stores it in the variable `liveActionCount`.\n11. **RETURN a.name, animatedCount, liveActionCount**: This returns the actor's name and the counts for both genres.\n12. **WHERE animatedCount > 0 AND liveActionCount > 0**: This ensures that only actors who have acted in both genres are returned.\n13. **ORDER BY animatedCount DESC, liveActionCount DESC**: This orders the results by the number of movies each actor acted in, in descending order.\n\nThis query will return the names of actors who have acted in both animated and live-action movies, along with the number of movies they have acted in for each genre.",
            "To find the actors who have starred in both animated and live-action movies, you can use a combination of Cypher queries to identify movies in each genre and then find the common actors between these sets. Here's how you can do it:\n\n```cypher\nMATCH (m:Movie)-[r:IN_GENRE]->(g:Genre)\nWHERE g.name IN ['Animation', 'Action']\nWITH m.movieId AS movieIds\nCALL apoc.util.map('movieIds', (movieId) => {\n  MATCH (a:Actor)-[ri:ACTED_IN {movieId: movieId}]->(m)\n  RETURN a.name AS actorName\n})\nYIELD movieIds, actors\nUNWIND actors AS actor\nRETURN actor\n```\n\n### Explanation:\n1. **MATCH (m:Movie)-[r:IN_GENRE]->(g:Genre)**: This query matches movies that are in the 'Animation' or 'Action' genres.\n2. **WITH m.movieId AS movieIds**: This captures the movie IDs of the movies that meet the genre criteria.\n3. **CALL apoc.util.map('movieIds', (movieId) => {...})**: This uses the `apoc.util.map` function to iterate over each movie ID and find the actors who acted in each movie.\n4. **MATCH (a:Actor)-[ri:ACTED_IN {movieId: movieId}]->(m)**: This query finds the actors who acted in each movie.\n5. **RETURN actorName**: This returns the name of the actor.\n6. **YIELD movieIds, actors**: This yields the movie IDs and the list of actors for each movie ID.\n7. **UNWIND actors AS actor**: This unwinds the list of actors into a single list.\n8. **RETURN actor**: This returns the list of actors who have acted in both movies.\n\nThis query will return the names of the actors who have starred in both animated and live-action movies.",
            "To find the actors who have starred in both animated and live-action movies, you can use Cypher to query the relationships between actors and movies. Here's a query that accomplishes this:\n\n```cypher\nMATCH (a:Actor)-[r:ACTED_IN]->(m:Movie)\nWHERE m.genre IN ['Animation', 'Live Action']\nWITH a, r\nMATCH (a)-[r2:ACTED_IN]->(m2:Movie)\nWHERE m2.genre IN ['Animation', 'Live Action']\nAND r <> r2\nRETURN a.name\n```\n\n### Explanation:\n1. **MATCH (a:Actor)-[r:ACTED_IN]->(m:Movie)**: This part matches all actors who have acted in movies.\n2. **WHERE m.genre IN ['Animation', 'Live Action']**: This filters the movies to only include animated and live-action movies.\n3. **WITH a, r**: This binds the actor node `a` and the relationship `r` to a temporary variable for the first set of matches.\n4. **MATCH (a)-[r2:ACTED_IN]->(m2:Movie)**: This matches the same actor again to find other movies they have acted in.\n5. **WHERE m2.genre IN ['Animation', 'Live Action']**: This ensures the second movie is also animated or live-action.\n6. **AND r <> r2**: This filters out the same movie from the second match to ensure we are looking for distinct movies.\n7. **RETURN a.name**: This returns the names of the actors who have acted in both sets of movies.\n\nThis query will return the names of actors who have starred in movies that are both animated and live-action.",
            "To find the actors who have starred in both animated and live-action movies, you can use the following Cypher query:\n\n```cypher\nMATCH (a:Actor)-[r:ACTED_IN]->(m:Movie)-[g:IN_GENRE]->(:Genre {name: \"Animation\"})\nWITH a, r, g\nMATCH (a)-[r2:ACTED_IN]->(m2:Movie)-[g2:IN_GENRE]->(:Genre {name: \"Live Action\"})\nRETURN a.name AS ActorName\nORDER BY ActorName\n```\n\nThis query does the following:\n1. It finds all actors who have acted in movies of the \"Animation\" genre.\n2. It then finds all actors who have acted in movies of the \"Live Action\" genre.\n3. It returns the names of actors who appear in both sets of movies, ensuring no duplicates by using `WITH` to capture the initial set of actors and then reusing them in the second `MATCH` clause.",
            "To find the actors who have starred in both animated and live-action movies, you can use a combination of Cypher queries to identify movies in each genre and then find the intersection of the actors from those movies. Here's a Cypher query to achieve that:\n\n```cypher\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre {name: \"Animation\"})\nWITH m, g\nMATCH (m:Movie)-[:IN_GENRE]->(g2:Genre {name: \"Live Action\"})\nRETURN m.title AS animatedMovies, g.name AS animationGenre, m.title AS liveActionMovies, g2.name AS liveActionGenre\nUNION\nMATCH (m:Movie)-[:IN"
        ]
    },
    {
        "question": "\"reflect all possible patterns linking DataCenters to IP adreses\"",
        "schema": "Node properties:\nDataCenter {name: STRING, location: STRING}\nRouter {name: STRING, zone: INTEGER}\nEgress {name: STRING}\nInterface {ip: STRING}\nNetwork {ip: STRING, size: INTEGER, zone: INTEGER}\nZone {ip: STRING, size: INTEGER, zone: INTEGER}\nRack {name: STRING, zone: INTEGER, rack: INTEGER}\nSwitch {ip: STRING, rack: INTEGER}\nType {id: INTEGER, type: STRING, ram: INTEGER, name: STRING, disk: INTEGER, cpu: INTEGER}\nMachine {name: STRING}\nSoftware {name: STRING, versions: LIST, ports: LIST, dependencies: LIST}\nOS {name: STRING, startTime: INTEGER}\nService {pid: INTEGER, name: STRING, startTime: INTEGER}\nApplication {name: STRING, startTime: INTEGER, pid: INTEGER}\nVersion {name: STRING}\nProcess {name: STRING, startTime: INTEGER, pid: INTEGER}\nPort {port: INTEGER}\nRelationship properties:\n\nThe relationships:\n(:DataCenter)-[:CONTAINS]->(:Rack)\n(:DataCenter)-[:CONTAINS]->(:Router)\n(:DataCenter)-[:CONTAINS]->(:Egress)\n(:Router)-[:ROUTES]->(:Interface)\n(:Egress)-[:ROUTES]->(:Interface)\n(:Interface)-[:EXPOSES]->(:Port)\n(:Interface)-[:CONNECTS]->(:Interface)\n(:Network)-[:ROUTES]->(:Interface)\n(:Zone)-[:ROUTES]->(:Interface)\n(:Rack)-[:HOLDS]->(:Machine)\n(:Rack)-[:HOLDS]->(:Switch)\n(:Switch)-[:ROUTES]->(:Interface)\n(:Machine)-[:RUNS]->(:OS)\n(:Machine)-[:RUNS]->(:Process)\n(:Machine)-[:RUNS]->(:Application)\n(:Machine)-[:RUNS]->(:Service)\n(:Machine)-[:ROUTES]->(:Interface)\n(:Machine)-[:TYPE]->(:Type)\n(:Software)-[:VERSION]->(:Version)\n(:Software)-[:DEPENDS_ON]->(:Version)\n(:Software)-[:DEPENDS_ON]->(:Software)\n(:Software)-[:DEPENDS_ON]->(:Application)\n(:Software)-[:DEPENDS_ON]->(:Service)\n(:OS)-[:INSTANCE]->(:Version)\n(:Service)-[:INSTANCE]->(:Software)\n(:Service)-[:INSTANCE]->(:Service)\n(:Service)-[:INSTANCE]->(:Application)\n(:Service)-[:INSTANCE]->(:Version)\n(:Service)-[:LISTENS]->(:Port)\n(:Application)-[:LISTENS]->(:Port)\n(:Application)-[:INSTANCE]->(:Software)\n(:Application)-[:INSTANCE]->(:Application)\n(:Application)-[:DEPENDS_ON]->(:Service)\n(:Application)-[:DEPENDS_ON]->(:Process)\n(:Version)-[:PREVIOUS]->(:Version)\n(:Process)-[:INSTANCE]->(:Software)\n(:Process)-[:INSTANCE]->(:Application)\n(:Process)-[:INSTANCE]->(:Version)\n(:Process)-[:INSTANCE]->(:Service)\n(:Process)-[:LISTENS]->(:Port)\n(:Process)-[:DEPENDS_ON]->(:Service)\n(:Process)-[:DEPENDS_ON]->(:Process)",
        "gold_cypher": "MATCH (dc:DataCenter)-[:CONTAINS]->(r:Router)-[:ROUTES]->(intf:Interface) RETURN dc.name AS DataCenterName, intf.ip AS IPAddress UNION MATCH (dc:DataCenter)-[:CONTAINS]->(e:Egress)-[:ROUTES]->(intf:Interface) RETURN dc.name AS DataCenterName, intf.ip AS IPAddress UNION MATCH (dc:DataCenter)-[:CONTAINS]->(:Rack)-[:HOLDS]->(:Machine)-[:ROUTES]->(intf:Interface) RETURN dc.name AS DataCenterName, intf.ip AS IPAddress UNION MATCH (dc:DataCenter)-[:CONTAINS]->(:Rack)-[:HOLDS]->(:Switch)-[:ROUTES]->(intf:Interface) RETURN dc.name AS DataCenterName, intf.ip AS IPAddress",
        "database": "network",
        "full_responses": [
            "To answer the question \"Reflect all possible patterns linking DataCenters to IP addresses, \" we need to identify all the paths in the Neo4j graph that start from a `DataCenter` node and end at an `Interface` node, and then trace these paths to reach `IP` addresses. Here's how you can write the Cypher query to achieve this:\n\n```cypher\nMATCH p=(dc:DataCenter)-[:CONTAINS*]->(interface:Interface)\nRETURN p\n```\n\nThis query uses the `MATCH` clause to find all paths starting from a `DataCenter` node and ending at an `Interface` node. The `CONTAINS*` relationship allows for any number of intermediate `Rack` or `Zone` nodes, capturing all possible paths that connect a data center to an interface. The `RETURN p` statement returns all the paths found.\n\nIf you specifically want to trace these paths further to reach `IP` addresses, you can add additional clauses to filter or project the results. For example, if you want to retrieve the IP addresses from the interfaces, you can modify the query as follows:\n\n```cypher\nMATCH p=(dc:DataCenter)-[:CONTAINS*]->(interface:Interface)\nRETURN p, interface.ip\n```\n\nThis query will return each path and the IP address associated with each interface in the path. Adjust the query as needed based on the specific requirements of your analysis.",
            "To reflect all possible patterns linking DataCenters to IP addresses in your Neo4j database, you can use the following Cypher query. This query will traverse the graph starting from DataCenters and follow the relationships to find all IP addresses associated with them.\n\n```cypher\nMATCH (dc:DataCenter)-[:CONTAINS|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|",
            "To reflect all possible patterns linking DataCenters to IP addresses, you can use the following Cypher query:\n\n```cypher\nMATCH (dc:DataCenter)-[r]->(ip:Interface)\nRETURN dc.name AS DataCenterName, ip.ip AS IPAddress\n```\n\nThis query starts from nodes of type `DataCenter` and traverses through all relationships to find and return the names of `DataCenters` and the IP addresses associated with `Interfaces`.",
            "To reflect all possible patterns linking DataCenters to IP addresses in your Neo4j database, you can use a combination of `MATCH` and `WITH` clauses to traverse the relationships and collect all unique IP addresses associated with DataCenters. Here's a Cypher query that accomplishes this:\n\n```cypher\nMATCH path = (dc:DataCenter)-[*]-(ip:Interface)\nRETURN ip.ip AS ipAddress\nUNION\nMATCH path = (dc:DataCenter)-[*]-(network:Network)\nRETURN network.ip AS ipAddress\nUNION\nMATCH path = (dc:DataCenter)-[*]-(zone:Zone)\nRETURN zone.ip AS ipAddress\nUNION\nMATCH path = (dc:DataCenter)-[*]-(egress:Egress)\nRETURN egress.ip AS ipAddress\n```\n\nThis query traverses all possible paths starting from `DataCenter` nodes and collects all IP addresses (`Interface`, `Network`, `Zone`, and `Egress`) that are reachable from these nodes. The `UNION` operator ensures that all unique IP addresses are returned without duplicates.",
            "To reflect all possible patterns linking `DataCenters` to IP addresses, we can query the Neo4j database to find all nodes that have IP addresses and their relationships. Here's a Cypher query that accomplishes this:\n\n```cypher\nMATCH (d:DataCenter)-[r:CONTAINS|ROUTES|EXPOSES|CONNECTS|ROUTES|HOLDS|RUNS|TYPE|INSTANCE|DEPENDS_ON|LISTENS]->(n)\nWHERE EXISTS(n.ip)\nRETURN d.name, r.type, n.ip;\n```\n\n### Explanation:\n- `MATCH (d:DataCenter)-[r:CONTAINS|ROUTES|EXPOSES|CONNECTS|ROUTES|HOLDS|RUNS|TYPE|INSTANCE|DEPENDS_ON|LISTENS]->(n)`: This pattern matches any `DataCenter` node and any relationship (of types `CONTAINS`, `ROUTES`, `EXPOSES`, `CONNECTS`, `ROUTES`, `HOLDS`, `RUNS`, `TYPE`, `INSTANCE`, `DEPENDS_ON`, `LISTENS`) that leads to another node (`n`).\n- `WHERE EXISTS(n.ip)`: This condition filters the results to only include nodes that have an `ip` property.\n- `RETURN d.name, r.type, n.ip`: This clause returns the name of the `DataCenter`, the type of the relationship, and the IP address of the target node.\n\nThis query will return all possible paths from `DataCenters` to IP addresses through various relationships."
        ],
        "generated_cyphers": [
            "To answer the question \"Reflect all possible patterns linking DataCenters to IP addresses, \" we need to identify all the paths in the Neo4j graph that start from a `DataCenter` node and end at an `Interface` node, and then trace these paths to reach `IP` addresses. Here's how you can write the Cypher query to achieve this:\n\n```cypher\nMATCH p=(dc:DataCenter)-[:CONTAINS*]->(interface:Interface)\nRETURN p\n```\n\nThis query uses the `MATCH` clause to find all paths starting from a `DataCenter` node and ending at an `Interface` node. The `CONTAINS*` relationship allows for any number of intermediate `Rack` or `Zone` nodes, capturing all possible paths that connect a data center to an interface. The `RETURN p` statement returns all the paths found.\n\nIf you specifically want to trace these paths further to reach `IP` addresses, you can add additional clauses to filter or project the results. For example, if you want to retrieve the IP addresses from the interfaces, you can modify the query as follows:\n\n```cypher\nMATCH p=(dc:DataCenter)-[:CONTAINS*]->(interface:Interface)\nRETURN p, interface.ip\n```\n\nThis query will return each path and the IP address associated with each interface in the path. Adjust the query as needed based on the specific requirements of your analysis.",
            "To reflect all possible patterns linking DataCenters to IP addresses in your Neo4j database, you can use the following Cypher query. This query will traverse the graph starting from DataCenters and follow the relationships to find all IP addresses associated with them.\n\n```cypher\nMATCH (dc:DataCenter)-[:CONTAINS|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|ROUTES|",
            "To reflect all possible patterns linking DataCenters to IP addresses, you can use the following Cypher query:\n\n```cypher\nMATCH (dc:DataCenter)-[r]->(ip:Interface)\nRETURN dc.name AS DataCenterName, ip.ip AS IPAddress\n```\n\nThis query starts from nodes of type `DataCenter` and traverses through all relationships to find and return the names of `DataCenters` and the IP addresses associated with `Interfaces`.",
            "To reflect all possible patterns linking DataCenters to IP addresses in your Neo4j database, you can use a combination of `MATCH` and `WITH` clauses to traverse the relationships and collect all unique IP addresses associated with DataCenters. Here's a Cypher query that accomplishes this:\n\n```cypher\nMATCH path = (dc:DataCenter)-[*]-(ip:Interface)\nRETURN ip.ip AS ipAddress\nUNION\nMATCH path = (dc:DataCenter)-[*]-(network:Network)\nRETURN network.ip AS ipAddress\nUNION\nMATCH path = (dc:DataCenter)-[*]-(zone:Zone)\nRETURN zone.ip AS ipAddress\nUNION\nMATCH path = (dc:DataCenter)-[*]-(egress:Egress)\nRETURN egress.ip AS ipAddress\n```\n\nThis query traverses all possible paths starting from `DataCenter` nodes and collects all IP addresses (`Interface`, `Network`, `Zone`, and `Egress`) that are reachable from these nodes. The `UNION` operator ensures that all unique IP addresses are returned without duplicates.",
            "To reflect all possible patterns linking `DataCenters` to IP addresses, we can query the Neo4j database to find all nodes that have IP addresses and their relationships. Here's a Cypher query that accomplishes this:\n\n```cypher\nMATCH (d:DataCenter)-[r:CONTAINS|ROUTES|EXPOSES|CONNECTS|ROUTES|HOLDS|RUNS|TYPE|INSTANCE|DEPENDS_ON|LISTENS]->(n)\nWHERE EXISTS(n.ip)\nRETURN d.name, r.type, n.ip;\n```\n\n### Explanation:\n- `MATCH (d:DataCenter)-[r:CONTAINS|ROUTES|EXPOSES|CONNECTS|ROUTES|HOLDS|RUNS|TYPE|INSTANCE|DEPENDS_ON|LISTENS]->(n)`: This pattern matches any `DataCenter` node and any relationship (of types `CONTAINS`, `ROUTES`, `EXPOSES`, `CONNECTS`, `ROUTES`, `HOLDS`, `RUNS`, `TYPE`, `INSTANCE`, `DEPENDS_ON`, `LISTENS`) that leads to another node (`n`).\n- `WHERE EXISTS(n.ip)`: This condition filters the results to only include nodes that have an `ip` property.\n- `RETURN d.name, r.type, n.ip`: This clause returns the name of the `DataCenter`, the type of the relationship, and the IP address of the target node.\n\nThis query will return all possible paths from `DataCenters` to IP addresses through various relationships."
        ]
    },
    {
        "question": "Find the filings where the 'originator_bank' and 'beneficiary_bank' are both located in countries that are members of the European Union.",
        "schema": "Node properties:\n- **Country**\n  - `location`: POINT \n  - `code`: STRING Example: \"AFG\"\n  - `name`: STRING Example: \"Afghanistan\"\n  - `tld`: STRING Example: \"AF\"\n- **Filing**\n  - `begin`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-09-05T00:00:00Z\n  - `end`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-11-03T00:00:00Z\n  - `originator_bank_id`: STRING Example: \"cimb-bank-berhad\"\n  - `sar_id`: STRING Example: \"3297\"\n  - `beneficiary_bank`: STRING Example: \"Barclays Bank Plc\"\n  - `filer_org_name_id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `originator_bank_country`: STRING Example: \"Singapore\"\n  - `beneficiary_bank_country`: STRING Example: \"United Kingdom\"\n  - `filer_org_name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `originator_iso`: STRING Example: \"SGP\"\n  - `beneficiary_bank_id`: STRING Example: \"barclays-bank-plc-london-england-gbr\"\n  - `origin_lat`: STRING Example: \"1.3667\"\n  - `origin_lng`: STRING Example: \"103.8\"\n  - `end_date_format`: STRING Example: \"2015-09-25T00:00:00Z\"\n  - `begin_date_format`: STRING Example: \"2015-03-25T00:00:00Z\"\n  - `originator_bank`: STRING Example: \"CIMB Bank Berhad\"\n  - `beneficiary_lat`: STRING Example: \"54\"\n  - `beneficiary_iso`: STRING Example: \"GBR\"\n  - `beneficiary_lng`: STRING Example: \"-2\"\n  - `begin_date`: STRING Example: \"Mar 25, 2015\"\n  - `id`: STRING Example: \"223254\"\n  - `end_date`: STRING Example: \"Sep 25, 2015\"\n  - `amount`: INTEGER Min: 1.18, Max: 2721000000\n  - `number`: INTEGER Min: 1, Max: 174\n- **Entity**\n  - `id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `location`: POINT \n  - `name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `country`: STRING Example: \"CHN\"\nRelationship properties:\n\nThe relationships:\n(:Filing)-[:BENEFITS]->(:Entity)\n(:Filing)-[:CONCERNS]->(:Entity)\n(:Filing)-[:ORIGINATOR]->(:Entity)\n(:Entity)-[:FILED]->(:Filing)\n(:Entity)-[:COUNTRY]->(:Country)",
        "gold_cypher": "MATCH (f:Filing)-[:ORIGINATOR]->(ob:Entity)-[:COUNTRY]->(oc:Country),       (f:Filing)-[:BENEFITS]->(bb:Entity)-[:COUNTRY]->(bc:Country) WHERE oc.code IN ['AUT', 'BEL', 'BGR', 'HRV', 'CYP', 'CZE', 'DNK', 'EST', 'FIN', 'FRA', 'DEU', 'GRC', 'HUN', 'IRL', 'ITA', 'LVA', 'LTU', 'LUX', 'MLT', 'NLD', 'POL', 'PRT', 'ROU', 'SVK', 'SVN', 'ESP', 'SWE']   AND bc.code IN ['AUT', 'BEL', 'BGR', 'HRV', 'CYP', 'CZE', 'DNK', 'EST', 'FIN', 'FRA', 'DEU', 'GRC', 'HUN', 'IRL', 'ITA', 'LVA', 'LTU', 'LUX', 'MLT', 'NLD', 'POL', 'PRT', 'ROU', 'SVK', 'SVN', 'ESP', 'SWE'] RETURN f.sar_id",
        "database": "fincen",
        "full_responses": [
            "To find the filings where both the 'originator_bank' and 'beneficiary_bank' are located in countries that are members of the European Union, you can use the following Cypher query. This query assumes that you have a list of EU country codes in a variable called `europeanUnionCountries`.\n\n```cypher\nWITH ['AT', 'BE', 'BG', 'CY', 'CZ', 'DE', 'DK', 'EE', 'FI', 'FR', 'GR', 'HR', 'HU', 'IE', 'IS', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'NO', 'PL', 'PT', 'RO', 'SE', 'SI', 'SK', 'ES', 'CH', 'GB'] AS europeanUnionCountries\n\nMATCH (f:Filing)-[:ORIGINATOR]->(ob:Entity)-[:COUNTRY]->(oc:Country)-[:COUNTRY_CODE]->(ocCode:CountryCode)\nWHERE ocCode.code IN europeanUnionCountries\nAND oc.name = ocCode.name\nAND oc.name IN europeanUnionCountries\n\nMATCH (f:Filing)-[:BENEFICIARY]->(bb:Entity)-[:COUNTRY]->(bc:Country)-[:COUNTRY_CODE]->(bcCode:CountryCode)\nWHERE bcCode.code IN europeanUnionCountries\nAND bc.name = bcCode.name\nAND bc.name IN europeanUnionCountries\n\nRETURN f\n```\n\nThis query first retrieves the list of EU country codes. It then matches filings where the 'originator_bank' and 'beneficiary_bank' are both located in countries that are members of the European Union. The query uses the `COUNTRY_CODE` relationship to connect countries to their respective ISO codes and names. The `WHERE` clause ensures that the country is part of the EU by checking if its ISO code, name, and official name are present in the list of EU country codes.",
            "To find the filings where the 'originator_bank' and 'beneficiary_bank' are both located in countries that are members of the European Union (EU), you can use the following Cypher query:\n\n```cypher\nMATCH (f:Filing)\nWHERE EXISTS (\n  (f.originator_bank)-[:COUNTRY]->(c1:Country {tld: 'EU'})\n  AND (f.beneficiary_bank)-[:COUNTRY]->(c2:Country {tld: 'EU'})\n)\nRETURN f;\n```\n\nThis query works as follows:\n- It starts by matching all nodes of type `Filing`.\n- It then checks if both the `originator_bank` and `beneficiary_bank` nodes are related to a `Country` node where the `tld` is 'EU', indicating membership in the European Union.\n- If both conditions are met, the query returns the `Filing` node.",
            "To find filings where the 'originator_bank' and 'beneficiary_bank' are both located in countries that are members of the European Union, you need to identify which countries are members of the European Union and then use these country codes to filter the filings. Here's how you can construct the Cypher query:\n\n```cypher\nMATCH (f:Filing)-[:ORIGINATOR]->(ob:Entity)\nMATCH (f)-[:BENEFICIARY]->(bb:Entity)\nWHERE ob.country IN ['AT', 'BE', 'BG', 'CH', 'CY', 'CZ', 'DE', 'DK', 'EE', 'EL', 'ES', 'FI', 'FR', 'GB', 'GR', 'HU', 'IE', 'IS', 'IT', 'LT', 'LU', 'LV', 'MT', 'NL', 'NO', 'PL', 'PT', 'RO', 'SE', 'SI', 'SK', 'ES']\n  AND bb.country IN ['AT', 'BE', 'BG', 'CH', 'CY', 'CZ', 'DE', 'DK', 'EE', 'EL', 'ES', 'FI', 'FR', 'GB', 'GR', 'HU', 'IE', 'IS', 'IT', 'LT', 'LU', 'LV', 'MT', 'NL', 'NO', 'PL', 'PT', 'RO', 'SE', 'SI', 'SK', 'ES']\nRETURN f;\n```\n\nThis query performs the following steps:\n1. Matches all `Filing` nodes (`f`) and their corresponding `Entity` nodes (`ob` and `bb`) through the `ORIGINATOR` and `BENEFICIARY` relationships.\n2. Checks if the `country` property of both `ob` and `bb` is in the list of European Union country codes.\n3. Returns the `Filing` nodes that meet the criteria.",
            "```cypher\nMATCH (f:Filing)-[r:CONCERNS|ORIGINATOR]->(e:Entity)-[c:COUNTRY]->(cou:Country)\nWHERE cou.tld IN ['eu', 'uk', 'de', 'fr', 'es', 'it', 'nl', 'gr', 'se', 'ch', 'at', 'be', 'fi', 'hu', 'lv', 'lt', 'lt', 'si', 'ro', 'cz', 'pl', 'bg', 'hu', 'sk', 'hu', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', '",
            "To find the filings where both the 'originator_bank' and 'beneficiary_bank' are located in countries that are members of the European Union, you can use the following Cypher query. This query assumes that the European Union members are defined in a separate node type or property.\n\n```cypher\nMATCH (country:Country)\nWHERE country.tld IN ['EU', 'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'NO', 'PL', 'PT', 'RO', 'SE', 'SI', 'SK', 'ES', 'GB', 'MC', 'LI', 'AT', 'EU']\nWITH country\nOPTIONAL MATCH (originator:Entity)-[r:ORIGINATOR]->(country)\nOPTIONAL MATCH (beneficiary:Entity)-[r:CONCERNS]->(country)\nWHERE originator.country <> beneficiary.country AND originator.country IN labels(country) AND beneficiary.country IN labels(country)\nRETURN r\n```\n\nThis query does the following:\n1. Matches all `Country` nodes that are members of the European Union.\n2. Finds `Entity` nodes that are originators of filings and associates them with the matched countries.\n3. Finds `Entity` nodes that are beneficiaries of filings and associates them with the matched countries.\n4. Filters the results to ensure that both the originator and beneficiary are associated with the same country node, ensuring that they are both located in the same EU country.\n5. Returns the relationships that satisfy these conditions."
        ],
        "generated_cyphers": [
            "To find the filings where both the 'originator_bank' and 'beneficiary_bank' are located in countries that are members of the European Union, you can use the following Cypher query. This query assumes that you have a list of EU country codes in a variable called `europeanUnionCountries`.\n\n```cypher\nWITH ['AT', 'BE', 'BG', 'CY', 'CZ', 'DE', 'DK', 'EE', 'FI', 'FR', 'GR', 'HR', 'HU', 'IE', 'IS', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'NO', 'PL', 'PT', 'RO', 'SE', 'SI', 'SK', 'ES', 'CH', 'GB'] AS europeanUnionCountries\n\nMATCH (f:Filing)-[:ORIGINATOR]->(ob:Entity)-[:COUNTRY]->(oc:Country)-[:COUNTRY_CODE]->(ocCode:CountryCode)\nWHERE ocCode.code IN europeanUnionCountries\nAND oc.name = ocCode.name\nAND oc.name IN europeanUnionCountries\n\nMATCH (f:Filing)-[:BENEFICIARY]->(bb:Entity)-[:COUNTRY]->(bc:Country)-[:COUNTRY_CODE]->(bcCode:CountryCode)\nWHERE bcCode.code IN europeanUnionCountries\nAND bc.name = bcCode.name\nAND bc.name IN europeanUnionCountries\n\nRETURN f\n```\n\nThis query first retrieves the list of EU country codes. It then matches filings where the 'originator_bank' and 'beneficiary_bank' are both located in countries that are members of the European Union. The query uses the `COUNTRY_CODE` relationship to connect countries to their respective ISO codes and names. The `WHERE` clause ensures that the country is part of the EU by checking if its ISO code, name, and official name are present in the list of EU country codes.",
            "To find the filings where the 'originator_bank' and 'beneficiary_bank' are both located in countries that are members of the European Union (EU), you can use the following Cypher query:\n\n```cypher\nMATCH (f:Filing)\nWHERE EXISTS (\n  (f.originator_bank)-[:COUNTRY]->(c1:Country {tld: 'EU'})\n  AND (f.beneficiary_bank)-[:COUNTRY]->(c2:Country {tld: 'EU'})\n)\nRETURN f;\n```\n\nThis query works as follows:\n- It starts by matching all nodes of type `Filing`.\n- It then checks if both the `originator_bank` and `beneficiary_bank` nodes are related to a `Country` node where the `tld` is 'EU', indicating membership in the European Union.\n- If both conditions are met, the query returns the `Filing` node.",
            "To find filings where the 'originator_bank' and 'beneficiary_bank' are both located in countries that are members of the European Union, you need to identify which countries are members of the European Union and then use these country codes to filter the filings. Here's how you can construct the Cypher query:\n\n```cypher\nMATCH (f:Filing)-[:ORIGINATOR]->(ob:Entity)\nMATCH (f)-[:BENEFICIARY]->(bb:Entity)\nWHERE ob.country IN ['AT', 'BE', 'BG', 'CH', 'CY', 'CZ', 'DE', 'DK', 'EE', 'EL', 'ES', 'FI', 'FR', 'GB', 'GR', 'HU', 'IE', 'IS', 'IT', 'LT', 'LU', 'LV', 'MT', 'NL', 'NO', 'PL', 'PT', 'RO', 'SE', 'SI', 'SK', 'ES']\n  AND bb.country IN ['AT', 'BE', 'BG', 'CH', 'CY', 'CZ', 'DE', 'DK', 'EE', 'EL', 'ES', 'FI', 'FR', 'GB', 'GR', 'HU', 'IE', 'IS', 'IT', 'LT', 'LU', 'LV', 'MT', 'NL', 'NO', 'PL', 'PT', 'RO', 'SE', 'SI', 'SK', 'ES']\nRETURN f;\n```\n\nThis query performs the following steps:\n1. Matches all `Filing` nodes (`f`) and their corresponding `Entity` nodes (`ob` and `bb`) through the `ORIGINATOR` and `BENEFICIARY` relationships.\n2. Checks if the `country` property of both `ob` and `bb` is in the list of European Union country codes.\n3. Returns the `Filing` nodes that meet the criteria.",
            "```cypher\nMATCH (f:Filing)-[r:CONCERNS|ORIGINATOR]->(e:Entity)-[c:COUNTRY]->(cou:Country)\nWHERE cou.tld IN ['eu', 'uk', 'de', 'fr', 'es', 'it', 'nl', 'gr', 'se', 'ch', 'at', 'be', 'fi', 'hu', 'lv', 'lt', 'lt', 'si', 'ro', 'cz', 'pl', 'bg', 'hu', 'sk', 'hu', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', 'lt', '",
            "To find the filings where both the 'originator_bank' and 'beneficiary_bank' are located in countries that are members of the European Union, you can use the following Cypher query. This query assumes that the European Union members are defined in a separate node type or property.\n\n```cypher\nMATCH (country:Country)\nWHERE country.tld IN ['EU', 'AT', 'BE', 'BG', 'HR', 'CY', 'CZ', 'DK', 'EE', 'FI', 'FR', 'DE', 'GR', 'HU', 'IE', 'IT', 'LV', 'LT', 'LU', 'MT', 'NL', 'NO', 'PL', 'PT', 'RO', 'SE', 'SI', 'SK', 'ES', 'GB', 'MC', 'LI', 'AT', 'EU']\nWITH country\nOPTIONAL MATCH (originator:Entity)-[r:ORIGINATOR]->(country)\nOPTIONAL MATCH (beneficiary:Entity)-[r:CONCERNS]->(country)\nWHERE originator.country <> beneficiary.country AND originator.country IN labels(country) AND beneficiary.country IN labels(country)\nRETURN r\n```\n\nThis query does the following:\n1. Matches all `Country` nodes that are members of the European Union.\n2. Finds `Entity` nodes that are originators of filings and associates them with the matched countries.\n3. Finds `Entity` nodes that are beneficiaries of filings and associates them with the matched countries.\n4. Filters the results to ensure that both the originator and beneficiary are associated with the same country node, ensuring that they are both located in the same EU country.\n5. Returns the relationships that satisfy these conditions."
        ]
    },
    {
        "question": "List the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book.",
        "schema": "Node properties:\n- **Character**\n  - `centrality`: FLOAT Min: 0.0, Max: 1.0\n  - `book45PageRank`: FLOAT Min: 0.15000000000000002, Max: 11.409916274911177\n  - `fastrf_embedding`: LIST Min Size: 10, Max Size: 10\n  - `book1BetweennessCentrality`: FLOAT Min: 0.0, Max: 4638.53495125504\n  - `book1PageRank`: FLOAT Min: 0.15000000000000002, Max: 8.164174336296284\n  - `louvain`: INTEGER Min: 0, Max: 10\n  - `community`: INTEGER Min: 504, Max: 795\n  - `degree`: FLOAT Min: 0.0, Max: 300.0\n  - `name`: STRING Example: \"Addam-Marbrand\"\n  - `pagerank`: FLOAT Min: 0.15000000000000002, Max: 9.473142454730429\nRelationship properties:\n- **INTERACTS**\n  - `weight: INTEGER` Min: 3, Max:  334\n- **INTERACTS1**\n  - `weight: INTEGER` Min: 3, Max:  291\n  - `book: INTEGER` Min: 1, Max:  1\n- **INTERACTS2**\n  - `weight: INTEGER` Min: 3, Max:  92\n  - `book: INTEGER` Min: 2, Max:  2\n- **INTERACTS3**\n  - `weight: INTEGER` Min: 3, Max:  95\n  - `book: INTEGER` Min: 3, Max:  3\n- **INTERACTS45**\n  - `weight: INTEGER` Min: 3, Max:  96\n  - `book: INTEGER` Min: 45, Max:  45\nThe relationships:\n(:Character)-[:INTERACTS45]->(:Character)\n(:Character)-[:INTERACTS]->(:Character)\n(:Character)-[:INTERACTS1]->(:Character)\n(:Character)-[:INTERACTS3]->(:Character)\n(:Character)-[:INTERACTS2]->(:Character)",
        "gold_cypher": "MATCH (stevron:Character {name: 'Stevron-Frey'}) CALL {     WITH stevron     MATCH (stevron)-[:INTERACTS|:INTERACTS1|:INTERACTS2|:INTERACTS3|:INTERACTS45]-(char1)     RETURN collect(DISTINCT char1) AS stevron_interacted_with } MATCH (walder:Character {name: 'Walder-Rivers'}) CALL {     WITH walder     MATCH (walder)-[:INTERACTS|:INTERACTS1|:INTERACTS2|:INTERACTS3|:INTERACTS45]-(char2)     RETURN collect(DISTINCT char2) AS walder_interacted_with } RETURN apoc.coll.intersection(stevron_interacted_with, walder_interacted_with) AS characters_interacted_with_both",
        "database": "gameofthrones",
        "full_responses": [
            "To list the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book, you can use the following Cypher query:\n\n```cypher\nMATCH (a:Character)-[r:INTERACTS45|INTERACTS|INTERACTS1|INTERACTS3|INTERACTS2]->(b:Character)\nWHERE a.name = 'Stevron-Frey' AND b.name = 'Walder-Rivers'\nRETURN DISTINCT a.name, b.name;\n```\n\nThis query matches all pairs of characters who interacted with each other (`INTERACTS45`, `INTERACTS`, `INTERACTS1`, `INTERACTS3`, or `INTERACTS2`) and filters for the specific characters 'Stevron-Frey' and 'Walder-Rivers'. The `DISTINCT` keyword ensures that each character name is listed only once.",
            "To list the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book, you can use the following Cypher query:\n\n```cypher\nMATCH (a:Character {name: 'Stevron-Frey'})-[:INTERACTS*1..2]->(b:Character {name: 'Walder-Rivers'})\nRETURN DISTINCT a.name, b.name\n```\n\nThis query uses the `MATCH` clause to find paths of length 1 or 2 between 'Stevron-Frey' and 'Walder-Rivers' through the `INTERACTS` relationship. The `DISTINCT` keyword ensures that each character pair is listed only once, even if they are connected in multiple ways.",
            "To find the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book, you can use the following Cypher query:\n\n```cypher\nMATCH (char1:Character)-[r1:INTERACTS*1..3]->(char2:Character)\nWHERE (char1.name = 'Stevron-Frey' AND char2.name = 'Walder-Rivers')\nRETURN DISTINCT char1.name, char2.name;\n```\n\nThis query uses a pattern to match characters who interact with each other through one to three relationships. It ensures that the relationships are between 'Stevron-Frey' and 'Walder-Rivers' and returns the distinct pairs of characters who satisfied this condition.",
            "To list the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book, you can use the following Cypher query:\n\n```cypher\nMATCH (c1:Character {name: 'Stevron-Frey'}),\n       (c2:Character {name: 'Walder-Rivers'}),\n       p = shortestPath((c1)-[r:INTERACTS*1..5]-(c2))\nRETURN DISTINCT c1.name AS Character1, c2.name AS Character2, p\nORDER BY LENGTH(p);\n```\n\nThis query uses the `shortestPath` function to find the shortest path between 'Stevron-Frey' and 'Walder-Rivers' across any number of interactions (up to 5 in this case) and returns the distinct characters involved in these paths. The path is ordered by its length to show the shortest paths first.",
            "```cypher\nMATCH (c1:Character)-[r1:INTERACTS45]->(c2:Character)-[r2:INTERACTS45]->(c3:Character)\nWHERE c1.name = 'Stevron-Frey' AND c2.name = 'Walder-Rivers'\nRETURN DISTINCT c3.name\n```"
        ],
        "generated_cyphers": [
            "To list the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book, you can use the following Cypher query:\n\n```cypher\nMATCH (a:Character)-[r:INTERACTS45|INTERACTS|INTERACTS1|INTERACTS3|INTERACTS2]->(b:Character)\nWHERE a.name = 'Stevron-Frey' AND b.name = 'Walder-Rivers'\nRETURN DISTINCT a.name, b.name;\n```\n\nThis query matches all pairs of characters who interacted with each other (`INTERACTS45`, `INTERACTS`, `INTERACTS1`, `INTERACTS3`, or `INTERACTS2`) and filters for the specific characters 'Stevron-Frey' and 'Walder-Rivers'. The `DISTINCT` keyword ensures that each character name is listed only once.",
            "To list the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book, you can use the following Cypher query:\n\n```cypher\nMATCH (a:Character {name: 'Stevron-Frey'})-[:INTERACTS*1..2]->(b:Character {name: 'Walder-Rivers'})\nRETURN DISTINCT a.name, b.name\n```\n\nThis query uses the `MATCH` clause to find paths of length 1 or 2 between 'Stevron-Frey' and 'Walder-Rivers' through the `INTERACTS` relationship. The `DISTINCT` keyword ensures that each character pair is listed only once, even if they are connected in multiple ways.",
            "To find the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book, you can use the following Cypher query:\n\n```cypher\nMATCH (char1:Character)-[r1:INTERACTS*1..3]->(char2:Character)\nWHERE (char1.name = 'Stevron-Frey' AND char2.name = 'Walder-Rivers')\nRETURN DISTINCT char1.name, char2.name;\n```\n\nThis query uses a pattern to match characters who interact with each other through one to three relationships. It ensures that the relationships are between 'Stevron-Frey' and 'Walder-Rivers' and returns the distinct pairs of characters who satisfied this condition.",
            "To list the characters who interacted with both 'Stevron-Frey' and 'Walder-Rivers' in any book, you can use the following Cypher query:\n\n```cypher\nMATCH (c1:Character {name: 'Stevron-Frey'}),\n       (c2:Character {name: 'Walder-Rivers'}),\n       p = shortestPath((c1)-[r:INTERACTS*1..5]-(c2))\nRETURN DISTINCT c1.name AS Character1, c2.name AS Character2, p\nORDER BY LENGTH(p);\n```\n\nThis query uses the `shortestPath` function to find the shortest path between 'Stevron-Frey' and 'Walder-Rivers' across any number of interactions (up to 5 in this case) and returns the distinct characters involved in these paths. The path is ordered by its length to show the shortest paths first.",
            "```cypher\nMATCH (c1:Character)-[r1:INTERACTS45]->(c2:Character)-[r2:INTERACTS45]->(c3:Character)\nWHERE c1.name = 'Stevron-Frey' AND c2.name = 'Walder-Rivers'\nRETURN DISTINCT c3.name\n```"
        ]
    },
    {
        "question": "List the orders placed by customers who have placed orders for products in all categories except 'Grains/Cereals'.",
        "schema": "Node properties:\n- **Product**\n  - `productName`: STRING Example: \"Chai\"\n  - `quantityPerUnit`: STRING Example: \"10 boxes x 20 bags\"\n  - `unitsOnOrder`: INTEGER Min: 0, Max: 100\n  - `supplierID`: STRING Example: \"1\"\n  - `productID`: STRING Example: \"1\"\n  - `discontinued`: BOOLEAN \n  - `categoryID`: STRING Available options: ['1', '2', '7', '6', '8', '4', '3', '5']\n  - `reorderLevel`: INTEGER Min: 0, Max: 30\n  - `unitsInStock`: INTEGER Min: 0, Max: 125\n  - `unitPrice`: FLOAT Min: 2.5, Max: 263.5\n- **Category**\n  - `picture`: STRING Available options: ['0x151C2F00020000000D000E0014002100FFFFFFFF4269746D']\n  - `categoryID`: STRING Available options: ['1', '2', '3', '4', '5', '6', '7', '8']\n  - `description`: STRING Available options: ['Soft drinks, coffees, teas, beers, and ales', 'Sweet and savory sauces, relishes, spreads, and se', 'Desserts, candies, and sweet breads', 'Cheeses', 'Breads, crackers, pasta, and cereal', 'Prepared meats', 'Dried fruit and bean curd', 'Seaweed and fish']\n  - `categoryName`: STRING Available options: ['Beverages', 'Condiments', 'Confections', 'Dairy Products', 'Grains/Cereals', 'Meat/Poultry', 'Produce', 'Seafood']\n- **Supplier**\n  - `companyName`: STRING Example: \"Exotic Liquids\"\n  - `contactName`: STRING Example: \"Charlotte Cooper\"\n  - `homePage`: STRING Available options: ['NULL', '#CAJUN.HTM#', \"Mayumi's (on the World Wide Web)#http://www.micros\", '(03) 444-6588', 'Plutzer (on the World Wide Web)#http://www.microso', '(0544) 60603', '(1) 03.83.00.62', '(02) 555-4873', '(089) 6547667', '38.76.98.58']\n  - `phone`: STRING Example: \"(171) 555-2222\"\n  - `postalCode`: STRING Example: \"EC1 4SD\"\n  - `contactTitle`: STRING Example: \"Purchasing Manager\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"49 Gilbert St.\"\n  - `fax`: STRING Example: \"NULL\"\n  - `supplierID`: STRING Example: \"1\"\n  - `country`: STRING Example: \"UK\"\n  - `city`: STRING Example: \"London\"\n- **Customer**\n  - `fax`: STRING Example: \"030-0076545\"\n  - `companyName`: STRING Example: \"Alfreds Futterkiste\"\n  - `customerID`: STRING Example: \"ALFKI\"\n  - `phone`: STRING Example: \"030-0074321\"\n  - `contactName`: STRING Example: \"Maria Anders\"\n  - `contactTitle`: STRING Example: \"Sales Representative\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"Obere Str. 57\"\n  - `postalCode`: STRING Example: \"12209\"\n  - `country`: STRING Example: \"Germany\"\n  - `city`: STRING Example: \"Berlin\"\n- **Order**\n  - `shipName`: STRING Example: \"Vins et alcools Chevalier\"\n  - `requiredDate`: STRING Example: \"1996-08-01 00:00:00.000\"\n  - `shipCity`: STRING Example: \"Reims\"\n  - `employeeID`: STRING Available options: ['5', '6', '4', '3', '9', '1', '8', '2', '7']\n  - `shipPostalCode`: STRING Example: \"51100\"\n  - `shippedDate`: STRING Example: \"1996-07-16 00:00:00.000\"\n  - `freight`: STRING Example: \"32.38\"\n  - `orderDate`: STRING Example: \"1996-07-04 00:00:00.000\"\n  - `orderID`: STRING Example: \"10248\"\n  - `shipAddress`: STRING Example: \"59 rue de l'Abbaye\"\n  - `customerID`: STRING Example: \"VINET\"\n  - `shipCountry`: STRING Example: \"France\"\n  - `shipVia`: STRING Available options: ['3', '1', '2']\n  - `shipRegion`: STRING Example: \"NULL\"\nRelationship properties:\n- **ORDERS**\n  - `orderID: STRING` Example: \"10248\"\n  - `unitPrice: STRING` Example: \"34.80\"\n  - `productID: STRING` Example: \"72\"\n  - `quantity: INTEGER` Min: 1, Max:  130\n  - `discount: STRING` Example: \"0\"\nThe relationships:\n(:Product)-[:PART_OF]->(:Category)\n(:Supplier)-[:SUPPLIES]->(:Product)\n(:Customer)-[:PURCHASED]->(:Order)\n(:Order)-[:ORDERS]->(:Product)",
        "gold_cypher": "MATCH (c:Category {categoryName: 'Grains/Cereals'}) WITH c.categoryID AS excludedCategory MATCH (p:Product)-[:PART_OF]->(cat:Category) WHERE cat.categoryID <> excludedCategory WITH DISTINCT cat.categoryID AS categoryID WITH collect(categoryID) AS allOtherCategories MATCH (cust:Customer)-[:PURCHASED]->(o:Order)-[:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category) WITH cust, collect(DISTINCT cat.categoryID) AS customerCategories, allOtherCategories WHERE customerCategories = allOtherCategories MATCH (cust)-[:PURCHASED]->(order:Order) RETURN DISTINCT order.orderID",
        "database": "northwind",
        "full_responses": [
            "To answer the question, we need to find customers who have purchased products from all categories except 'Grains/Cereals'. We'll achieve this by:\n\n1. Identifying all categories except 'Grains/Cereals'.\n2. Listing all products that belong to these categories.\n3. Counting the number of orders for each customer who has purchased at least one product from each category.\n4. Filtering customers who have purchased products from all categories except 'Grains/Cereals'.\n\nHere's the Cypher query to accomplish this:\n\n```cypher\nMATCH (c:Customer)\nWHERE NOT c.customerID IN (\n    SELECT DISTINCT t1.customerID\n    FROM (\n        // Step 1: Identify all categories except 'Grains/Cereals'\n        MATCH (t1:Product)-[t2:PART_OF]->(t3:Category)\n        WHERE t3.categoryName <> 'Grains/Cereals'\n        RETURN t1.customerID\n    ) AS t1\n)\nWITH c\nMATCH (c)-[t2:PURCHASED]->(t3:Order)\nWITH c, COUNT(t3) AS orderCount\nMATCH (c)-[t4:PART_OF]->(t5:Category)\nWHERE t5.categoryName <> 'Grains/Cereals'\nWITH c, orderCount, COLLECT(t5.categoryName) AS categories\nWHERE orderCount = size(categories) AND categories HAS 'Grains/Cereals'\nRETURN c\n```\n\n### Explanation:\n1. **Identify Categories Except 'Grains/Cereals':**\n   - We match products that are in categories other than 'Grains/Cereals' and collect the customer IDs.\n\n2. **Filter Customers with Purchased Products from All Categories Except 'Grains/Cereals':**\n   - We match customers who have purchased products from all categories except 'Grains/Cereals' by ensuring that the number of distinct categories they have purchased products from is equal to the total number of categories they have, and 'Grains/Cereals' is not in that list.\n\n3. **Return Customers:**\n   - Finally, we return the customers who meet the criteria.\n\nThis query ensures that we only retrieve customers who have purchased products from all categories except 'Grains/Cereals'.",
            "To answer the question \"List the orders placed by customers who have placed orders for products in all categories except 'Grains/Cereals'\", you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[ord:ORDERS]->(prod:Product)\nWHERE prod.categoryID <> '4'  -- Exclude 'Grains/Cereals'\nWITH c, COUNT(DISTINCT prod.categoryID) AS distinctCategories\nWHERE distinctCategories = (SELECT COUNT(DISTINCT categoryID) FROM Category)\nRETURN c.customerName, o.orderID\nORDER BY c.customerName, o.orderID;\n```\n\nThis query does the following:\n\n1. Matches all customers who have placed orders for products.\n2. Counts the distinct categories for each customer's orders.\n3. Uses a subquery to count the total number of distinct categories across all products.\n4. Filters customers who have placed orders for all categories except 'Grains/Cereals'.\n5. Returns the customer name and order ID for the filtered customers.",
            "```cypher\nMATCH (c:Customer) \nWHERE ALL(cat IN ['1', '2', '7', '6', '8', '4', '3', '5'] WHERE NOT (c)-[:PURCHASED]->()-[r:PART_OF]->(:Category {categoryID: cat})) \nRETURN c.customerID, c.companyName, c.contactName, c.contactTitle, c.address, c.city, c.region, c.postalCode, c.country, c.fax\n```",
            "To answer the question, we need to identify customers who have placed orders for all categories except 'Grains/Cereals'. Here's a step-by-step approach to derive the Cypher query:\n\n1. **Identify products in each category**:\n   - First, we need to find the products in each category, excluding 'Grains/Cereals'.\n\n2. **Identify customers who have placed orders for all these products**:\n   - Then, we need to identify customers who have placed orders for all the products in the identified categories.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (p:Product)-[r:PART_OF]-(c:Category)\nWHERE c.categoryName <> 'Grains/Cereals'\nWITH c.categoryName AS category, collect(p.productID) AS productIDs\nUNION\nMATCH (p:Product)-[r:PART_OF]-(c:Category)\nWHERE c.categoryName = 'Grains/Cereals'\nWITH c.categoryName AS category, collect(p.productID) AS productIDs\n\nWITH category, productIDs\nORDER BY category\nWITH category, productIDs, collect(productID) AS allProductIDs\nWHERE size(productIDs) = size(allProductIDs)\n\nMATCH (c:Customer)-[o:PURCHASED]->(o2:Order)-[or:ORDERS]->(p:Product)\nWHERE p.productID IN allProductIDs\nRETURN c.customerID, c.companyName, c.contactName\nORDER BY c.companyName\n```\n\n### Explanation:\n\n1. **Step 1: Identify products in each category, excluding 'Grains/Cereals'**\n   - We use `MATCH (p:Product)-[r:PART_OF]-(c:Category)` to find relationships between products and categories.\n   - We filter out products that belong to the 'Grains/Cereals' category.\n   - We collect the product IDs for each category.\n\n2. **Step 2: Identify customers who have placed orders for all these products**\n   - We use `UNION` to combine the product IDs from all categories.\n   - We then order by category to ensure we handle categories in the correct order.\n\n3. **Step 3: Identify customers who have placed orders for all these products**\n   - We use `MATCH (c:Customer)-[o:PURCHASED]->(o2:Order)-[or:ORDERS]->(p:Product)` to find customers who have placed orders for products.\n   - We filter customers based on the product IDs collected in the previous step.\n\n4. **Final step: Return the results**\n   - We return the customer IDs, company names, and contact names of customers who have placed orders for all the products in the identified categories.\n\nThis query will list the customers who have placed orders for all products except those in the 'Grains/Cereals' category.",
            "To list the orders placed by customers who have placed orders for products in all categories except 'Grains/Cereals', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[pu:Purchased]->(o:Order)-[ord:ORDERS]->(p:Product)-[cat:PART_OF]->(ca:Category)\nWHERE ca.categoryName <> 'Grains/Cereals'\nWITH c, COUNT(DISTINCT p.categoryID) AS numCategories\nWHERE numCategories = COUNT(DISTINCT ca.categoryID) - 1\nRETURN c.customerID, c.companyName\n```\n\n### Explanation:\n1. **MATCH**: This clause matches the relationships between nodes to retrieve the necessary data.\n   - `(c:Customer)-[pu:Purchased]->(o:Order)-[ord:ORDERS]->(p:Product)-[cat:PART_OF]->(ca:Category)`: This pattern matches customers who have purchased orders, those orders contain products, those products belong to categories, and finally, those categories are not 'Grains/Cereals'.\n\n2. **WHERE ca.categoryName <> 'Grains/Cereals'**: This condition filters out categories that are 'Grains/Cereals'.\n\n3. **WITH c, COUNT(DISTINCT p.categoryID) AS numCategories**: This clause groups the results by customer and counts the distinct categories they have purchased products from.\n\n4. **WHERE numCategories = COUNT(DISTINCT ca.categoryID) - 1**: This condition ensures that the customer has purchased products from all categories except 'Grains/Cereals'.\n\n5. **RETURN c.customerID, c.companyName**: This clause returns the customer ID and company name for those customers who meet the conditions."
        ],
        "generated_cyphers": [
            "To answer the question, we need to find customers who have purchased products from all categories except 'Grains/Cereals'. We'll achieve this by:\n\n1. Identifying all categories except 'Grains/Cereals'.\n2. Listing all products that belong to these categories.\n3. Counting the number of orders for each customer who has purchased at least one product from each category.\n4. Filtering customers who have purchased products from all categories except 'Grains/Cereals'.\n\nHere's the Cypher query to accomplish this:\n\n```cypher\nMATCH (c:Customer)\nWHERE NOT c.customerID IN (\n    SELECT DISTINCT t1.customerID\n    FROM (\n        // Step 1: Identify all categories except 'Grains/Cereals'\n        MATCH (t1:Product)-[t2:PART_OF]->(t3:Category)\n        WHERE t3.categoryName <> 'Grains/Cereals'\n        RETURN t1.customerID\n    ) AS t1\n)\nWITH c\nMATCH (c)-[t2:PURCHASED]->(t3:Order)\nWITH c, COUNT(t3) AS orderCount\nMATCH (c)-[t4:PART_OF]->(t5:Category)\nWHERE t5.categoryName <> 'Grains/Cereals'\nWITH c, orderCount, COLLECT(t5.categoryName) AS categories\nWHERE orderCount = size(categories) AND categories HAS 'Grains/Cereals'\nRETURN c\n```\n\n### Explanation:\n1. **Identify Categories Except 'Grains/Cereals':**\n   - We match products that are in categories other than 'Grains/Cereals' and collect the customer IDs.\n\n2. **Filter Customers with Purchased Products from All Categories Except 'Grains/Cereals':**\n   - We match customers who have purchased products from all categories except 'Grains/Cereals' by ensuring that the number of distinct categories they have purchased products from is equal to the total number of categories they have, and 'Grains/Cereals' is not in that list.\n\n3. **Return Customers:**\n   - Finally, we return the customers who meet the criteria.\n\nThis query ensures that we only retrieve customers who have purchased products from all categories except 'Grains/Cereals'.",
            "To answer the question \"List the orders placed by customers who have placed orders for products in all categories except 'Grains/Cereals'\", you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[p:PURCHASED]->(o:Order)-[ord:ORDERS]->(prod:Product)\nWHERE prod.categoryID <> '4'  -- Exclude 'Grains/Cereals'\nWITH c, COUNT(DISTINCT prod.categoryID) AS distinctCategories\nWHERE distinctCategories = (SELECT COUNT(DISTINCT categoryID) FROM Category)\nRETURN c.customerName, o.orderID\nORDER BY c.customerName, o.orderID;\n```\n\nThis query does the following:\n\n1. Matches all customers who have placed orders for products.\n2. Counts the distinct categories for each customer's orders.\n3. Uses a subquery to count the total number of distinct categories across all products.\n4. Filters customers who have placed orders for all categories except 'Grains/Cereals'.\n5. Returns the customer name and order ID for the filtered customers.",
            "```cypher\nMATCH (c:Customer) \nWHERE ALL(cat IN ['1', '2', '7', '6', '8', '4', '3', '5'] WHERE NOT (c)-[:PURCHASED]->()-[r:PART_OF]->(:Category {categoryID: cat})) \nRETURN c.customerID, c.companyName, c.contactName, c.contactTitle, c.address, c.city, c.region, c.postalCode, c.country, c.fax\n```",
            "To answer the question, we need to identify customers who have placed orders for all categories except 'Grains/Cereals'. Here's a step-by-step approach to derive the Cypher query:\n\n1. **Identify products in each category**:\n   - First, we need to find the products in each category, excluding 'Grains/Cereals'.\n\n2. **Identify customers who have placed orders for all these products**:\n   - Then, we need to identify customers who have placed orders for all the products in the identified categories.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (p:Product)-[r:PART_OF]-(c:Category)\nWHERE c.categoryName <> 'Grains/Cereals'\nWITH c.categoryName AS category, collect(p.productID) AS productIDs\nUNION\nMATCH (p:Product)-[r:PART_OF]-(c:Category)\nWHERE c.categoryName = 'Grains/Cereals'\nWITH c.categoryName AS category, collect(p.productID) AS productIDs\n\nWITH category, productIDs\nORDER BY category\nWITH category, productIDs, collect(productID) AS allProductIDs\nWHERE size(productIDs) = size(allProductIDs)\n\nMATCH (c:Customer)-[o:PURCHASED]->(o2:Order)-[or:ORDERS]->(p:Product)\nWHERE p.productID IN allProductIDs\nRETURN c.customerID, c.companyName, c.contactName\nORDER BY c.companyName\n```\n\n### Explanation:\n\n1. **Step 1: Identify products in each category, excluding 'Grains/Cereals'**\n   - We use `MATCH (p:Product)-[r:PART_OF]-(c:Category)` to find relationships between products and categories.\n   - We filter out products that belong to the 'Grains/Cereals' category.\n   - We collect the product IDs for each category.\n\n2. **Step 2: Identify customers who have placed orders for all these products**\n   - We use `UNION` to combine the product IDs from all categories.\n   - We then order by category to ensure we handle categories in the correct order.\n\n3. **Step 3: Identify customers who have placed orders for all these products**\n   - We use `MATCH (c:Customer)-[o:PURCHASED]->(o2:Order)-[or:ORDERS]->(p:Product)` to find customers who have placed orders for products.\n   - We filter customers based on the product IDs collected in the previous step.\n\n4. **Final step: Return the results**\n   - We return the customer IDs, company names, and contact names of customers who have placed orders for all the products in the identified categories.\n\nThis query will list the customers who have placed orders for all products except those in the 'Grains/Cereals' category.",
            "To list the orders placed by customers who have placed orders for products in all categories except 'Grains/Cereals', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[pu:Purchased]->(o:Order)-[ord:ORDERS]->(p:Product)-[cat:PART_OF]->(ca:Category)\nWHERE ca.categoryName <> 'Grains/Cereals'\nWITH c, COUNT(DISTINCT p.categoryID) AS numCategories\nWHERE numCategories = COUNT(DISTINCT ca.categoryID) - 1\nRETURN c.customerID, c.companyName\n```\n\n### Explanation:\n1. **MATCH**: This clause matches the relationships between nodes to retrieve the necessary data.\n   - `(c:Customer)-[pu:Purchased]->(o:Order)-[ord:ORDERS]->(p:Product)-[cat:PART_OF]->(ca:Category)`: This pattern matches customers who have purchased orders, those orders contain products, those products belong to categories, and finally, those categories are not 'Grains/Cereals'.\n\n2. **WHERE ca.categoryName <> 'Grains/Cereals'**: This condition filters out categories that are 'Grains/Cereals'.\n\n3. **WITH c, COUNT(DISTINCT p.categoryID) AS numCategories**: This clause groups the results by customer and counts the distinct categories they have purchased products from.\n\n4. **WHERE numCategories = COUNT(DISTINCT ca.categoryID) - 1**: This condition ensures that the customer has purchased products from all categories except 'Grains/Cereals'.\n\n5. **RETURN c.customerID, c.companyName**: This clause returns the customer ID and company name for those customers who meet the conditions."
        ]
    },
    {
        "question": "What is the name of the country with the highest concentration of organizations in a specific industry?",
        "schema": "Node properties:\n- **Person**\n  - `name`: STRING Example: \"Julie Spellman Sweet\"\n  - `id`: STRING Example: \"Eaf0bpz6NNoqLVUCqNZPAew\"\n  - `summary`: STRING Example: \"CEO at Accenture\"\n- **Organization**\n  - `revenue`: FLOAT Example: \"1.2E8\"\n  - `motto`: STRING Example: \"\"\n  - `nbrEmployees`: INTEGER Example: \"375\"\n  - `isDissolved`: BOOLEAN \n  - `id`: STRING Example: \"E0ZU8eCc5OaqS1LU9qE3n3w\"\n  - `isPublic`: BOOLEAN \n  - `name`: STRING Example: \"New Energy Group\"\n  - `summary`: STRING Example: \"Software company based in Rome, Metropolitan City \"\n- **IndustryCategory**\n  - `name`: STRING Example: \"Electronic Products Manufacturers\"\n  - `id`: STRING Example: \"EUNd__O4zMNW81lAXNK2GNw\"\n- **City**\n  - `id`: STRING Example: \"EZHWv2xKgN92oYDKSjhJ2gw\"\n  - `summary`: STRING Example: \"City in and county seat of King County, Washington\"\n  - `name`: STRING Example: \"Seattle\"\n- **Country**\n  - `name`: STRING Example: \"United States of America\"\n  - `id`: STRING Example: \"E01d4EK33MmCosgI2KXa4-A\"\n  - `summary`: STRING Example: \"Country in North America\"\n- **Article**\n  - `id`: STRING Example: \"ART176872705964\"\n  - `sentiment`: FLOAT Example: \"0.856\"\n  - `author`: STRING Example: \"David Correa\"\n  - `siteName`: STRING Example: \"MrWeb\"\n  - `summary`: STRING Example: \"Boston and Mumbai-based consumer behavior analyses\"\n  - `date`: DATE_TIME Example: \"2022-03-10T00:00:00Z\"\n  - `title`: STRING Example: \"Funds for Consumer Behavior Specialist Infinite An\"\n- **Chunk**\n  - `text`: STRING Example: \"Boston and Mumbai-based consumer behavior analyses\"\n- **Fewshot**\n  - `Question`: STRING Available options: ['How is Emil Eifrem connected to Michael Hunger? ', 'What are the latest news regarding Google? ', 'Are there any news regarding return to office poli', 'What is Microsoft policy regarding to the return t', 'How many levels of subsidiaries does Blackstone ha', 'How many Telecommunications Companies are from Mal']\n  - `Cypher`: STRING Available options: ['MATCH (p1:Person {{name:\"Emil Eifrem\"}}), (p2:Pers', 'MATCH (o:Organization {{name:\"Google\"}})<-[:MENTIO', 'CALL apoc.ml.openai.embedding([\"Are there any news', 'CALL apoc.ml.openai.embedding([\"What is Microsoft ', 'MATCH p=(o:Organization {name:\"Blackstone\"})-[:HAS', 'MATCH (o:Organization) WHERE EXISTS {(o)-[:HAS_CAT']\n  - `id`: INTEGER Min: 2, Max: 7\nRelationship properties:\n\nThe relationships:\n(:Person)-[:HAS_PARENT]->(:Person)\n(:Person)-[:HAS_CHILD]->(:Person)\n(:Organization)-[:IN_CITY]->(:City)\n(:Organization)-[:HAS_CEO]->(:Person)\n(:Organization)-[:HAS_CATEGORY]->(:IndustryCategory)\n(:Organization)-[:HAS_SUBSIDIARY]->(:Organization)\n(:Organization)-[:HAS_SUPPLIER]->(:Organization)\n(:Organization)-[:HAS_INVESTOR]->(:Organization)\n(:Organization)-[:HAS_INVESTOR]->(:Person)\n(:Organization)-[:HAS_BOARD_MEMBER]->(:Person)\n(:Organization)-[:HAS_COMPETITOR]->(:Organization)\n(:City)-[:IN_COUNTRY]->(:Country)\n(:Article)-[:HAS_CHUNK]->(:Chunk)\n(:Article)-[:MENTIONS]->(:Organization)",
        "gold_cypher": "MATCH (o:Organization)-[:HAS_CATEGORY]->(ic:IndustryCategory) WITH ic.name AS industryName, o, ic MATCH (o)-[:IN_CITY]->(ci:City)-[:IN_COUNTRY]->(co:Country) WITH industryName, co.name AS countryName, count(o) AS orgCount WITH industryName, countryName, collect({count: orgCount, country: countryName}) AS countryCounts, max(orgCount) as maxCount UNWIND countryCounts as countryCount WITH industryName, countryCount WHERE countryCount.count = maxCount RETURN industryName, countryCount.country AS countryName, countryCount.count AS orgCount ORDER BY industryName",
        "database": "companies",
        "full_responses": [
            "To find the country with the highest concentration of organizations in a specific industry, you can use the following Cypher query. This query calculates the number of organizations for each country and then determines the country with the highest count.\n\n```cypher\nMATCH (c:Country)-[r:HAS_CITY]->(ci:City)-[r2:HAS]->(o:Organization)-[r3:HAS_CATEGORY]->(ic:IndustryCategory {name: 'Electronic Products Manufacturers'})\nWITH c, COUNT(o) AS orgCount\nORDER BY orgCount DESC\nLIMIT 1\nRETURN c.name AS CountryName\n```\n\nThis query does the following:\n1. Matches all organizations that belong to the \"Electronic Products Manufacturers\" category.\n2. Counts the number of organizations for each country.\n3. Orders the countries by the count of organizations in descending order.\n4. Limits the result to the top country with the highest count and returns its name.",
            "```cypher\nMATCH (i:IndustryCategory)\nWITH i\nMATCH (o:Organization)-[r:HAS_CATEGORY]->(i)\nWITH i, COUNT(o) AS orgCount\nORDER BY orgCount DESC\nLIMIT 1\nMATCH (c:Country)-[r:IN_COUNTRY]->(o)\nRETURN c.name AS CountryName\n```",
            "To answer the question \"What is the name of the country with the highest concentration of organizations in a specific industry?\", you can use the following Cypher query. This query will identify the industry category and then find the country with the highest number of organizations associated with that industry.\n\n```cypher\nMATCH (i:IndustryCategory)-[r:HAS_ORGANIZATION]->(o:Organization)\nWITH i.name AS industryName, COUNT(o) AS organizationCount\nORDER BY organizationCount DESC\nLIMIT 1\n```\n\nThis query works as follows:\n\n1. **MATCH**: It starts by matching all relationships where an industry category (`i:IndustryCategory`) is associated with an organization (`o:Organization`).\n\n2. **WITH**: It extracts the industry name and counts the number of organizations associated with each industry.\n\n3. **ORDER BY**: It orders the results by the number of organizations in descending order.\n\n4. **LIMIT 1**: It limits the results to the top entry, which corresponds to the industry with the highest concentration of organizations.\n\nThis query will return the name of the country with the highest number of organizations in the industry with the highest concentration of organizations.",
            "To answer the question \"What is the name of the country with the highest concentration of organizations in a specific industry?\", you can use the following Cypher query:\n\n```cypher\nMATCH (i:IndustryCategory)<-[:HAS_CATEGORY]-(o:Organization)<-[r:IN_CITY]-(c:City)<-[cr:IN_COUNTRY]-(co:Country)\nWITH i.name AS Industry, co.name AS Country, count(*) AS OrgCount\nORDER BY OrgCount DESC\nLIMIT 1\n```\n\nThis query does the following:\n1. Matches the relationship between IndustryCategory and Organization.\n2. Matches the relationship between Organization and City.\n3. Matches the relationship between City and Country.\n4. Filters the results to only include the industry of interest.\n5. Counts the number of organizations in each country.\n6. Orders the results by the number of organizations in descending order.\n7. Limits the results to the top country with the highest concentration of organizations.",
            "To find the country with the highest concentration of organizations in a specific industry, you can use the following Cypher query. This query assumes you have a specific industry category and you want to find the country with the most organizations in that category.\n\n```cypher\nMATCH (i:IndustryCategory {name: \"Electronic Products Manufacturers\"})<-[:HAS_CATEGORY]-(o:Organization)\nWITH o, i\nMATCH (o)-[:IN_CITY]->(c:City)\nMATCH (c)-[:IN_COUNTRY]->(nc:Country)\nGROUP BY nc.name\nORDER BY COUNT(nc.name) DESC\nLIMIT 1\nRETURN nc.name AS CountryWithHighestConcentration\n```\n\nThis query works as follows:\n1. It matches organizations that have the specified industry category (`\"Electronic Products Manufacturers\"`).\n2. It then matches these organizations to their corresponding cities.\n3. It further matches these cities to the countries they belong to.\n4. It groups the results by country and counts the number of organizations in each country.\n5. It orders the results by the count in descending order and limits the results to the top country with the highest concentration."
        ],
        "generated_cyphers": [
            "To find the country with the highest concentration of organizations in a specific industry, you can use the following Cypher query. This query calculates the number of organizations for each country and then determines the country with the highest count.\n\n```cypher\nMATCH (c:Country)-[r:HAS_CITY]->(ci:City)-[r2:HAS]->(o:Organization)-[r3:HAS_CATEGORY]->(ic:IndustryCategory {name: 'Electronic Products Manufacturers'})\nWITH c, COUNT(o) AS orgCount\nORDER BY orgCount DESC\nLIMIT 1\nRETURN c.name AS CountryName\n```\n\nThis query does the following:\n1. Matches all organizations that belong to the \"Electronic Products Manufacturers\" category.\n2. Counts the number of organizations for each country.\n3. Orders the countries by the count of organizations in descending order.\n4. Limits the result to the top country with the highest count and returns its name.",
            "```cypher\nMATCH (i:IndustryCategory)\nWITH i\nMATCH (o:Organization)-[r:HAS_CATEGORY]->(i)\nWITH i, COUNT(o) AS orgCount\nORDER BY orgCount DESC\nLIMIT 1\nMATCH (c:Country)-[r:IN_COUNTRY]->(o)\nRETURN c.name AS CountryName\n```",
            "To answer the question \"What is the name of the country with the highest concentration of organizations in a specific industry?\", you can use the following Cypher query. This query will identify the industry category and then find the country with the highest number of organizations associated with that industry.\n\n```cypher\nMATCH (i:IndustryCategory)-[r:HAS_ORGANIZATION]->(o:Organization)\nWITH i.name AS industryName, COUNT(o) AS organizationCount\nORDER BY organizationCount DESC\nLIMIT 1\n```\n\nThis query works as follows:\n\n1. **MATCH**: It starts by matching all relationships where an industry category (`i:IndustryCategory`) is associated with an organization (`o:Organization`).\n\n2. **WITH**: It extracts the industry name and counts the number of organizations associated with each industry.\n\n3. **ORDER BY**: It orders the results by the number of organizations in descending order.\n\n4. **LIMIT 1**: It limits the results to the top entry, which corresponds to the industry with the highest concentration of organizations.\n\nThis query will return the name of the country with the highest number of organizations in the industry with the highest concentration of organizations.",
            "To answer the question \"What is the name of the country with the highest concentration of organizations in a specific industry?\", you can use the following Cypher query:\n\n```cypher\nMATCH (i:IndustryCategory)<-[:HAS_CATEGORY]-(o:Organization)<-[r:IN_CITY]-(c:City)<-[cr:IN_COUNTRY]-(co:Country)\nWITH i.name AS Industry, co.name AS Country, count(*) AS OrgCount\nORDER BY OrgCount DESC\nLIMIT 1\n```\n\nThis query does the following:\n1. Matches the relationship between IndustryCategory and Organization.\n2. Matches the relationship between Organization and City.\n3. Matches the relationship between City and Country.\n4. Filters the results to only include the industry of interest.\n5. Counts the number of organizations in each country.\n6. Orders the results by the number of organizations in descending order.\n7. Limits the results to the top country with the highest concentration of organizations.",
            "To find the country with the highest concentration of organizations in a specific industry, you can use the following Cypher query. This query assumes you have a specific industry category and you want to find the country with the most organizations in that category.\n\n```cypher\nMATCH (i:IndustryCategory {name: \"Electronic Products Manufacturers\"})<-[:HAS_CATEGORY]-(o:Organization)\nWITH o, i\nMATCH (o)-[:IN_CITY]->(c:City)\nMATCH (c)-[:IN_COUNTRY]->(nc:Country)\nGROUP BY nc.name\nORDER BY COUNT(nc.name) DESC\nLIMIT 1\nRETURN nc.name AS CountryWithHighestConcentration\n```\n\nThis query works as follows:\n1. It matches organizations that have the specified industry category (`\"Electronic Products Manufacturers\"`).\n2. It then matches these organizations to their corresponding cities.\n3. It further matches these cities to the countries they belong to.\n4. It groups the results by country and counts the number of organizations in each country.\n5. It orders the results by the count in descending order and limits the results to the top country with the highest concentration."
        ]
    },
    {
        "question": "What are the top 5 orders in terms of quantity for the product 'Chai'?",
        "schema": "Node properties:\n- **Product**\n  - `productName`: STRING Example: \"Chai\"\n  - `quantityPerUnit`: STRING Example: \"10 boxes x 20 bags\"\n  - `unitsOnOrder`: INTEGER Min: 0, Max: 100\n  - `supplierID`: STRING Example: \"1\"\n  - `productID`: STRING Example: \"1\"\n  - `discontinued`: BOOLEAN \n  - `categoryID`: STRING Available options: ['1', '2', '7', '6', '8', '4', '3', '5']\n  - `reorderLevel`: INTEGER Min: 0, Max: 30\n  - `unitsInStock`: INTEGER Min: 0, Max: 125\n  - `unitPrice`: FLOAT Min: 2.5, Max: 263.5\n- **Category**\n  - `picture`: STRING Available options: ['0x151C2F00020000000D000E0014002100FFFFFFFF4269746D']\n  - `categoryID`: STRING Available options: ['1', '2', '3', '4', '5', '6', '7', '8']\n  - `description`: STRING Available options: ['Soft drinks, coffees, teas, beers, and ales', 'Sweet and savory sauces, relishes, spreads, and se', 'Desserts, candies, and sweet breads', 'Cheeses', 'Breads, crackers, pasta, and cereal', 'Prepared meats', 'Dried fruit and bean curd', 'Seaweed and fish']\n  - `categoryName`: STRING Available options: ['Beverages', 'Condiments', 'Confections', 'Dairy Products', 'Grains/Cereals', 'Meat/Poultry', 'Produce', 'Seafood']\n- **Supplier**\n  - `companyName`: STRING Example: \"Exotic Liquids\"\n  - `contactName`: STRING Example: \"Charlotte Cooper\"\n  - `homePage`: STRING Available options: ['NULL', '#CAJUN.HTM#', \"Mayumi's (on the World Wide Web)#http://www.micros\", '(03) 444-6588', 'Plutzer (on the World Wide Web)#http://www.microso', '(0544) 60603', '(1) 03.83.00.62', '(02) 555-4873', '(089) 6547667', '38.76.98.58']\n  - `phone`: STRING Example: \"(171) 555-2222\"\n  - `postalCode`: STRING Example: \"EC1 4SD\"\n  - `contactTitle`: STRING Example: \"Purchasing Manager\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"49 Gilbert St.\"\n  - `fax`: STRING Example: \"NULL\"\n  - `supplierID`: STRING Example: \"1\"\n  - `country`: STRING Example: \"UK\"\n  - `city`: STRING Example: \"London\"\n- **Customer**\n  - `fax`: STRING Example: \"030-0076545\"\n  - `companyName`: STRING Example: \"Alfreds Futterkiste\"\n  - `customerID`: STRING Example: \"ALFKI\"\n  - `phone`: STRING Example: \"030-0074321\"\n  - `contactName`: STRING Example: \"Maria Anders\"\n  - `contactTitle`: STRING Example: \"Sales Representative\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"Obere Str. 57\"\n  - `postalCode`: STRING Example: \"12209\"\n  - `country`: STRING Example: \"Germany\"\n  - `city`: STRING Example: \"Berlin\"\n- **Order**\n  - `shipName`: STRING Example: \"Vins et alcools Chevalier\"\n  - `requiredDate`: STRING Example: \"1996-08-01 00:00:00.000\"\n  - `shipCity`: STRING Example: \"Reims\"\n  - `employeeID`: STRING Available options: ['5', '6', '4', '3', '9', '1', '8', '2', '7']\n  - `shipPostalCode`: STRING Example: \"51100\"\n  - `shippedDate`: STRING Example: \"1996-07-16 00:00:00.000\"\n  - `freight`: STRING Example: \"32.38\"\n  - `orderDate`: STRING Example: \"1996-07-04 00:00:00.000\"\n  - `orderID`: STRING Example: \"10248\"\n  - `shipAddress`: STRING Example: \"59 rue de l'Abbaye\"\n  - `customerID`: STRING Example: \"VINET\"\n  - `shipCountry`: STRING Example: \"France\"\n  - `shipVia`: STRING Available options: ['3', '1', '2']\n  - `shipRegion`: STRING Example: \"NULL\"\nRelationship properties:\n- **ORDERS**\n  - `orderID: STRING` Example: \"10248\"\n  - `unitPrice: STRING` Example: \"34.80\"\n  - `productID: STRING` Example: \"72\"\n  - `quantity: INTEGER` Min: 1, Max:  130\n  - `discount: STRING` Example: \"0\"\nThe relationships:\n(:Product)-[:PART_OF]->(:Category)\n(:Supplier)-[:SUPPLIES]->(:Product)\n(:Customer)-[:PURCHASED]->(:Order)\n(:Order)-[:ORDERS]->(:Product)",
        "gold_cypher": "MATCH (p:Product {productName: 'Chai'})<-[:ORDERS]-(o:Order) RETURN o.orderID AS orderID, o.orderDate AS orderDate, o.shipName AS shipName, o.shipCity AS shipCity, o.shipCountry AS shipCountry, o.shipPostalCode AS shipPostalCode, o.shipAddress AS shipAddress, o.shipVia AS shipVia, o.shipRegion AS shipRegion, o.freight AS freight, o.requiredDate AS requiredDate, o.shippedDate AS shippedDate, o.customerID AS customerID, o.employeeID AS employeeID, o.unitPrice AS unitPrice, o.quantity AS quantity, o.discount AS discount ORDER BY o.quantity DESC LIMIT 5",
        "database": "northwind",
        "full_responses": [
            "To find the top 5 orders in terms of quantity for the product 'Chai', you can use the following Cypher query:\n\n```cypher\nMATCH (p:Product {productName: 'Chai'})\nWITH p\nMATCH (p)-[o:ORDERS]->(o2:Order)\nRETURN o2, o.quantity\nORDER BY o.quantity DESC\nLIMIT 5;\n```\n\nThis query does the following:\n1. Matches the product node with the name 'Chai'.\n2. Finds all orders that include this product.\n3. Returns the orders along with their quantities, ordered by quantity in descending order.\n4. Limits the result to the top 5 orders.",
            "```cypher\nMATCH (p:Product {productName: 'Chai'})<-[:PART_OF]->(c:Category)\nMATCH (o:Order)-[r:ORDERS]->(p)\nORDER BY r.quantity DESC\nLIMIT 5\n```",
            "```cypher\nMATCH (p:Product {productName: 'Chai'})-[:PART_OF]->(c:Category)\nMATCH (p)-[:ORDERS]->(o:Order)-[:PART_OF]->(c2:Category)\nWHERE c.categoryID = c2.categoryID AND p.categoryID = c.categoryID\nMATCH (o)-[ord:ORDERS]->(p)\nWHERE p.productName = 'Chai'\nRETURN o.orderID, SUM(ord.quantity) AS totalQuantity\nORDER BY totalQuantity DESC\nLIMIT 5\n```",
            "To find the top 5 orders in terms of quantity for the product 'Chai', you can use the following Cypher query:\n\n```cypher\nMATCH (p:Product {productName: 'Chai'})-[:PART_OF]->(c:Category)\nMATCH (o:Order)-[:ORDERS]->(p)\nRETURN o.orderID, o.quantity DESC LIMIT 5\n```\n\nThis query does the following:\n1. Matches the product 'Chai' and retrieves the category it belongs to.\n2. Matches the order products and orders, linking them through the `PART_OF` relationship.\n3. Returns the order ID and quantity for the product 'Chai', sorted in descending order by quantity, and limits the result to the top 5 orders.",
            "```cypher\nMATCH (p:Product {productName: 'Chai'})-[:PART_OF]->(c:Category)\nMATCH (o:Order)-[:ORDERS]->(p)\nORDER BY o.quantity DESC\nLIMIT 5\n```"
        ],
        "generated_cyphers": [
            "To find the top 5 orders in terms of quantity for the product 'Chai', you can use the following Cypher query:\n\n```cypher\nMATCH (p:Product {productName: 'Chai'})\nWITH p\nMATCH (p)-[o:ORDERS]->(o2:Order)\nRETURN o2, o.quantity\nORDER BY o.quantity DESC\nLIMIT 5;\n```\n\nThis query does the following:\n1. Matches the product node with the name 'Chai'.\n2. Finds all orders that include this product.\n3. Returns the orders along with their quantities, ordered by quantity in descending order.\n4. Limits the result to the top 5 orders.",
            "```cypher\nMATCH (p:Product {productName: 'Chai'})<-[:PART_OF]->(c:Category)\nMATCH (o:Order)-[r:ORDERS]->(p)\nORDER BY r.quantity DESC\nLIMIT 5\n```",
            "```cypher\nMATCH (p:Product {productName: 'Chai'})-[:PART_OF]->(c:Category)\nMATCH (p)-[:ORDERS]->(o:Order)-[:PART_OF]->(c2:Category)\nWHERE c.categoryID = c2.categoryID AND p.categoryID = c.categoryID\nMATCH (o)-[ord:ORDERS]->(p)\nWHERE p.productName = 'Chai'\nRETURN o.orderID, SUM(ord.quantity) AS totalQuantity\nORDER BY totalQuantity DESC\nLIMIT 5\n```",
            "To find the top 5 orders in terms of quantity for the product 'Chai', you can use the following Cypher query:\n\n```cypher\nMATCH (p:Product {productName: 'Chai'})-[:PART_OF]->(c:Category)\nMATCH (o:Order)-[:ORDERS]->(p)\nRETURN o.orderID, o.quantity DESC LIMIT 5\n```\n\nThis query does the following:\n1. Matches the product 'Chai' and retrieves the category it belongs to.\n2. Matches the order products and orders, linking them through the `PART_OF` relationship.\n3. Returns the order ID and quantity for the product 'Chai', sorted in descending order by quantity, and limits the result to the top 5 orders.",
            "```cypher\nMATCH (p:Product {productName: 'Chai'})-[:PART_OF]->(c:Category)\nMATCH (o:Order)-[:ORDERS]->(p)\nORDER BY o.quantity DESC\nLIMIT 5\n```"
        ]
    },
    {
        "question": "What is the average 'book1BetweennessCentrality' of characters who have interacted with both 'Daenerys-Targaryen' and 'Haldon'?",
        "schema": "Node properties:\n- **Character**\n  - `centrality`: FLOAT Min: 0.0, Max: 1.0\n  - `book45PageRank`: FLOAT Min: 0.15000000000000002, Max: 11.409916274911177\n  - `fastrf_embedding`: LIST Min Size: 10, Max Size: 10\n  - `book1BetweennessCentrality`: FLOAT Min: 0.0, Max: 4638.53495125504\n  - `book1PageRank`: FLOAT Min: 0.15000000000000002, Max: 8.164174336296284\n  - `louvain`: INTEGER Min: 0, Max: 10\n  - `community`: INTEGER Min: 504, Max: 795\n  - `degree`: FLOAT Min: 0.0, Max: 300.0\n  - `name`: STRING Example: \"Addam-Marbrand\"\n  - `pagerank`: FLOAT Min: 0.15000000000000002, Max: 9.473142454730429\nRelationship properties:\n- **INTERACTS**\n  - `weight: INTEGER` Min: 3, Max:  334\n- **INTERACTS1**\n  - `weight: INTEGER` Min: 3, Max:  291\n  - `book: INTEGER` Min: 1, Max:  1\n- **INTERACTS2**\n  - `weight: INTEGER` Min: 3, Max:  92\n  - `book: INTEGER` Min: 2, Max:  2\n- **INTERACTS3**\n  - `weight: INTEGER` Min: 3, Max:  95\n  - `book: INTEGER` Min: 3, Max:  3\n- **INTERACTS45**\n  - `weight: INTEGER` Min: 3, Max:  96\n  - `book: INTEGER` Min: 45, Max:  45\nThe relationships:\n(:Character)-[:INTERACTS45]->(:Character)\n(:Character)-[:INTERACTS]->(:Character)\n(:Character)-[:INTERACTS1]->(:Character)\n(:Character)-[:INTERACTS3]->(:Character)\n(:Character)-[:INTERACTS2]->(:Character)",
        "gold_cypher": "MATCH (daenerys:Character { name: 'Daenerys-Targaryen' })-[:INTERACTS1]->(d_interaction:Character) WITH daenerys, collect(d_interaction) AS daenerys_interactions MATCH (haldon:Character { name: 'Haldon' })-[:INTERACTS1]->(h_interaction:Character) WITH daenerys, daenerys_interactions, haldon, collect(h_interaction) AS haldon_interactions WITH apoc.coll.intersection(daenerys_interactions, haldon_interactions) AS common_characters UNWIND common_characters AS common_character RETURN avg(common_character.book1BetweennessCentrality) AS average_centrality",
        "database": "gameofthrones",
        "full_responses": [
            "To find the average `book1BetweennessCentrality` of characters who have interacted with both 'Daenerys-Targaryen' and 'Haldon', you can use the following Cypher query:\n\n```cypher\nMATCH (a:Character)-[r1:INTERACTS45]->(b:Character)-[r2:INTERACTS45]->(c:Character)\nWHERE a.name = 'Daenerys-Targaryen' AND b.name = 'Haldon'\nRETURN AVG(c.book1BetweennessCentrality) AS averageBook1BetweennessCentrality\n```\n\nThis query works as follows:\n1. It matches three nodes: `a`, `b`, and `c` where `a` and `b` are the characters 'Daenerys-Targaryen' and 'Haldon', respectively.\n2. It finds the paths `(a)-[r1:INTERACTS45]->(b)-[r2:INTERACTS45]->(c)`, which represents characters who have interacted with both 'Daenerys-Targaryen' and 'Haldon'.\n3. It calculates the average `book1BetweennessCentrality` of the `c` nodes in these paths.",
            "```cypher\nMATCH (d:Character {name: 'Daenerys-Targaryen'})-[:INTERACTS45]->(h:Character {name: 'Haldon'})<-[:INTERACTS45]-(c:Character)\nRETURN avg(c.book1BetweennessCentrality)\n```",
            "To answer the question about the average `book1BetweennessCentrality` of characters who have interacted with both 'Daenerys-Targaryen' and 'Haldon', you can use the following Cypher query:\n\n```cypher\nMATCH (c1:Character)-[:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(c2:Character)\nWHERE c1.name = 'Daenerys-Targaryen' AND c2.name = 'Haldon'\nRETURN avg(c1.book1BetweennessCentrality) AS averageBetweenness\n```\n\nThis query matches characters who interact with 'Daenerys-Targaryen' and 'Haldon' through the relationships defined in the schema and calculates the average `book1BetweennessCentrality` for these characters.",
            "```cypher\nMATCH (c1:Character)-[r1:INTERACTS]->(c2:Character)-[r2:INTERACTS]->(c3:Character)\nWHERE c2.name = 'Daenerys-Targaryen' AND c3.name = 'Haldon'\nRETURN AVG(c1.book1BetweennessCentrality)\n```",
            "```cypher\nMATCH (a:Character)-[r:INTERACTS]->(b:Character)\nWHERE a.name = 'Daenerys-Targaryen' AND b.name = 'Haldon'\nWITH a, b, COLLECT([r.book1BetweennessCentrality]) AS betweennessCentrality\nRETURN avg(betweennessCentrality) AS averageBook1BetweennessCentrality\n```"
        ],
        "generated_cyphers": [
            "To find the average `book1BetweennessCentrality` of characters who have interacted with both 'Daenerys-Targaryen' and 'Haldon', you can use the following Cypher query:\n\n```cypher\nMATCH (a:Character)-[r1:INTERACTS45]->(b:Character)-[r2:INTERACTS45]->(c:Character)\nWHERE a.name = 'Daenerys-Targaryen' AND b.name = 'Haldon'\nRETURN AVG(c.book1BetweennessCentrality) AS averageBook1BetweennessCentrality\n```\n\nThis query works as follows:\n1. It matches three nodes: `a`, `b`, and `c` where `a` and `b` are the characters 'Daenerys-Targaryen' and 'Haldon', respectively.\n2. It finds the paths `(a)-[r1:INTERACTS45]->(b)-[r2:INTERACTS45]->(c)`, which represents characters who have interacted with both 'Daenerys-Targaryen' and 'Haldon'.\n3. It calculates the average `book1BetweennessCentrality` of the `c` nodes in these paths.",
            "```cypher\nMATCH (d:Character {name: 'Daenerys-Targaryen'})-[:INTERACTS45]->(h:Character {name: 'Haldon'})<-[:INTERACTS45]-(c:Character)\nRETURN avg(c.book1BetweennessCentrality)\n```",
            "To answer the question about the average `book1BetweennessCentrality` of characters who have interacted with both 'Daenerys-Targaryen' and 'Haldon', you can use the following Cypher query:\n\n```cypher\nMATCH (c1:Character)-[:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(c2:Character)\nWHERE c1.name = 'Daenerys-Targaryen' AND c2.name = 'Haldon'\nRETURN avg(c1.book1BetweennessCentrality) AS averageBetweenness\n```\n\nThis query matches characters who interact with 'Daenerys-Targaryen' and 'Haldon' through the relationships defined in the schema and calculates the average `book1BetweennessCentrality` for these characters.",
            "```cypher\nMATCH (c1:Character)-[r1:INTERACTS]->(c2:Character)-[r2:INTERACTS]->(c3:Character)\nWHERE c2.name = 'Daenerys-Targaryen' AND c3.name = 'Haldon'\nRETURN AVG(c1.book1BetweennessCentrality)\n```",
            "```cypher\nMATCH (a:Character)-[r:INTERACTS]->(b:Character)\nWHERE a.name = 'Daenerys-Targaryen' AND b.name = 'Haldon'\nWITH a, b, COLLECT([r.book1BetweennessCentrality]) AS betweennessCentrality\nRETURN avg(betweennessCentrality) AS averageBook1BetweennessCentrality\n```"
        ]
    },
    {
        "question": "What is the total revenue generated by orders placed by customers located in the same country as the supplier of the most expensive product?",
        "schema": "Node properties:\n- **Product**\n  - `productName`: STRING Example: \"Chai\"\n  - `quantityPerUnit`: STRING Example: \"10 boxes x 20 bags\"\n  - `unitsOnOrder`: INTEGER Min: 0, Max: 100\n  - `supplierID`: STRING Example: \"1\"\n  - `productID`: STRING Example: \"1\"\n  - `discontinued`: BOOLEAN \n  - `categoryID`: STRING Available options: ['1', '2', '7', '6', '8', '4', '3', '5']\n  - `reorderLevel`: INTEGER Min: 0, Max: 30\n  - `unitsInStock`: INTEGER Min: 0, Max: 125\n  - `unitPrice`: FLOAT Min: 2.5, Max: 263.5\n- **Category**\n  - `picture`: STRING Available options: ['0x151C2F00020000000D000E0014002100FFFFFFFF4269746D']\n  - `categoryID`: STRING Available options: ['1', '2', '3', '4', '5', '6', '7', '8']\n  - `description`: STRING Available options: ['Soft drinks, coffees, teas, beers, and ales', 'Sweet and savory sauces, relishes, spreads, and se', 'Desserts, candies, and sweet breads', 'Cheeses', 'Breads, crackers, pasta, and cereal', 'Prepared meats', 'Dried fruit and bean curd', 'Seaweed and fish']\n  - `categoryName`: STRING Available options: ['Beverages', 'Condiments', 'Confections', 'Dairy Products', 'Grains/Cereals', 'Meat/Poultry', 'Produce', 'Seafood']\n- **Supplier**\n  - `companyName`: STRING Example: \"Exotic Liquids\"\n  - `contactName`: STRING Example: \"Charlotte Cooper\"\n  - `homePage`: STRING Available options: ['NULL', '#CAJUN.HTM#', \"Mayumi's (on the World Wide Web)#http://www.micros\", '(03) 444-6588', 'Plutzer (on the World Wide Web)#http://www.microso', '(0544) 60603', '(1) 03.83.00.62', '(02) 555-4873', '(089) 6547667', '38.76.98.58']\n  - `phone`: STRING Example: \"(171) 555-2222\"\n  - `postalCode`: STRING Example: \"EC1 4SD\"\n  - `contactTitle`: STRING Example: \"Purchasing Manager\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"49 Gilbert St.\"\n  - `fax`: STRING Example: \"NULL\"\n  - `supplierID`: STRING Example: \"1\"\n  - `country`: STRING Example: \"UK\"\n  - `city`: STRING Example: \"London\"\n- **Customer**\n  - `fax`: STRING Example: \"030-0076545\"\n  - `companyName`: STRING Example: \"Alfreds Futterkiste\"\n  - `customerID`: STRING Example: \"ALFKI\"\n  - `phone`: STRING Example: \"030-0074321\"\n  - `contactName`: STRING Example: \"Maria Anders\"\n  - `contactTitle`: STRING Example: \"Sales Representative\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"Obere Str. 57\"\n  - `postalCode`: STRING Example: \"12209\"\n  - `country`: STRING Example: \"Germany\"\n  - `city`: STRING Example: \"Berlin\"\n- **Order**\n  - `shipName`: STRING Example: \"Vins et alcools Chevalier\"\n  - `requiredDate`: STRING Example: \"1996-08-01 00:00:00.000\"\n  - `shipCity`: STRING Example: \"Reims\"\n  - `employeeID`: STRING Available options: ['5', '6', '4', '3', '9', '1', '8', '2', '7']\n  - `shipPostalCode`: STRING Example: \"51100\"\n  - `shippedDate`: STRING Example: \"1996-07-16 00:00:00.000\"\n  - `freight`: STRING Example: \"32.38\"\n  - `orderDate`: STRING Example: \"1996-07-04 00:00:00.000\"\n  - `orderID`: STRING Example: \"10248\"\n  - `shipAddress`: STRING Example: \"59 rue de l'Abbaye\"\n  - `customerID`: STRING Example: \"VINET\"\n  - `shipCountry`: STRING Example: \"France\"\n  - `shipVia`: STRING Available options: ['3', '1', '2']\n  - `shipRegion`: STRING Example: \"NULL\"\nRelationship properties:\n- **ORDERS**\n  - `orderID: STRING` Example: \"10248\"\n  - `unitPrice: STRING` Example: \"34.80\"\n  - `productID: STRING` Example: \"72\"\n  - `quantity: INTEGER` Min: 1, Max:  130\n  - `discount: STRING` Example: \"0\"\nThe relationships:\n(:Product)-[:PART_OF]->(:Category)\n(:Supplier)-[:SUPPLIES]->(:Product)\n(:Customer)-[:PURCHASED]->(:Order)\n(:Order)-[:ORDERS]->(:Product)",
        "gold_cypher": "MATCH (mostExpensiveProduct:Product) WITH max(mostExpensiveProduct.unitPrice) AS maxPrice, mostExpensiveProduct MATCH (mostExpensiveProduct)-[:SUPPLIES]->(supplier:Supplier) WITH mostExpensiveProduct, supplier.country AS supplierCountry MATCH (customer:Customer {country: supplierCountry})-[:PURCHASED]->(order:Order) WITH order, customer MATCH (order)-[orders:ORDERS]->(product:Product) WITH order, sum(toFloat(orders.quantity) * toFloat(orders.unitPrice) * (1 - toFloat(orders.discount))) AS orderRevenue RETURN sum(orderRevenue) AS totalRevenue",
        "database": "northwind",
        "full_responses": [
            "To solve this problem, we need to find the most expensive product, determine the country of its supplier, and then calculate the total revenue generated by orders placed by customers from that country. Here's the step-by-step Cypher query to achieve this:\n\n1. **Find the most expensive product**: Use a subquery to find the product with the highest `unitPrice`.\n2. **Get the country of its supplier**: Use the `Supplier` node to find the supplier and then its country.\n3. **Calculate total revenue**: Use the `Customer` and `Order` nodes to find orders placed by customers from the same country and calculate the total revenue.\n\nHere's the Cypher query to perform these steps:\n\n```cypher\nMATCH (p:Product) WHERE p.unitPrice = (MATCH (p)-[r:PART_OF]->(c:Category) RETURN max(p.unitPrice))\nWITH c\nMATCH (s:Supplier)-[supp:SUPPLIES]-(p)\nWHERE c.categoryID = supp.categoryID\nWITH s.country AS supplierCountry\nMATCH (c:Customer)-[ord:PURCHASED]->(o:Order)\nWHERE c.country = supplierCountry\nRETURN sum(o.freight) AS totalRevenue\n```\n\nThis query works as follows:\n\n1. **Find the most expensive product**: \n   - `MATCH (p:Product) WHERE p.unitPrice = (MATCH (p)-[r:PART_OF]->(c:Category) RETURN max(p.unitPrice))`: This part finds the `Product` node with the highest `unitPrice`.\n\n2. **Get the country of its supplier**:\n   - `WITH c`: This assigns the category ID of the most expensive product to the variable `c`.\n   - `MATCH (s:Supplier)-[supp:SUPPLIES]-(p) WHERE c.categoryID = supp.categoryID`: This part finds the supplier of the most expensive product and checks if the category ID matches.\n\n3. **Calculate total revenue**:\n   - `WITH s.country AS supplierCountry`: This assigns the country of the supplier to the variable `supplierCountry`.\n   - `MATCH (c:Customer)-[ord:PURCHASED]->(o:Order) WHERE c.country = supplierCountry`: This part finds all orders placed by customers from the same country as the supplier.\n   - `RETURN sum(o.freight) AS totalRevenue`: This part calculates the total revenue generated by these orders.\n\nThis query will return the total revenue generated by orders placed by customers located in the same country as the supplier of the most expensive product.",
            "To answer the question, we need to identify the most expensive product, determine the supplier of this product, find the customers who bought this product from the same supplier, and then calculate the total revenue generated by these customers.\n\nHere's the Cypher query to achieve this:\n\n```cypher\n// Step 1: Find the most expensive product\nMATCH (p:Product) RETURN p ORDER BY p.unitPrice DESC LIMIT 1 AS mostExpensiveProduct\n\n// Step 2: Find the supplier of the most expensive product\nMATCH (ps:Product)-[r:PART_OF]->(c:Category)-[s:SUPPLIES]->(sp:Supplier) WHERE p = mostExpensiveProduct RETURN sp\n\n// Step 3: Find customers who bought the most expensive product from the same supplier\nMATCH (sp:Supplier)-[:SUPPLIES]->(p:Product)<-[o:ORDERS]-(:Customer) WHERE sp = mostExpensiveProduct RETURN o\n\n// Step 4: Calculate the total revenue generated by these customers\nMATCH (sp:Supplier)-[:SUPPLIES]->(p:Product)<-[o:ORDERS]-(:Customer) WHERE sp = mostExpensiveProduct\nMATCH (o)-[ord:ORDERS]->(p)\nRETURN sum(ord.quantity * ord.unitPrice) AS totalRevenue\n```\n\nThis query first identifies the most expensive product, then finds its supplier. It then finds all customers who purchased this product from the same supplier. Finally, it calculates the total revenue generated by these customers by summing up the product of the quantity and unit price of the orders placed by these customers.",
            "Here's the Cypher query to answer the question:\n\n```cypher\nMATCH (p:Product)-[r:PART_OF]->(c:Category)-[:SUPPLIES]->(s:Supplier)\nWHERE p.unitPrice = MAX(p.unitPrice)\nWITH s\nMATCH (s)-[r:SUPPLIES]->(p)\nMATCH (c)-[:PART_OF]->(p)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUP",
            "```cypher\nMATCH (p:Product)-[:PART_OF]->(c:Category)-[:SUPPLIES]->(s:Supplier)\nWHERE NOT p.discontinued\nWITH s, p ORDER BY p.unitPrice DESC LIMIT 1 AS mostExpensiveProductSupplier\nMATCH (cs:Customer)-[o:PURCHASED]->(o2:Order)\nWHERE s.country = cs.country\nRETURN SUM(o.quantity * o.unitPrice) AS totalRevenue\n```",
            "```cypher\nWITH \n    (\n        MATCH (p:Product)\n        WHERE p.unitPrice = max(p.unitPrice)\n        WITH p, p.supplierID AS supplierId\n        MATCH (s:Supplier {supplierID: supplierId})\n        RETURN s.country AS country\n    ) AS mostExpensiveProductCountry\n\nMATCH (p:Product)\nWITH p, p.supplierID AS supplierId, p.unitPrice AS unitPrice\nMATCH (s:Supplier {supplierID: supplierId})\nWITH p, s, unitPrice\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)\nWHERE c.country = mostExpensiveProductCountry.country\nWITH p, s, unitPrice, c, o\nMATCH (p)-[:PART_OF]->(c2:Category)\nWITH p, s, unitPrice, c, o, c2\nMATCH (c2)-[:SUPPLIES]->(p2)\nWHERE p2.supplierID = s.supplierID\nWITH p, s, unitPrice, c, o, p2\nRETURN p.productName AS ProductName, p.unitPrice * o.quantity AS Revenue\n```"
        ],
        "generated_cyphers": [
            "To solve this problem, we need to find the most expensive product, determine the country of its supplier, and then calculate the total revenue generated by orders placed by customers from that country. Here's the step-by-step Cypher query to achieve this:\n\n1. **Find the most expensive product**: Use a subquery to find the product with the highest `unitPrice`.\n2. **Get the country of its supplier**: Use the `Supplier` node to find the supplier and then its country.\n3. **Calculate total revenue**: Use the `Customer` and `Order` nodes to find orders placed by customers from the same country and calculate the total revenue.\n\nHere's the Cypher query to perform these steps:\n\n```cypher\nMATCH (p:Product) WHERE p.unitPrice = (MATCH (p)-[r:PART_OF]->(c:Category) RETURN max(p.unitPrice))\nWITH c\nMATCH (s:Supplier)-[supp:SUPPLIES]-(p)\nWHERE c.categoryID = supp.categoryID\nWITH s.country AS supplierCountry\nMATCH (c:Customer)-[ord:PURCHASED]->(o:Order)\nWHERE c.country = supplierCountry\nRETURN sum(o.freight) AS totalRevenue\n```\n\nThis query works as follows:\n\n1. **Find the most expensive product**: \n   - `MATCH (p:Product) WHERE p.unitPrice = (MATCH (p)-[r:PART_OF]->(c:Category) RETURN max(p.unitPrice))`: This part finds the `Product` node with the highest `unitPrice`.\n\n2. **Get the country of its supplier**:\n   - `WITH c`: This assigns the category ID of the most expensive product to the variable `c`.\n   - `MATCH (s:Supplier)-[supp:SUPPLIES]-(p) WHERE c.categoryID = supp.categoryID`: This part finds the supplier of the most expensive product and checks if the category ID matches.\n\n3. **Calculate total revenue**:\n   - `WITH s.country AS supplierCountry`: This assigns the country of the supplier to the variable `supplierCountry`.\n   - `MATCH (c:Customer)-[ord:PURCHASED]->(o:Order) WHERE c.country = supplierCountry`: This part finds all orders placed by customers from the same country as the supplier.\n   - `RETURN sum(o.freight) AS totalRevenue`: This part calculates the total revenue generated by these orders.\n\nThis query will return the total revenue generated by orders placed by customers located in the same country as the supplier of the most expensive product.",
            "To answer the question, we need to identify the most expensive product, determine the supplier of this product, find the customers who bought this product from the same supplier, and then calculate the total revenue generated by these customers.\n\nHere's the Cypher query to achieve this:\n\n```cypher\n// Step 1: Find the most expensive product\nMATCH (p:Product) RETURN p ORDER BY p.unitPrice DESC LIMIT 1 AS mostExpensiveProduct\n\n// Step 2: Find the supplier of the most expensive product\nMATCH (ps:Product)-[r:PART_OF]->(c:Category)-[s:SUPPLIES]->(sp:Supplier) WHERE p = mostExpensiveProduct RETURN sp\n\n// Step 3: Find customers who bought the most expensive product from the same supplier\nMATCH (sp:Supplier)-[:SUPPLIES]->(p:Product)<-[o:ORDERS]-(:Customer) WHERE sp = mostExpensiveProduct RETURN o\n\n// Step 4: Calculate the total revenue generated by these customers\nMATCH (sp:Supplier)-[:SUPPLIES]->(p:Product)<-[o:ORDERS]-(:Customer) WHERE sp = mostExpensiveProduct\nMATCH (o)-[ord:ORDERS]->(p)\nRETURN sum(ord.quantity * ord.unitPrice) AS totalRevenue\n```\n\nThis query first identifies the most expensive product, then finds its supplier. It then finds all customers who purchased this product from the same supplier. Finally, it calculates the total revenue generated by these customers by summing up the product of the quantity and unit price of the orders placed by these customers.",
            "Here's the Cypher query to answer the question:\n\n```cypher\nMATCH (p:Product)-[r:PART_OF]->(c:Category)-[:SUPPLIES]->(s:Supplier)\nWHERE p.unitPrice = MAX(p.unitPrice)\nWITH s\nMATCH (s)-[r:SUPPLIES]->(p)\nMATCH (c)-[:PART_OF]->(p)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUPPLIES]->(s)\nMATCH (c)-[:PART_OF]->(:Category)-[:SUP",
            "```cypher\nMATCH (p:Product)-[:PART_OF]->(c:Category)-[:SUPPLIES]->(s:Supplier)\nWHERE NOT p.discontinued\nWITH s, p ORDER BY p.unitPrice DESC LIMIT 1 AS mostExpensiveProductSupplier\nMATCH (cs:Customer)-[o:PURCHASED]->(o2:Order)\nWHERE s.country = cs.country\nRETURN SUM(o.quantity * o.unitPrice) AS totalRevenue\n```",
            "```cypher\nWITH \n    (\n        MATCH (p:Product)\n        WHERE p.unitPrice = max(p.unitPrice)\n        WITH p, p.supplierID AS supplierId\n        MATCH (s:Supplier {supplierID: supplierId})\n        RETURN s.country AS country\n    ) AS mostExpensiveProductCountry\n\nMATCH (p:Product)\nWITH p, p.supplierID AS supplierId, p.unitPrice AS unitPrice\nMATCH (s:Supplier {supplierID: supplierId})\nWITH p, s, unitPrice\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)\nWHERE c.country = mostExpensiveProductCountry.country\nWITH p, s, unitPrice, c, o\nMATCH (p)-[:PART_OF]->(c2:Category)\nWITH p, s, unitPrice, c, o, c2\nMATCH (c2)-[:SUPPLIES]->(p2)\nWHERE p2.supplierID = s.supplierID\nWITH p, s, unitPrice, c, o, p2\nRETURN p.productName AS ProductName, p.unitPrice * o.quantity AS Revenue\n```"
        ]
    },
    {
        "question": "Which customers have placed orders that include products from both the 'Beverages' and 'Confections' categories?",
        "schema": "Node properties:\n- **Product**\n  - `productName`: STRING Example: \"Chai\"\n  - `quantityPerUnit`: STRING Example: \"10 boxes x 20 bags\"\n  - `unitsOnOrder`: INTEGER Min: 0, Max: 100\n  - `supplierID`: STRING Example: \"1\"\n  - `productID`: STRING Example: \"1\"\n  - `discontinued`: BOOLEAN \n  - `categoryID`: STRING Available options: ['1', '2', '7', '6', '8', '4', '3', '5']\n  - `reorderLevel`: INTEGER Min: 0, Max: 30\n  - `unitsInStock`: INTEGER Min: 0, Max: 125\n  - `unitPrice`: FLOAT Min: 2.5, Max: 263.5\n- **Category**\n  - `picture`: STRING Available options: ['0x151C2F00020000000D000E0014002100FFFFFFFF4269746D']\n  - `categoryID`: STRING Available options: ['1', '2', '3', '4', '5', '6', '7', '8']\n  - `description`: STRING Available options: ['Soft drinks, coffees, teas, beers, and ales', 'Sweet and savory sauces, relishes, spreads, and se', 'Desserts, candies, and sweet breads', 'Cheeses', 'Breads, crackers, pasta, and cereal', 'Prepared meats', 'Dried fruit and bean curd', 'Seaweed and fish']\n  - `categoryName`: STRING Available options: ['Beverages', 'Condiments', 'Confections', 'Dairy Products', 'Grains/Cereals', 'Meat/Poultry', 'Produce', 'Seafood']\n- **Supplier**\n  - `companyName`: STRING Example: \"Exotic Liquids\"\n  - `contactName`: STRING Example: \"Charlotte Cooper\"\n  - `homePage`: STRING Available options: ['NULL', '#CAJUN.HTM#', \"Mayumi's (on the World Wide Web)#http://www.micros\", '(03) 444-6588', 'Plutzer (on the World Wide Web)#http://www.microso', '(0544) 60603', '(1) 03.83.00.62', '(02) 555-4873', '(089) 6547667', '38.76.98.58']\n  - `phone`: STRING Example: \"(171) 555-2222\"\n  - `postalCode`: STRING Example: \"EC1 4SD\"\n  - `contactTitle`: STRING Example: \"Purchasing Manager\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"49 Gilbert St.\"\n  - `fax`: STRING Example: \"NULL\"\n  - `supplierID`: STRING Example: \"1\"\n  - `country`: STRING Example: \"UK\"\n  - `city`: STRING Example: \"London\"\n- **Customer**\n  - `fax`: STRING Example: \"030-0076545\"\n  - `companyName`: STRING Example: \"Alfreds Futterkiste\"\n  - `customerID`: STRING Example: \"ALFKI\"\n  - `phone`: STRING Example: \"030-0074321\"\n  - `contactName`: STRING Example: \"Maria Anders\"\n  - `contactTitle`: STRING Example: \"Sales Representative\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"Obere Str. 57\"\n  - `postalCode`: STRING Example: \"12209\"\n  - `country`: STRING Example: \"Germany\"\n  - `city`: STRING Example: \"Berlin\"\n- **Order**\n  - `shipName`: STRING Example: \"Vins et alcools Chevalier\"\n  - `requiredDate`: STRING Example: \"1996-08-01 00:00:00.000\"\n  - `shipCity`: STRING Example: \"Reims\"\n  - `employeeID`: STRING Available options: ['5', '6', '4', '3', '9', '1', '8', '2', '7']\n  - `shipPostalCode`: STRING Example: \"51100\"\n  - `shippedDate`: STRING Example: \"1996-07-16 00:00:00.000\"\n  - `freight`: STRING Example: \"32.38\"\n  - `orderDate`: STRING Example: \"1996-07-04 00:00:00.000\"\n  - `orderID`: STRING Example: \"10248\"\n  - `shipAddress`: STRING Example: \"59 rue de l'Abbaye\"\n  - `customerID`: STRING Example: \"VINET\"\n  - `shipCountry`: STRING Example: \"France\"\n  - `shipVia`: STRING Available options: ['3', '1', '2']\n  - `shipRegion`: STRING Example: \"NULL\"\nRelationship properties:\n- **ORDERS**\n  - `orderID: STRING` Example: \"10248\"\n  - `unitPrice: STRING` Example: \"34.80\"\n  - `productID: STRING` Example: \"72\"\n  - `quantity: INTEGER` Min: 1, Max:  130\n  - `discount: STRING` Example: \"0\"\nThe relationships:\n(:Product)-[:PART_OF]->(:Category)\n(:Supplier)-[:SUPPLIES]->(:Product)\n(:Customer)-[:PURCHASED]->(:Order)\n(:Order)-[:ORDERS]->(:Product)",
        "gold_cypher": "MATCH (bev:Category {categoryName: 'Beverages'})<-[:PART_OF]-(p1:Product)<-[:ORDERS]-(:Order)<-[:PURCHASED]-(c1:Customer) WITH collect(DISTINCT c1.customerID) AS bevCust MATCH (conf:Category {categoryName: 'Confections'})<-[:PART_OF]-(p2:Product)<-[:ORDERS]-(:Order)<-[:PURCHASED]-(c2:Customer) WITH bevCust, collect(DISTINCT c2.customerID) AS confCust WITH apoc.coll.intersection(bevCust, confCust) AS commonCust UNWIND commonCust AS custID MATCH (customer:Customer {customerID: custID}) RETURN DISTINCT customer.customerID, customer.companyName",
        "database": "northwind",
        "full_responses": [
            "To answer this question, you can use the following Cypher query to identify customers who have purchased products from both the 'Beverages' and 'Confections' categories:\n\n```cypher\nMATCH (c:Customer)-[o:ORDERED]->(p:Product)\nWHERE p.categoryID IN ['1', '4']\nWITH c\nMATCH (c)-[o2:ORDERED]->(p2:Product)\nWHERE p2.categoryID IN ['2']\nRETURN DISTINCT c.customerID, c.companyName\n```\n\n### Explanation:\n1. **Initial Match**: The first part of the query matches customers who have placed orders. It uses the `ORDERED` relationship between `Customer` and `Product`.\n\n2. **Filter by Categories**: It filters these orders to include only those that involve products from the 'Beverages' category (`categoryID = '1'`).\n\n3. **Second Match**: The query then matches these customers again to see if they have placed orders that include products from the 'Confections' category (`categoryID = '2'`).\n\n4. **Distinct Customers**: Finally, it returns distinct customer IDs and company names for the customers who meet both criteria.",
            "To answer the question \"Which customers have placed orders that include products from both the 'Beverages' and 'Confections' categories?\", you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)-[r:ORDERS]->(p:Product)\nWHERE p.categoryID IN ['1', '6']  // Categories 'Beverages' and 'Confections'\nWITH c, COUNT(DISTINCT r) AS order_count\nWHERE order_count = 2  // Ensure the customer placed orders with both categories\nRETURN c.customerID, c.companyName, c.contactName, c.contactTitle, c.address, c.city, c.region, c.postalCode, c.country\nORDER BY c.companyName;\n```\n\nThis query performs the following steps:\n1. Matches customers who have placed orders (`Customer` - `PURCHASED` - `Order`).\n2. Extracts the categories of products in the orders (`Product` - `ORDERS` - `Category`).\n3. Filters customers who have placed orders with both 'Beverages' (category ID '1') and 'Confections' (category ID '6').\n4. Counts the number of unique orders for each customer to ensure they have orders from both categories.\n5. Returns customers with exactly 2 orders, indicating they have products from both categories.\n6. Orders the results by company name for readability.",
            "To answer this question, we need to identify customers who have placed orders containing products from both the 'Beverages' and 'Confections' categories. Here's how you can write the Cypher query to achieve this:\n\n```cypher\nMATCH (c:Customer)-[:PURCHASED]->(o:Order)-[:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category)\nWHERE cat.categoryName IN ['Beverages', 'Confections']\nWITH c, COLLECT(p.productName) AS productNames\nWHERE 'Beverages' IN productNames AND 'Confections' IN productNames\nRETURN DISTINCT c.customerID, c.companyName\n```\n\n### Explanation:\n1. **MATCH Clause**: We start by matching customers who have purchased orders.\n2. **WITH Clause**: We then collect all product names for each customer's orders and store them in a list.\n3. **WHERE Clause**: We filter customers who have at least one product from both the 'Beverages' and 'Confections' categories.\n4. **RETURN Clause**: Finally, we return distinct customer IDs and company names who meet the criteria.\n\nThis query will give you the list of customers who have placed orders containing products from both categories.",
            "```cypher\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)-[p:ORDERS]->(prod:Product)\nWHERE prod.categoryID IN ['1', '7']\nRETURN c.customerID, c.companyName\nGROUP BY c.customerID, c.companyName\nHAVING COUNT(DISTINCT prod.categoryID) = 2\nORDER BY c.companyName ASC;\n```",
            "To answer the question \"Which customers have placed orders that include products from both the 'Beverages' and 'Confections' categories?\", we need to find customers who have placed orders containing products from both these categories. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)-[:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category)\nWHERE cat.categoryName IN ['Beverages', 'Confections']\nRETURN c.customerID, c.companyName\nGROUP BY c.customerID, c.companyName\nHAVING COUNT(DISTINCT cat.categoryName) = 2\n```\n\n### Explanation:\n- **MATCH**: We start by matching customers who have placed orders (`c:Customer)-[o:PURCHASED]->(ord:Order)`) and those orders (`ord:Order)-[:ORDERS]->(p:Product)` that are part of a product (`p:Product`).\n- **WHERE**: We filter the products by their category names to ensure they are either 'Beverages' or 'Confections'.\n- **GROUP BY**: We group the results by customer to count the number of unique categories each customer has placed orders for.\n- **HAVING COUNT(DISTINCT cat.categoryName) = 2**: We filter the groups to include only those customers who have placed orders for both 'Beverages' and 'Confections'."
        ],
        "generated_cyphers": [
            "To answer this question, you can use the following Cypher query to identify customers who have purchased products from both the 'Beverages' and 'Confections' categories:\n\n```cypher\nMATCH (c:Customer)-[o:ORDERED]->(p:Product)\nWHERE p.categoryID IN ['1', '4']\nWITH c\nMATCH (c)-[o2:ORDERED]->(p2:Product)\nWHERE p2.categoryID IN ['2']\nRETURN DISTINCT c.customerID, c.companyName\n```\n\n### Explanation:\n1. **Initial Match**: The first part of the query matches customers who have placed orders. It uses the `ORDERED` relationship between `Customer` and `Product`.\n\n2. **Filter by Categories**: It filters these orders to include only those that involve products from the 'Beverages' category (`categoryID = '1'`).\n\n3. **Second Match**: The query then matches these customers again to see if they have placed orders that include products from the 'Confections' category (`categoryID = '2'`).\n\n4. **Distinct Customers**: Finally, it returns distinct customer IDs and company names for the customers who meet both criteria.",
            "To answer the question \"Which customers have placed orders that include products from both the 'Beverages' and 'Confections' categories?\", you can use the following Cypher query:\n\n```cypher\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)-[r:ORDERS]->(p:Product)\nWHERE p.categoryID IN ['1', '6']  // Categories 'Beverages' and 'Confections'\nWITH c, COUNT(DISTINCT r) AS order_count\nWHERE order_count = 2  // Ensure the customer placed orders with both categories\nRETURN c.customerID, c.companyName, c.contactName, c.contactTitle, c.address, c.city, c.region, c.postalCode, c.country\nORDER BY c.companyName;\n```\n\nThis query performs the following steps:\n1. Matches customers who have placed orders (`Customer` - `PURCHASED` - `Order`).\n2. Extracts the categories of products in the orders (`Product` - `ORDERS` - `Category`).\n3. Filters customers who have placed orders with both 'Beverages' (category ID '1') and 'Confections' (category ID '6').\n4. Counts the number of unique orders for each customer to ensure they have orders from both categories.\n5. Returns customers with exactly 2 orders, indicating they have products from both categories.\n6. Orders the results by company name for readability.",
            "To answer this question, we need to identify customers who have placed orders containing products from both the 'Beverages' and 'Confections' categories. Here's how you can write the Cypher query to achieve this:\n\n```cypher\nMATCH (c:Customer)-[:PURCHASED]->(o:Order)-[:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category)\nWHERE cat.categoryName IN ['Beverages', 'Confections']\nWITH c, COLLECT(p.productName) AS productNames\nWHERE 'Beverages' IN productNames AND 'Confections' IN productNames\nRETURN DISTINCT c.customerID, c.companyName\n```\n\n### Explanation:\n1. **MATCH Clause**: We start by matching customers who have purchased orders.\n2. **WITH Clause**: We then collect all product names for each customer's orders and store them in a list.\n3. **WHERE Clause**: We filter customers who have at least one product from both the 'Beverages' and 'Confections' categories.\n4. **RETURN Clause**: Finally, we return distinct customer IDs and company names who meet the criteria.\n\nThis query will give you the list of customers who have placed orders containing products from both categories.",
            "```cypher\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)-[p:ORDERS]->(prod:Product)\nWHERE prod.categoryID IN ['1', '7']\nRETURN c.customerID, c.companyName\nGROUP BY c.customerID, c.companyName\nHAVING COUNT(DISTINCT prod.categoryID) = 2\nORDER BY c.companyName ASC;\n```",
            "To answer the question \"Which customers have placed orders that include products from both the 'Beverages' and 'Confections' categories?\", we need to find customers who have placed orders containing products from both these categories. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (c:Customer)-[o:PURCHASED]->(ord:Order)-[:ORDERS]->(p:Product)-[:PART_OF]->(cat:Category)\nWHERE cat.categoryName IN ['Beverages', 'Confections']\nRETURN c.customerID, c.companyName\nGROUP BY c.customerID, c.companyName\nHAVING COUNT(DISTINCT cat.categoryName) = 2\n```\n\n### Explanation:\n- **MATCH**: We start by matching customers who have placed orders (`c:Customer)-[o:PURCHASED]->(ord:Order)`) and those orders (`ord:Order)-[:ORDERS]->(p:Product)` that are part of a product (`p:Product`).\n- **WHERE**: We filter the products by their category names to ensure they are either 'Beverages' or 'Confections'.\n- **GROUP BY**: We group the results by customer to count the number of unique categories each customer has placed orders for.\n- **HAVING COUNT(DISTINCT cat.categoryName) = 2**: We filter the groups to include only those customers who have placed orders for both 'Beverages' and 'Confections'."
        ]
    },
    {
        "question": "Which organizations are mentioned in articles that also mention organizations in the same industry?",
        "schema": "Node properties:\n- **Person**\n  - `name`: STRING Example: \"Julie Spellman Sweet\"\n  - `id`: STRING Example: \"Eaf0bpz6NNoqLVUCqNZPAew\"\n  - `summary`: STRING Example: \"CEO at Accenture\"\n- **Organization**\n  - `revenue`: FLOAT Example: \"1.2E8\"\n  - `motto`: STRING Example: \"\"\n  - `nbrEmployees`: INTEGER Example: \"375\"\n  - `isDissolved`: BOOLEAN \n  - `id`: STRING Example: \"E0ZU8eCc5OaqS1LU9qE3n3w\"\n  - `isPublic`: BOOLEAN \n  - `name`: STRING Example: \"New Energy Group\"\n  - `summary`: STRING Example: \"Software company based in Rome, Metropolitan City \"\n- **IndustryCategory**\n  - `name`: STRING Example: \"Electronic Products Manufacturers\"\n  - `id`: STRING Example: \"EUNd__O4zMNW81lAXNK2GNw\"\n- **City**\n  - `id`: STRING Example: \"EZHWv2xKgN92oYDKSjhJ2gw\"\n  - `summary`: STRING Example: \"City in and county seat of King County, Washington\"\n  - `name`: STRING Example: \"Seattle\"\n- **Country**\n  - `name`: STRING Example: \"United States of America\"\n  - `id`: STRING Example: \"E01d4EK33MmCosgI2KXa4-A\"\n  - `summary`: STRING Example: \"Country in North America\"\n- **Article**\n  - `id`: STRING Example: \"ART176872705964\"\n  - `sentiment`: FLOAT Example: \"0.856\"\n  - `author`: STRING Example: \"David Correa\"\n  - `siteName`: STRING Example: \"MrWeb\"\n  - `summary`: STRING Example: \"Boston and Mumbai-based consumer behavior analyses\"\n  - `date`: DATE_TIME Example: \"2022-03-10T00:00:00Z\"\n  - `title`: STRING Example: \"Funds for Consumer Behavior Specialist Infinite An\"\n- **Chunk**\n  - `text`: STRING Example: \"Boston and Mumbai-based consumer behavior analyses\"\n- **Fewshot**\n  - `Question`: STRING Available options: ['How is Emil Eifrem connected to Michael Hunger? ', 'What are the latest news regarding Google? ', 'Are there any news regarding return to office poli', 'What is Microsoft policy regarding to the return t', 'How many levels of subsidiaries does Blackstone ha', 'How many Telecommunications Companies are from Mal']\n  - `Cypher`: STRING Available options: ['MATCH (p1:Person {{name:\"Emil Eifrem\"}}), (p2:Pers', 'MATCH (o:Organization {{name:\"Google\"}})<-[:MENTIO', 'CALL apoc.ml.openai.embedding([\"Are there any news', 'CALL apoc.ml.openai.embedding([\"What is Microsoft ', 'MATCH p=(o:Organization {name:\"Blackstone\"})-[:HAS', 'MATCH (o:Organization) WHERE EXISTS {(o)-[:HAS_CAT']\n  - `id`: INTEGER Min: 2, Max: 7\nRelationship properties:\n\nThe relationships:\n(:Person)-[:HAS_PARENT]->(:Person)\n(:Person)-[:HAS_CHILD]->(:Person)\n(:Organization)-[:IN_CITY]->(:City)\n(:Organization)-[:HAS_CEO]->(:Person)\n(:Organization)-[:HAS_CATEGORY]->(:IndustryCategory)\n(:Organization)-[:HAS_SUBSIDIARY]->(:Organization)\n(:Organization)-[:HAS_SUPPLIER]->(:Organization)\n(:Organization)-[:HAS_INVESTOR]->(:Organization)\n(:Organization)-[:HAS_INVESTOR]->(:Person)\n(:Organization)-[:HAS_BOARD_MEMBER]->(:Person)\n(:Organization)-[:HAS_COMPETITOR]->(:Organization)\n(:City)-[:IN_COUNTRY]->(:Country)\n(:Article)-[:HAS_CHUNK]->(:Chunk)\n(:Article)-[:MENTIONS]->(:Organization)",
        "gold_cypher": "MATCH (article:Article)-[:MENTIONS]->(org1:Organization) WITH article, collect(org1) AS mentionedOrganizations, count(DISTINCT org1) AS orgCount WHERE orgCount > 1 UNWIND mentionedOrganizations AS org MATCH (org)-[:HAS_CATEGORY]->(industry:IndustryCategory) WITH article, industry, collect(org) AS orgsByIndustry WITH article, collect(industry) AS industries, collect(orgsByIndustry) as orgsByIndustryPerArticle WHERE size(industries) > 1 UNWIND orgsByIndustryPerArticle AS orgsByIndustry UNWIND orgsByIndustry AS org RETURN DISTINCT org",
        "database": "companies",
        "full_responses": [
            "To answer the question \"Which organizations are mentioned in articles that also mention organizations in the same industry?\", we need to identify articles that mention at least one organization and then find organizations that appear in those articles. We also need to ensure that these organizations belong to the same industry category as the mentioned organizations.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (a:Article)\nWITH a, COLLECT(DISTINCT id(o)) AS org_ids\nWHERE size(org_ids) > 1\nOPTIONAL MATCH (o1:Organization)-[r:HAS_CATEGORY]->(ic:IndustryCategory)\nWHERE ic.name = ic.name  // This is a trick to ensure that the industry category is the same as the one in the article\nWITH a, org_ids, ic.name\nOPTIONAL MATCH (o2:Organization)-[r:HAS_CATEGORY]->(ic:IndustryCategory)\nWHERE ic.name = ic.name\nWITH a, org_ids, ic.name, COLLECT(DISTINCT o1.id) AS orgs1, COLLECT(DISTINCT o2.id) AS orgs2\nRETURN a.title, orgs1, orgs2, ic.name\n```\n\nThis query works as follows:\n\n1. **Identify Articles with Multiple Mentions**:\n   - `MATCH (a:Article)` selects all articles.\n   - `WITH a, COLLECT(DISTINCT id(o)) AS org_ids` collects distinct organization IDs mentioned in each article and stores them in `org_ids`.\n\n2. **Filter Articles with More Than One Organization**:\n   - `WHERE size(org_ids) > 1` filters articles that mention more than one organization.\n\n3. **Find Organizations with the Same Industry Category**:\n   - `OPTIONAL MATCH (o1:Organization)-[r:HAS_CATEGORY]->(ic:IndustryCategory)` finds organizations that have the same industry category as the one in the article.\n   - `WITH a, org_ids, ic.name` passes the article title, organization IDs, and industry category to the next `WITH` clause.\n\n4. **Collect Organizations from Both Articles**:\n   - `OPTIONAL MATCH (o2:Organization)-[r:HAS_CATEGORY]->(ic:IndustryCategory)` finds organizations that have the same industry category as the one in the article.\n   - `WITH a, org_ids, ic.name, COLLECT(DISTINCT o1.id) AS orgs1, COLLECT(DISTINCT o2.id) AS orgs2` collects the organization IDs from both articles into `orgs1` and `orgs2`.\n\n5. **Return Results**:\n   - `RETURN a.title, orgs1, orgs2, ic.name` returns the article title, the organizations mentioned in the first article, the organizations mentioned in the second article, and the industry category.\n\nThis query will provide the titles of articles that mention organizations in the same industry and the organizations themselves.",
            "To answer the question \"Which organizations are mentioned in articles that also mention organizations in the same industry?\", we can use the following Cypher query. This query finds articles that mention at least two different organizations from the same industry.\n\n```cypher\nMATCH (a:Article)-[r:MENTIONS]->(o1:Organization)\nWITH o1\nMATCH (o1)-[r2:HAS_CATEGORY]->(c:IndustryCategory)\nWITH o1, c\nMATCH (o2:Organization)-[r3:MENTIONS]->(a2:Article)\nWHERE id(o1) < id(o2)\nWITH o1, o2, c\nMATCH (o2)-[r4:HAS_CATEGORY]->(c2)\nRETURN DISTINCT o1.name, o2.name, c.name\n```\n\n### Explanation:\n1. **First Match**: We start by matching articles (`Article`) that mention organizations (`Organization`) using the `MENTIONS` relationship.\n2. **First Organization**: For each article, we find the industries it mentions using the `HAS_CATEGORY` relationship.\n3. **Second Match**: We then match another organization (`o2`) that is mentioned in the same article (`a2`) and is also from the same industry (`c2`).\n4. **Distinct Organizations**: We return distinct combinations of organizations and industries that meet the criteria.\n\nThis query will give you a list of organizations that are mentioned in articles that also mention organizations from the same industry.",
            "```cypher\nMATCH (o1:Organization)-[r1:HAS_CATEGORY]->(ic1:IndustryCategory)\nWITH ic1.name AS industry\nMATCH (a:Article)\nWHERE a.MENTIONS[o1.id]\nWITH industry, COLLECT(DISTINCT o1) AS orgs\nMATCH (o2:Organization)-[r2:HAS_CATEGORY]->(ic1)\nWITH industry, orgs, COLLECT(DISTINCT o2) AS orgs2\nRETURN DISTINCT orgs, orgs2\nWHERE orgs2 INTERSECT orgs\n```",
            "```cypher\nMATCH (a:Article)-[r:MENTIONS]->(o:Organization)\nWITH o, a\nWHERE EXISTS (\n  MATCH (o)-[:HAS_CATEGORY]->(c:IndustryCategory)\n  WHERE c.name = r.category\n)\nRETURN o\n```",
            "To answer the question \"Which organizations are mentioned in articles that also mention organizations in the same industry?\", we need to find articles that mention organizations and then filter those articles to find organizations that are mentioned in the same industry. Here's the step-by-step Cypher query to achieve this:\n\n1. **Find articles that mention organizations**: Use the `MENTIONS` relationship to find articles that mention organizations.\n2. **Find organizations mentioned in these articles**: Use the `MENTIONS` relationship to find the organizations mentioned in those articles.\n3. **Filter organizations by industry**: Use the `HAS_CATEGORY` relationship to find organizations that belong to the same industry as the mentioned organizations.\n\nHere's the Cypher query:\n\n```cypher\nMATCH (a:Article)-[r:MENTIONS]->(o:Organization)\nWITH a, o\nMATCH (o)-[r2:HAS_CATEGORY]->(ic:IndustryCategory)\nWITH a, o, ic\nMATCH (a2:Article)-[r3:MENTIONS]->(o2:Organization)\nWITH a, o, o2, ic\nWHERE ic.name = ic2.name\nRETURN DISTINCT o2.name AS OrganizationName\n```\n\n### Explanation:\n- **MATCH (a:Article)-[r:MENTIONS]->(o:Organization)**: This matches articles that mention organizations.\n- **WITH a, o**: This creates a common path for the next steps.\n- **MATCH (o)-[r2:HAS_CATEGORY]->(ic:IndustryCategory)**: This matches the organizations to their industries.\n- **WITH a, o, o2, ic**: This creates a common path for the final steps.\n- **MATCH (a2:Article)-[r3:MENTIONS]->(o2:Organization)**: This matches other articles that mention organizations.\n- **WHERE ic.name = ic2.name**: This filters the organizations to those in the same industry.\n- **RETURN DISTINCT o2.name AS OrganizationName**: This returns the names of the organizations that are mentioned in articles that also mention organizations in the same industry.\n\nThis query will give you the names of organizations that are mentioned in articles that also mention other organizations in the same industry."
        ],
        "generated_cyphers": [
            "To answer the question \"Which organizations are mentioned in articles that also mention organizations in the same industry?\", we need to identify articles that mention at least one organization and then find organizations that appear in those articles. We also need to ensure that these organizations belong to the same industry category as the mentioned organizations.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (a:Article)\nWITH a, COLLECT(DISTINCT id(o)) AS org_ids\nWHERE size(org_ids) > 1\nOPTIONAL MATCH (o1:Organization)-[r:HAS_CATEGORY]->(ic:IndustryCategory)\nWHERE ic.name = ic.name  // This is a trick to ensure that the industry category is the same as the one in the article\nWITH a, org_ids, ic.name\nOPTIONAL MATCH (o2:Organization)-[r:HAS_CATEGORY]->(ic:IndustryCategory)\nWHERE ic.name = ic.name\nWITH a, org_ids, ic.name, COLLECT(DISTINCT o1.id) AS orgs1, COLLECT(DISTINCT o2.id) AS orgs2\nRETURN a.title, orgs1, orgs2, ic.name\n```\n\nThis query works as follows:\n\n1. **Identify Articles with Multiple Mentions**:\n   - `MATCH (a:Article)` selects all articles.\n   - `WITH a, COLLECT(DISTINCT id(o)) AS org_ids` collects distinct organization IDs mentioned in each article and stores them in `org_ids`.\n\n2. **Filter Articles with More Than One Organization**:\n   - `WHERE size(org_ids) > 1` filters articles that mention more than one organization.\n\n3. **Find Organizations with the Same Industry Category**:\n   - `OPTIONAL MATCH (o1:Organization)-[r:HAS_CATEGORY]->(ic:IndustryCategory)` finds organizations that have the same industry category as the one in the article.\n   - `WITH a, org_ids, ic.name` passes the article title, organization IDs, and industry category to the next `WITH` clause.\n\n4. **Collect Organizations from Both Articles**:\n   - `OPTIONAL MATCH (o2:Organization)-[r:HAS_CATEGORY]->(ic:IndustryCategory)` finds organizations that have the same industry category as the one in the article.\n   - `WITH a, org_ids, ic.name, COLLECT(DISTINCT o1.id) AS orgs1, COLLECT(DISTINCT o2.id) AS orgs2` collects the organization IDs from both articles into `orgs1` and `orgs2`.\n\n5. **Return Results**:\n   - `RETURN a.title, orgs1, orgs2, ic.name` returns the article title, the organizations mentioned in the first article, the organizations mentioned in the second article, and the industry category.\n\nThis query will provide the titles of articles that mention organizations in the same industry and the organizations themselves.",
            "To answer the question \"Which organizations are mentioned in articles that also mention organizations in the same industry?\", we can use the following Cypher query. This query finds articles that mention at least two different organizations from the same industry.\n\n```cypher\nMATCH (a:Article)-[r:MENTIONS]->(o1:Organization)\nWITH o1\nMATCH (o1)-[r2:HAS_CATEGORY]->(c:IndustryCategory)\nWITH o1, c\nMATCH (o2:Organization)-[r3:MENTIONS]->(a2:Article)\nWHERE id(o1) < id(o2)\nWITH o1, o2, c\nMATCH (o2)-[r4:HAS_CATEGORY]->(c2)\nRETURN DISTINCT o1.name, o2.name, c.name\n```\n\n### Explanation:\n1. **First Match**: We start by matching articles (`Article`) that mention organizations (`Organization`) using the `MENTIONS` relationship.\n2. **First Organization**: For each article, we find the industries it mentions using the `HAS_CATEGORY` relationship.\n3. **Second Match**: We then match another organization (`o2`) that is mentioned in the same article (`a2`) and is also from the same industry (`c2`).\n4. **Distinct Organizations**: We return distinct combinations of organizations and industries that meet the criteria.\n\nThis query will give you a list of organizations that are mentioned in articles that also mention organizations from the same industry.",
            "```cypher\nMATCH (o1:Organization)-[r1:HAS_CATEGORY]->(ic1:IndustryCategory)\nWITH ic1.name AS industry\nMATCH (a:Article)\nWHERE a.MENTIONS[o1.id]\nWITH industry, COLLECT(DISTINCT o1) AS orgs\nMATCH (o2:Organization)-[r2:HAS_CATEGORY]->(ic1)\nWITH industry, orgs, COLLECT(DISTINCT o2) AS orgs2\nRETURN DISTINCT orgs, orgs2\nWHERE orgs2 INTERSECT orgs\n```",
            "```cypher\nMATCH (a:Article)-[r:MENTIONS]->(o:Organization)\nWITH o, a\nWHERE EXISTS (\n  MATCH (o)-[:HAS_CATEGORY]->(c:IndustryCategory)\n  WHERE c.name = r.category\n)\nRETURN o\n```",
            "To answer the question \"Which organizations are mentioned in articles that also mention organizations in the same industry?\", we need to find articles that mention organizations and then filter those articles to find organizations that are mentioned in the same industry. Here's the step-by-step Cypher query to achieve this:\n\n1. **Find articles that mention organizations**: Use the `MENTIONS` relationship to find articles that mention organizations.\n2. **Find organizations mentioned in these articles**: Use the `MENTIONS` relationship to find the organizations mentioned in those articles.\n3. **Filter organizations by industry**: Use the `HAS_CATEGORY` relationship to find organizations that belong to the same industry as the mentioned organizations.\n\nHere's the Cypher query:\n\n```cypher\nMATCH (a:Article)-[r:MENTIONS]->(o:Organization)\nWITH a, o\nMATCH (o)-[r2:HAS_CATEGORY]->(ic:IndustryCategory)\nWITH a, o, ic\nMATCH (a2:Article)-[r3:MENTIONS]->(o2:Organization)\nWITH a, o, o2, ic\nWHERE ic.name = ic2.name\nRETURN DISTINCT o2.name AS OrganizationName\n```\n\n### Explanation:\n- **MATCH (a:Article)-[r:MENTIONS]->(o:Organization)**: This matches articles that mention organizations.\n- **WITH a, o**: This creates a common path for the next steps.\n- **MATCH (o)-[r2:HAS_CATEGORY]->(ic:IndustryCategory)**: This matches the organizations to their industries.\n- **WITH a, o, o2, ic**: This creates a common path for the final steps.\n- **MATCH (a2:Article)-[r3:MENTIONS]->(o2:Organization)**: This matches other articles that mention organizations.\n- **WHERE ic.name = ic2.name**: This filters the organizations to those in the same industry.\n- **RETURN DISTINCT o2.name AS OrganizationName**: This returns the names of the organizations that are mentioned in articles that also mention organizations in the same industry.\n\nThis query will give you the names of organizations that are mentioned in articles that also mention other organizations in the same industry."
        ]
    },
    {
        "question": "What is the average 'book45PageRank' of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen'?",
        "schema": "Node properties:\n- **Character**\n  - `centrality`: FLOAT Min: 0.0, Max: 1.0\n  - `book45PageRank`: FLOAT Min: 0.15000000000000002, Max: 11.409916274911177\n  - `fastrf_embedding`: LIST Min Size: 10, Max Size: 10\n  - `book1BetweennessCentrality`: FLOAT Min: 0.0, Max: 4638.53495125504\n  - `book1PageRank`: FLOAT Min: 0.15000000000000002, Max: 8.164174336296284\n  - `louvain`: INTEGER Min: 0, Max: 10\n  - `community`: INTEGER Min: 504, Max: 795\n  - `degree`: FLOAT Min: 0.0, Max: 300.0\n  - `name`: STRING Example: \"Addam-Marbrand\"\n  - `pagerank`: FLOAT Min: 0.15000000000000002, Max: 9.473142454730429\nRelationship properties:\n- **INTERACTS**\n  - `weight: INTEGER` Min: 3, Max:  334\n- **INTERACTS1**\n  - `weight: INTEGER` Min: 3, Max:  291\n  - `book: INTEGER` Min: 1, Max:  1\n- **INTERACTS2**\n  - `weight: INTEGER` Min: 3, Max:  92\n  - `book: INTEGER` Min: 2, Max:  2\n- **INTERACTS3**\n  - `weight: INTEGER` Min: 3, Max:  95\n  - `book: INTEGER` Min: 3, Max:  3\n- **INTERACTS45**\n  - `weight: INTEGER` Min: 3, Max:  96\n  - `book: INTEGER` Min: 45, Max:  45\nThe relationships:\n(:Character)-[:INTERACTS45]->(:Character)\n(:Character)-[:INTERACTS]->(:Character)\n(:Character)-[:INTERACTS1]->(:Character)\n(:Character)-[:INTERACTS3]->(:Character)\n(:Character)-[:INTERACTS2]->(:Character)",
        "gold_cypher": "MATCH (aemon:Character { name: 'Aemon-Targaryen-(Maester-Aemon)' })-[:INTERACTS45]->(char1:Character) MATCH (aegon:Character { name: 'Aegon-V-Targaryen' })-[:INTERACTS45]->(char2:Character) WITH collect(DISTINCT char1) AS interacted_with_aemon, collect(DISTINCT char2) AS interacted_with_aegon WITH apoc.coll.intersection(interacted_with_aemon, interacted_with_aegon) AS common_characters UNWIND common_characters AS common_character WITH avg(common_character.book45PageRank) AS average_book45PageRank RETURN average_book45PageRank",
        "database": "gameofthrones",
        "full_responses": [
            "To find the average 'book45PageRank' of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen', you can use the following Cypher query:\n\n```cypher\nMATCH (a:Character)-[i:INTERACTS45]->(b:Character)\nWHERE a.name = 'Aemon-Targaryen-(Maester-Aemon)' AND b.name = 'Aegon-V-Targaryen'\nRETURN avg(b.book45PageRank)\n```\n\nThis query matches characters who interacted with 'Aemon-Targaryen-(Maester-Aemon)' using the `INTERACTS45` relationship and then finds the average 'book45PageRank' of those characters who also interacted with 'Aegon-V-Targaryen'.",
            "```cypher\nMATCH (a:Character)-[r1:INTERACTS45]->(b:Character)-[r2:INTERACTS45]->(c:Character)\nWHERE a.name = 'Aemon-Targaryen-(Maester-Aemon)' AND b.name = 'Aegon-V-Targaryen'\nRETURN AVG(c.book45PageRank)\n```",
            "To find the average 'book45PageRank' of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen', you can use the following Cypher query:\n\n```cypher\nMATCH (a:Aemon-Targaryen-(Maester-Aemon)), (b:Aegon-V-Targaryen)\nWHERE a:Character AND b:Character\nWITH a, b\nMATCH (a)-[r:INTERACTS45]-(c:Character)\nWHERE c:Character\nMATCH (b)-[r:INTERACTS45]-(c:Character)\nRETURN avg(c.book45PageRank) AS average_book45PageRank\n```\n\nThis query does the following:\n1. Matches nodes `a` and `b` representing 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen' respectively.\n2. Checks if both nodes are of type `Character`.\n3. Matches all `INTERACTS45` relationships from `a` and `b` to characters `c`.\n4. Calculates the average of the `book45PageRank` of these characters `c`.",
            "To find the average 'book45PageRank' of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)-[i:INTERACTS45]->(o:Character)\nWHERE c.name = 'Aemon-Targaryen-(Maester-Aemon)' OR o.name = 'Aemon-Targaryen-(Maester-Aemon)'\nAND c.name = 'Aegon-V-Targaryen' OR o.name = 'Aegon-V-Targaryen'\nRETURN avg(c.book45PageRank)\n```\n\nThis query matches characters who interacted with 'Aemon-Targaryen-(Maester-Aemon)' or 'Aegon-V-Targaryen' and calculates the average of their 'book45PageRank'.",
            "To find the average `book45PageRank` of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen', you can use the following Cypher query:\n\n```cypher\nMATCH (char1:Character)-[:INTERACTS45]->(char2:Character)-[:INTERACTS45]->(char3:Character)\nWHERE char1.name = 'Aemon-Targaryen-(Maester-Aemon)' AND char3.name = 'Aegon-V-Targaryen'\nRETURN avg(char2.book45PageRank) AS average_book45PageRank\n```\n\nThis query matches characters who interact with 'Aemon-Targaryen-(Maester-Aemon)' and then finds those who also interact with 'Aegon-V-Targaryen'. It then calculates and returns the average `book45PageRank` of these characters."
        ],
        "generated_cyphers": [
            "To find the average 'book45PageRank' of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen', you can use the following Cypher query:\n\n```cypher\nMATCH (a:Character)-[i:INTERACTS45]->(b:Character)\nWHERE a.name = 'Aemon-Targaryen-(Maester-Aemon)' AND b.name = 'Aegon-V-Targaryen'\nRETURN avg(b.book45PageRank)\n```\n\nThis query matches characters who interacted with 'Aemon-Targaryen-(Maester-Aemon)' using the `INTERACTS45` relationship and then finds the average 'book45PageRank' of those characters who also interacted with 'Aegon-V-Targaryen'.",
            "```cypher\nMATCH (a:Character)-[r1:INTERACTS45]->(b:Character)-[r2:INTERACTS45]->(c:Character)\nWHERE a.name = 'Aemon-Targaryen-(Maester-Aemon)' AND b.name = 'Aegon-V-Targaryen'\nRETURN AVG(c.book45PageRank)\n```",
            "To find the average 'book45PageRank' of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen', you can use the following Cypher query:\n\n```cypher\nMATCH (a:Aemon-Targaryen-(Maester-Aemon)), (b:Aegon-V-Targaryen)\nWHERE a:Character AND b:Character\nWITH a, b\nMATCH (a)-[r:INTERACTS45]-(c:Character)\nWHERE c:Character\nMATCH (b)-[r:INTERACTS45]-(c:Character)\nRETURN avg(c.book45PageRank) AS average_book45PageRank\n```\n\nThis query does the following:\n1. Matches nodes `a` and `b` representing 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen' respectively.\n2. Checks if both nodes are of type `Character`.\n3. Matches all `INTERACTS45` relationships from `a` and `b` to characters `c`.\n4. Calculates the average of the `book45PageRank` of these characters `c`.",
            "To find the average 'book45PageRank' of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen', you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)-[i:INTERACTS45]->(o:Character)\nWHERE c.name = 'Aemon-Targaryen-(Maester-Aemon)' OR o.name = 'Aemon-Targaryen-(Maester-Aemon)'\nAND c.name = 'Aegon-V-Targaryen' OR o.name = 'Aegon-V-Targaryen'\nRETURN avg(c.book45PageRank)\n```\n\nThis query matches characters who interacted with 'Aemon-Targaryen-(Maester-Aemon)' or 'Aegon-V-Targaryen' and calculates the average of their 'book45PageRank'.",
            "To find the average `book45PageRank` of characters who have interacted with both 'Aemon-Targaryen-(Maester-Aemon)' and 'Aegon-V-Targaryen', you can use the following Cypher query:\n\n```cypher\nMATCH (char1:Character)-[:INTERACTS45]->(char2:Character)-[:INTERACTS45]->(char3:Character)\nWHERE char1.name = 'Aemon-Targaryen-(Maester-Aemon)' AND char3.name = 'Aegon-V-Targaryen'\nRETURN avg(char2.book45PageRank) AS average_book45PageRank\n```\n\nThis query matches characters who interact with 'Aemon-Targaryen-(Maester-Aemon)' and then finds those who also interact with 'Aegon-V-Targaryen'. It then calculates and returns the average `book45PageRank` of these characters."
        ]
    },
    {
        "question": "Which business has the highest ratio of 5-star reviews to total reviews?",
        "schema": "Node properties:\n- **Business**\n  - `address`: STRING Available options: ['301 E Main St', '200 W Pine St', '313 N 1st St W', '1151 W Broadway St', '201 E Front St', '723 California Dr', '121 W Broadway St', '716 N San Mateo Dr', '111 E 5th Ave']\n  - `location`: POINT \n  - `city`: STRING Available options: ['Missoula', 'Burlingame', 'San Mateo']\n  - `state`: STRING Available options: ['MT', 'CA']\n  - `businessId`: STRING Available options: ['b5', 'b3', 'b1', 'b2', 'b4', 'b7', 'b6', 'b8', 'b9']\n  - `name`: STRING Available options: ['Missoula Public Library', \"Ninja Mike's\", 'KettleHouse Brewing Co.', 'Imagine Nation Brewing', 'Market on Front', 'Hanabi', 'Zootown Brew', \"Ducky's Car Wash\", 'Neo4j']\n- **User**\n  - `name`: STRING Available options: ['Will', 'Bob', 'Jenny', 'Angie']\n  - `userId`: STRING Available options: ['u1', 'u2', 'u3', 'u4']\n- **Review**\n  - `date`: DATE Min: 2015-08-29, Max: 2018-09-10\n  - `text`: STRING Available options: ['Not a great selection of books, but fortunately th', \"Best breakfast sandwich at the Farmer's Market. Al\", 'Great IPA selection!', \"Awesome full-service car wash. Love Ducky's!\", \"The world's leading graph database HQ!\"]\n  - `stars`: FLOAT Min: 3.0, Max: 5.0\n  - `reviewId`: STRING Example: \"r7\"\n- **Category**\n  - `name`: STRING Example: \"Library\"\nRelationship properties:\n\nThe relationships:\n(:Business)-[:IN_CATEGORY]->(:Category)\n(:User)-[:WROTE]->(:Review)\n(:Review)-[:REVIEWS]->(:Business)",
        "gold_cypher": "MATCH (b:Business)<-[:REVIEWS]-(review:Review) WITH b, count(review) AS totalReviews, count(CASE WHEN review.stars = 5 THEN review ELSE null END) AS fiveStarReviews WITH b, fiveStarReviews /toFloat(totalReviews)  AS ratio WITH max(ratio) AS maxRatio MATCH (b:Business)<-[:REVIEWS]-(review:Review) WITH b, count(review) AS totalReviews, count(CASE WHEN review.stars = 5 THEN review ELSE null END) AS fiveStarReviews, maxRatio WITH b, fiveStarReviews /toFloat(totalReviews)  AS ratio, maxRatio WHERE ratio = maxRatio RETURN b.name",
        "database": "grandstack",
        "full_responses": [
            "To answer the question of which business has the highest ratio of 5-star reviews to total reviews, we need to:\n\n1. Find all 5-star reviews.\n2. Count the total number of reviews for each business.\n3. Calculate the ratio of 5-star reviews to total reviews for each business.\n4. Order the businesses by this ratio and select the one with the highest ratio.\n\nHere is the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWHERE rev.stars = 5\nWITH b, COUNT(*) AS totalReviews\nMATCH (b)-[r:REVIEWS]->(rev:Review)\nRETURN b.name AS BusinessName, totalReviews, COUNT(rev) AS NumberOfFiveStarReviews\nORDER BY NumberOfFiveStarReviews / totalReviews DESC\nLIMIT 1\n```\n\nThis query works as follows:\n- It matches all reviews that are 5-star and counts the total number of reviews for each business.\n- It then matches all reviews for each business again and counts the number of 5-star reviews.\n- It calculates the ratio of 5-star reviews to total reviews for each business.\n- It orders the businesses by this ratio in descending order and limits the result to the first business with the highest ratio.",
            "```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWHERE rv.stars = 5\nWITH b, COUNT(r) AS totalReviews\nORDER BY totalReviews DESC\nLIMIT 1\n```",
            "```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWHERE rv.stars = 5\nRETURN b.name, COUNT(rv) AS total_reviews, COUNT(CASE WHEN rv.stars = 5 THEN 1 ELSE NULL END) AS five_star_reviews\nORDER BY five_star_reviews / total_reviews DESC\nLIMIT 1\n```",
            "To find the business with the highest ratio of 5-star reviews to total reviews, we need to:\n\n1. Count the total number of reviews for each business.\n2. Count the number of 5-star reviews for each business.\n3. Calculate the ratio of 5-star reviews to total reviews.\n4. Order the businesses by this ratio in descending order.\n5. Return the business with the highest ratio.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Business)-[:REVIEWS]->(r:Review)\nWITH b, COUNT(r) AS totalReviews, COUNT(CASE WHEN r.stars = 5 THEN 1 ELSE NULL END) AS fiveStarReviews\nRETURN b.name, totalReviews, fiveStarReviews, totalReviews / fiveStarReviews AS ratio\nORDER BY ratio DESC\nLIMIT 1\n```\n\nThis query does the following:\n- Matches all relationships between `Business` and `Review`.\n- Groups the results by `Business` and counts the total number of reviews and the number of 5-star reviews.\n- Calculates the ratio of 5-star reviews to total reviews.\n- Orders the businesses by this ratio in descending order.\n- Limits the result to the top business with the highest ratio.",
            "To find the business with the highest ratio of 5-star reviews to total reviews, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWHERE rev.stars = 5\nWITH b, COUNT(r) AS totalReviews, COUNT(CASE WHEN rev.stars = 5 THEN 1 ELSE NULL END) AS fiveStarReviews\nRETURN b.name, totalReviews, fiveStarReviews, totalReviews * 1.0 / fiveStarReviews AS ratio\nORDER BY ratio DESC\nLIMIT 1\n```\n\nThis query does the following:\n1. Matches all businesses (`b`) with their associated reviews (`r`).\n2. Filters the reviews to only include those with a rating of 5 stars.\n3. Groups the results by business and counts the total number of reviews and the number of 5-star reviews.\n4. Calculates the ratio of 5-star reviews to total reviews for each business.\n5. Orders the results by the ratio in descending order and limits the output to the top business with the highest ratio."
        ],
        "generated_cyphers": [
            "To answer the question of which business has the highest ratio of 5-star reviews to total reviews, we need to:\n\n1. Find all 5-star reviews.\n2. Count the total number of reviews for each business.\n3. Calculate the ratio of 5-star reviews to total reviews for each business.\n4. Order the businesses by this ratio and select the one with the highest ratio.\n\nHere is the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWHERE rev.stars = 5\nWITH b, COUNT(*) AS totalReviews\nMATCH (b)-[r:REVIEWS]->(rev:Review)\nRETURN b.name AS BusinessName, totalReviews, COUNT(rev) AS NumberOfFiveStarReviews\nORDER BY NumberOfFiveStarReviews / totalReviews DESC\nLIMIT 1\n```\n\nThis query works as follows:\n- It matches all reviews that are 5-star and counts the total number of reviews for each business.\n- It then matches all reviews for each business again and counts the number of 5-star reviews.\n- It calculates the ratio of 5-star reviews to total reviews for each business.\n- It orders the businesses by this ratio in descending order and limits the result to the first business with the highest ratio.",
            "```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWHERE rv.stars = 5\nWITH b, COUNT(r) AS totalReviews\nORDER BY totalReviews DESC\nLIMIT 1\n```",
            "```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWHERE rv.stars = 5\nRETURN b.name, COUNT(rv) AS total_reviews, COUNT(CASE WHEN rv.stars = 5 THEN 1 ELSE NULL END) AS five_star_reviews\nORDER BY five_star_reviews / total_reviews DESC\nLIMIT 1\n```",
            "To find the business with the highest ratio of 5-star reviews to total reviews, we need to:\n\n1. Count the total number of reviews for each business.\n2. Count the number of 5-star reviews for each business.\n3. Calculate the ratio of 5-star reviews to total reviews.\n4. Order the businesses by this ratio in descending order.\n5. Return the business with the highest ratio.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Business)-[:REVIEWS]->(r:Review)\nWITH b, COUNT(r) AS totalReviews, COUNT(CASE WHEN r.stars = 5 THEN 1 ELSE NULL END) AS fiveStarReviews\nRETURN b.name, totalReviews, fiveStarReviews, totalReviews / fiveStarReviews AS ratio\nORDER BY ratio DESC\nLIMIT 1\n```\n\nThis query does the following:\n- Matches all relationships between `Business` and `Review`.\n- Groups the results by `Business` and counts the total number of reviews and the number of 5-star reviews.\n- Calculates the ratio of 5-star reviews to total reviews.\n- Orders the businesses by this ratio in descending order.\n- Limits the result to the top business with the highest ratio.",
            "To find the business with the highest ratio of 5-star reviews to total reviews, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWHERE rev.stars = 5\nWITH b, COUNT(r) AS totalReviews, COUNT(CASE WHEN rev.stars = 5 THEN 1 ELSE NULL END) AS fiveStarReviews\nRETURN b.name, totalReviews, fiveStarReviews, totalReviews * 1.0 / fiveStarReviews AS ratio\nORDER BY ratio DESC\nLIMIT 1\n```\n\nThis query does the following:\n1. Matches all businesses (`b`) with their associated reviews (`r`).\n2. Filters the reviews to only include those with a rating of 5 stars.\n3. Groups the results by business and counts the total number of reviews and the number of 5-star reviews.\n4. Calculates the ratio of 5-star reviews to total reviews for each business.\n5. Orders the results by the ratio in descending order and limits the output to the top business with the highest ratio."
        ]
    },
    {
        "question": "List the businesses and the percentage of their reviews that are positive, negative, and neutral.",
        "schema": "Node properties:\n- **Business**\n  - `address`: STRING Available options: ['301 E Main St', '200 W Pine St', '313 N 1st St W', '1151 W Broadway St', '201 E Front St', '723 California Dr', '121 W Broadway St', '716 N San Mateo Dr', '111 E 5th Ave']\n  - `location`: POINT \n  - `city`: STRING Available options: ['Missoula', 'Burlingame', 'San Mateo']\n  - `state`: STRING Available options: ['MT', 'CA']\n  - `businessId`: STRING Available options: ['b5', 'b3', 'b1', 'b2', 'b4', 'b7', 'b6', 'b8', 'b9']\n  - `name`: STRING Available options: ['Missoula Public Library', \"Ninja Mike's\", 'KettleHouse Brewing Co.', 'Imagine Nation Brewing', 'Market on Front', 'Hanabi', 'Zootown Brew', \"Ducky's Car Wash\", 'Neo4j']\n- **User**\n  - `name`: STRING Available options: ['Will', 'Bob', 'Jenny', 'Angie']\n  - `userId`: STRING Available options: ['u1', 'u2', 'u3', 'u4']\n- **Review**\n  - `date`: DATE Min: 2015-08-29, Max: 2018-09-10\n  - `text`: STRING Available options: ['Not a great selection of books, but fortunately th', \"Best breakfast sandwich at the Farmer's Market. Al\", 'Great IPA selection!', \"Awesome full-service car wash. Love Ducky's!\", \"The world's leading graph database HQ!\"]\n  - `stars`: FLOAT Min: 3.0, Max: 5.0\n  - `reviewId`: STRING Example: \"r7\"\n- **Category**\n  - `name`: STRING Example: \"Library\"\nRelationship properties:\n\nThe relationships:\n(:Business)-[:IN_CATEGORY]->(:Category)\n(:User)-[:WROTE]->(:Review)\n(:Review)-[:REVIEWS]->(:Business)",
        "gold_cypher": "MATCH (b:Business)<-[:REVIEWS]-(r:Review) WITH b, count(r) AS totalReviews,   sum(CASE WHEN r.stars >= 4 THEN 1 ELSE 0 END) AS positiveReviews,  sum(CASE WHEN r.stars = 3 OR r.stars = 2 THEN 1 ELSE 0 END) AS neutralReviews,  sum(CASE WHEN r.stars = 1 THEN 1 ELSE 0 END) AS negativeReviews RETURN b.name AS businessName,        (positiveReviews / totalReviews * 100) AS positivePercentage,        (neutralReviews / totalReviews * 100) AS neutralPercentage,        (negativeReviews / totalReviews * 100) AS negativePercentage",
        "database": "grandstack",
        "full_responses": [
            "To answer the question, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business)-[:IN_CATEGORY]->(c:Category)\nMATCH (b)-[:WROTE]->(r:Review)\nWITH b, r.stars AS stars\nGROUP BY b.name\nORDER BY COUNT(*) DESC\nRETURN b.name AS Business, COUNT(*) AS TotalReviews, COUNT(CASE WHEN stars > 3 THEN 1 ELSE NULL END) AS PositiveReviews, COUNT(CASE WHEN stars < 3 THEN 1 ELSE NULL END) AS NegativeReviews, COUNT(CASE WHEN stars = 3 THEN 1 ELSE NULL END) AS NeutralReviews, \n       (PositiveReviews * 100.0 / COUNT(*)) AS PositivePercentage, \n       (NegativeReviews * 100.0 / COUNT(*)) AS NegativePercentage, \n       (NeutralReviews * 100.0 / COUNT(*)) AS NeutralPercentage\n```\n\nThis query does the following:\n1. Matches businesses and their categories.\n2. Matches users and their reviews.\n3. Groups the results by business name and counts the total reviews.\n4. Counts the number of positive, negative, and neutral reviews.\n5. Calculates the percentage of each review type.\n6. Returns the business name, total reviews, positive, negative, and neutral reviews, along with their respective percentages.",
            "To list the businesses and the percentage of their reviews that are positive, negative, and neutral, you can use the following Cypher query. This query will calculate the number of positive, negative, and neutral reviews for each business and then calculate the percentage of each.\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWITH b, r.stars AS stars\nWHERE r.stars >= 3 AND r.stars <= 5\nRETURN b.name AS BusinessName,\n       COUNT(CASE WHEN stars = 5 THEN r END) / COUNT(r) * 100 AS PositivePercentage,\n       COUNT(CASE WHEN stars = 1 THEN r END) / COUNT(r) * 100 AS NegativePercentage,\n       COUNT(CASE WHEN stars = 3 OR stars = 4 THEN r END) / COUNT(r) * 100 AS NeutralPercentage\nORDER BY PositivePercentage DESC, NegativePercentage DESC, NeutralPercentage DESC;\n```\n\n### Explanation:\n1. **MATCH (b:Business)-[r:REVIEWS]->(rev:Review)**: This pattern matches each business and its reviews.\n2. **WITH b, r.stars AS stars**: This step extracts the business name and the review's stars for each match.\n3. **WHERE r.stars >= 3 AND r.stars <= 5**: This condition ensures that only reviews with a rating between 3 and 5 are considered.\n4. **RETURN b.name AS BusinessName**: This returns the business name.\n5. **COUNT(CASE WHEN stars = 5 THEN r END) / COUNT(r) * 100 AS PositivePercentage**: This calculates the percentage of positive reviews (stars = 5).\n6. **COUNT(CASE WHEN stars = 1 THEN r END) / COUNT(r) * 100 AS NegativePercentage**: This calculates the percentage of negative reviews (stars = 1).\n7. **COUNT(CASE WHEN stars = 3 OR stars = 4 THEN r END) / COUNT(r) * 100 AS NeutralPercentage**: This calculates the percentage of neutral reviews (stars = 3 or 4).\n8. **ORDER BY PositivePercentage DESC, NegativePercentage DESC, NeutralPercentage DESC**: This orders the results by the percentage of positive reviews in descending order, then by negative reviews, and finally by neutral reviews.",
            "```cypher\nMATCH (b:Business)<-[:REVIEWS]-(:Review)-[:REVIEWED_BY]->(u:User)\nWITH b, u, COUNT(CASE WHEN r.stars = 5 THEN 1 ELSE NULL END) AS positiveReviews,\n       COUNT(CASE WHEN r.stars = 1 THEN 1 ELSE NULL END) AS negativeReviews,\n       COUNT(CASE WHEN r.stars BETWEEN 2 AND 4 THEN 1 ELSE NULL END) AS neutralReviews\nRETURN b.name, positiveReviews / (positiveReviews + negativeReviews + neutralReviews) * 100 AS positivePercentage,\n       negativeReviews / (positiveReviews + negativeReviews + neutralReviews) * 100 AS negativePercentage,\n       neutralReviews / (positiveReviews + negativeReviews + neutralReviews) * 100 AS neutralPercentage\nORDER BY positivePercentage DESC, negativePercentage DESC, neutralPercentage DESC;\n```",
            "To answer the question, we need to write a Cypher query that calculates the percentage of positive, negative, and neutral reviews for each business. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWITH b, COUNT(r) AS total_reviews, \n     SUM(CASE WHEN rv.stars < 3 THEN 1 ELSE 0 END) AS negative_reviews, \n     SUM(CASE WHEN rv.stars >= 3 THEN 1 ELSE 0 END) AS positive_reviews\nRETURN b.name AS business_name, \n       total_reviews, \n       negative_reviews, \n       positive_reviews,\n       (positive_reviews * 100 / total_reviews) AS positive_percentage,\n       (negative_reviews * 100 / total_reviews) AS negative_percentage,\n       (CASE WHEN total_reviews = 0 THEN 0 ELSE (total_reviews - negative_reviews - positive_reviews) * 100 / total_reviews END) AS neutral_percentage\nORDER BY positive_percentage DESC;\n```\n\n### Explanation:\n1. **MATCH (b:Business)-[r:REVIEWS]->(rv:Review)**: This pattern matches all businesses and their associated reviews.\n2. **WITH b, COUNT(r) AS total_reviews**: This clause groups the results by business and counts the total number of reviews for each business.\n3. **SUM(CASE WHEN rv.stars < 3 THEN 1 ELSE 0 END) AS negative_reviews**: This calculates the number of negative reviews by summing up the cases where the review stars are less than 3.\n4. **SUM(CASE WHEN rv.stars >= 3 THEN 1 ELSE 0 END) AS positive_reviews**: This calculates the number of positive reviews by summing up the cases where the review stars are 3 or more.\n5. **RETURN b.name AS business_name, total_reviews, negative_reviews, positive_reviews, (positive_reviews * 100 / total_reviews) AS positive_percentage, (negative_reviews * 100 / total_reviews) AS negative_percentage, (CASE WHEN total_reviews = 0 THEN 0 ELSE (total_reviews - negative_reviews - positive_reviews) * 100 / total_reviews END) AS neutral_percentage**: This clause returns the business name, total number of reviews, number of negative reviews, number of positive reviews, and the percentage of positive and negative reviews. The neutral percentage is calculated as the percentage of reviews that are not positive or negative.\n6. **ORDER BY positive_percentage DESC**: This orders the results by the percentage of positive reviews in descending order.\n\nThis query will provide a list of businesses along with the percentage of their reviews that are positive, negative, and neutral.",
            "To answer the question about the percentage of positive, negative, and neutral reviews for each business, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWHERE rv.stars IS NOT NULL\nWITH b, r, rv.stars\nCALL {\n    WITH b, rv.stars as stars\n    UNWIND ['Positive', 'Negative', 'Neutral'] AS sentiment\n    WHERE stars >= 4.0 OR stars <= 2.0\n    RETURN sentiment AS category, COUNT(*) AS count\n}\nRETURN b.name AS BusinessName, category, count, count * 100 / COUNT(*) AS percentage\nORDER BY b.name, category;\n```\n\n### Explanation:\n1. **MATCH and WITH**: \n   - We start by matching all businesses and their reviews.\n   - We then `WITH` the business node, the review node, and the review's `stars` property.\n\n2. **CALL with UNWIND**:\n   - We use a subquery to iterate over the possible categories: 'Positive', 'Negative', and 'Neutral'.\n   - We use `UNWIND` to distribute these categories across the reviews, filtering for reviews with `stars` values that fall within the categories:\n     - 'Positive' for ratings 4.0 and above.\n     - 'Negative' for ratings 2.0 and below.\n     - 'Neutral' for ratings between 3.0 and 4.0 (inclusive).\n\n3. **RETURN**:\n   - We return the business name, the category, the count of reviews in each category, and the percentage of reviews in each category.\n   - The percentage is calculated by multiplying the count by 100 and dividing by the total count of reviews for the business.\n\n4. **ORDER BY**:\n   - Finally, we order the results by business name and category for better readability."
        ],
        "generated_cyphers": [
            "To answer the question, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business)-[:IN_CATEGORY]->(c:Category)\nMATCH (b)-[:WROTE]->(r:Review)\nWITH b, r.stars AS stars\nGROUP BY b.name\nORDER BY COUNT(*) DESC\nRETURN b.name AS Business, COUNT(*) AS TotalReviews, COUNT(CASE WHEN stars > 3 THEN 1 ELSE NULL END) AS PositiveReviews, COUNT(CASE WHEN stars < 3 THEN 1 ELSE NULL END) AS NegativeReviews, COUNT(CASE WHEN stars = 3 THEN 1 ELSE NULL END) AS NeutralReviews, \n       (PositiveReviews * 100.0 / COUNT(*)) AS PositivePercentage, \n       (NegativeReviews * 100.0 / COUNT(*)) AS NegativePercentage, \n       (NeutralReviews * 100.0 / COUNT(*)) AS NeutralPercentage\n```\n\nThis query does the following:\n1. Matches businesses and their categories.\n2. Matches users and their reviews.\n3. Groups the results by business name and counts the total reviews.\n4. Counts the number of positive, negative, and neutral reviews.\n5. Calculates the percentage of each review type.\n6. Returns the business name, total reviews, positive, negative, and neutral reviews, along with their respective percentages.",
            "To list the businesses and the percentage of their reviews that are positive, negative, and neutral, you can use the following Cypher query. This query will calculate the number of positive, negative, and neutral reviews for each business and then calculate the percentage of each.\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWITH b, r.stars AS stars\nWHERE r.stars >= 3 AND r.stars <= 5\nRETURN b.name AS BusinessName,\n       COUNT(CASE WHEN stars = 5 THEN r END) / COUNT(r) * 100 AS PositivePercentage,\n       COUNT(CASE WHEN stars = 1 THEN r END) / COUNT(r) * 100 AS NegativePercentage,\n       COUNT(CASE WHEN stars = 3 OR stars = 4 THEN r END) / COUNT(r) * 100 AS NeutralPercentage\nORDER BY PositivePercentage DESC, NegativePercentage DESC, NeutralPercentage DESC;\n```\n\n### Explanation:\n1. **MATCH (b:Business)-[r:REVIEWS]->(rev:Review)**: This pattern matches each business and its reviews.\n2. **WITH b, r.stars AS stars**: This step extracts the business name and the review's stars for each match.\n3. **WHERE r.stars >= 3 AND r.stars <= 5**: This condition ensures that only reviews with a rating between 3 and 5 are considered.\n4. **RETURN b.name AS BusinessName**: This returns the business name.\n5. **COUNT(CASE WHEN stars = 5 THEN r END) / COUNT(r) * 100 AS PositivePercentage**: This calculates the percentage of positive reviews (stars = 5).\n6. **COUNT(CASE WHEN stars = 1 THEN r END) / COUNT(r) * 100 AS NegativePercentage**: This calculates the percentage of negative reviews (stars = 1).\n7. **COUNT(CASE WHEN stars = 3 OR stars = 4 THEN r END) / COUNT(r) * 100 AS NeutralPercentage**: This calculates the percentage of neutral reviews (stars = 3 or 4).\n8. **ORDER BY PositivePercentage DESC, NegativePercentage DESC, NeutralPercentage DESC**: This orders the results by the percentage of positive reviews in descending order, then by negative reviews, and finally by neutral reviews.",
            "```cypher\nMATCH (b:Business)<-[:REVIEWS]-(:Review)-[:REVIEWED_BY]->(u:User)\nWITH b, u, COUNT(CASE WHEN r.stars = 5 THEN 1 ELSE NULL END) AS positiveReviews,\n       COUNT(CASE WHEN r.stars = 1 THEN 1 ELSE NULL END) AS negativeReviews,\n       COUNT(CASE WHEN r.stars BETWEEN 2 AND 4 THEN 1 ELSE NULL END) AS neutralReviews\nRETURN b.name, positiveReviews / (positiveReviews + negativeReviews + neutralReviews) * 100 AS positivePercentage,\n       negativeReviews / (positiveReviews + negativeReviews + neutralReviews) * 100 AS negativePercentage,\n       neutralReviews / (positiveReviews + negativeReviews + neutralReviews) * 100 AS neutralPercentage\nORDER BY positivePercentage DESC, negativePercentage DESC, neutralPercentage DESC;\n```",
            "To answer the question, we need to write a Cypher query that calculates the percentage of positive, negative, and neutral reviews for each business. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWITH b, COUNT(r) AS total_reviews, \n     SUM(CASE WHEN rv.stars < 3 THEN 1 ELSE 0 END) AS negative_reviews, \n     SUM(CASE WHEN rv.stars >= 3 THEN 1 ELSE 0 END) AS positive_reviews\nRETURN b.name AS business_name, \n       total_reviews, \n       negative_reviews, \n       positive_reviews,\n       (positive_reviews * 100 / total_reviews) AS positive_percentage,\n       (negative_reviews * 100 / total_reviews) AS negative_percentage,\n       (CASE WHEN total_reviews = 0 THEN 0 ELSE (total_reviews - negative_reviews - positive_reviews) * 100 / total_reviews END) AS neutral_percentage\nORDER BY positive_percentage DESC;\n```\n\n### Explanation:\n1. **MATCH (b:Business)-[r:REVIEWS]->(rv:Review)**: This pattern matches all businesses and their associated reviews.\n2. **WITH b, COUNT(r) AS total_reviews**: This clause groups the results by business and counts the total number of reviews for each business.\n3. **SUM(CASE WHEN rv.stars < 3 THEN 1 ELSE 0 END) AS negative_reviews**: This calculates the number of negative reviews by summing up the cases where the review stars are less than 3.\n4. **SUM(CASE WHEN rv.stars >= 3 THEN 1 ELSE 0 END) AS positive_reviews**: This calculates the number of positive reviews by summing up the cases where the review stars are 3 or more.\n5. **RETURN b.name AS business_name, total_reviews, negative_reviews, positive_reviews, (positive_reviews * 100 / total_reviews) AS positive_percentage, (negative_reviews * 100 / total_reviews) AS negative_percentage, (CASE WHEN total_reviews = 0 THEN 0 ELSE (total_reviews - negative_reviews - positive_reviews) * 100 / total_reviews END) AS neutral_percentage**: This clause returns the business name, total number of reviews, number of negative reviews, number of positive reviews, and the percentage of positive and negative reviews. The neutral percentage is calculated as the percentage of reviews that are not positive or negative.\n6. **ORDER BY positive_percentage DESC**: This orders the results by the percentage of positive reviews in descending order.\n\nThis query will provide a list of businesses along with the percentage of their reviews that are positive, negative, and neutral.",
            "To answer the question about the percentage of positive, negative, and neutral reviews for each business, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rv:Review)\nWHERE rv.stars IS NOT NULL\nWITH b, r, rv.stars\nCALL {\n    WITH b, rv.stars as stars\n    UNWIND ['Positive', 'Negative', 'Neutral'] AS sentiment\n    WHERE stars >= 4.0 OR stars <= 2.0\n    RETURN sentiment AS category, COUNT(*) AS count\n}\nRETURN b.name AS BusinessName, category, count, count * 100 / COUNT(*) AS percentage\nORDER BY b.name, category;\n```\n\n### Explanation:\n1. **MATCH and WITH**: \n   - We start by matching all businesses and their reviews.\n   - We then `WITH` the business node, the review node, and the review's `stars` property.\n\n2. **CALL with UNWIND**:\n   - We use a subquery to iterate over the possible categories: 'Positive', 'Negative', and 'Neutral'.\n   - We use `UNWIND` to distribute these categories across the reviews, filtering for reviews with `stars` values that fall within the categories:\n     - 'Positive' for ratings 4.0 and above.\n     - 'Negative' for ratings 2.0 and below.\n     - 'Neutral' for ratings between 3.0 and 4.0 (inclusive).\n\n3. **RETURN**:\n   - We return the business name, the category, the count of reviews in each category, and the percentage of reviews in each category.\n   - The percentage is calculated by multiplying the count by 100 and dividing by the total count of reviews for the business.\n\n4. **ORDER BY**:\n   - Finally, we order the results by business name and category for better readability."
        ]
    },
    {
        "question": "How many characters interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book?",
        "schema": "Node properties:\n- **Character**\n  - `centrality`: FLOAT Min: 0.0, Max: 1.0\n  - `book45PageRank`: FLOAT Min: 0.15000000000000002, Max: 11.409916274911177\n  - `fastrf_embedding`: LIST Min Size: 10, Max Size: 10\n  - `book1BetweennessCentrality`: FLOAT Min: 0.0, Max: 4638.53495125504\n  - `book1PageRank`: FLOAT Min: 0.15000000000000002, Max: 8.164174336296284\n  - `louvain`: INTEGER Min: 0, Max: 10\n  - `community`: INTEGER Min: 504, Max: 795\n  - `degree`: FLOAT Min: 0.0, Max: 300.0\n  - `name`: STRING Example: \"Addam-Marbrand\"\n  - `pagerank`: FLOAT Min: 0.15000000000000002, Max: 9.473142454730429\nRelationship properties:\n- **INTERACTS**\n  - `weight: INTEGER` Min: 3, Max:  334\n- **INTERACTS1**\n  - `weight: INTEGER` Min: 3, Max:  291\n  - `book: INTEGER` Min: 1, Max:  1\n- **INTERACTS2**\n  - `weight: INTEGER` Min: 3, Max:  92\n  - `book: INTEGER` Min: 2, Max:  2\n- **INTERACTS3**\n  - `weight: INTEGER` Min: 3, Max:  95\n  - `book: INTEGER` Min: 3, Max:  3\n- **INTERACTS45**\n  - `weight: INTEGER` Min: 3, Max:  96\n  - `book: INTEGER` Min: 45, Max:  45\nThe relationships:\n(:Character)-[:INTERACTS45]->(:Character)\n(:Character)-[:INTERACTS]->(:Character)\n(:Character)-[:INTERACTS1]->(:Character)\n(:Character)-[:INTERACTS3]->(:Character)\n(:Character)-[:INTERACTS2]->(:Character)",
        "gold_cypher": "MATCH (aegon:Character {name: \"Aegon-V-Targaryen\"})-[:INTERACTS|:INTERACTS1|:INTERACTS2|:INTERACTS3|:INTERACTS45]-(char1:Character) WITH aegon, collect(char1) AS aegon_interacted_characters MATCH (cersei:Character {name: \"Cersei-Lannister\"})-[:INTERACTS|:INTERACTS1|:INTERACTS2|:INTERACTS3|:INTERACTS45]-(char2:Character) WITH aegon_interacted_characters, collect(char2) AS cersei_interacted_characters RETURN size(apoc.coll.intersection(aegon_interacted_characters, cersei_interacted_characters)) AS count",
        "database": "gameofthrones",
        "full_responses": [
            "To answer this question, we need to find characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book. This involves identifying the common characters between the two sets of nodes and then checking if they have any interactions.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (a:Character)-[r:INTERACTS*1..3]-(b:Character)\nWHERE a.name = 'Aegon-V-Targaryen' AND b.name = 'Cersei-Lannister'\nRETURN a, b\n```\n\nThis query uses a recursive relationship pattern (`-[r:INTERACTS*1..3]`) to find characters who are directly or indirectly interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\". The `LIMIT 1` clause can be added to return only one pair of characters if you are only interested in the first interaction found, but in this case, it returns all pairs that meet the criteria.",
            "To answer the question, we need to find characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book. We will use the `MATCH` clause to find characters that have relationships with both characters, and then count them using the `COUNT` function.\n\nHere is the Cypher query:\n\n```cypher\nMATCH (char1:Character)-[rel1:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(char2:Character)\nWHERE char1.name = 'Aegon-V-Targaryen' AND char2.name = 'Cersei-Lannister'\nRETURN count(char1)\n```\n\nThis query will return the number of characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book.",
            "To answer this question, we need to find characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book. Here's the Cypher query to achieve that:\n\n```cypher\nMATCH (a:Character {name: 'Aegon-V-Targaryen'})-[:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(c:Character {name: 'Cersei-Lannister'})\nRETURN count(DISTINCT c)\n```\n\nThis query does the following:\n- `MATCH (a:Character {name: 'Aegon-V-Targaryen'})-[:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(c:Character {name: 'Cersei-Lannister'})`: Matches any character named \"Aegon-V-Targaryen\" and any character named \"Cersei-Lannister\" who are connected by the specified relationships.\n- `RETURN count(DISTINCT c)`: Counts the number of distinct characters who satisfy the condition and returns the count.",
            "```cypher\nMATCH (a:Character)-[:INTERACTS45]->(b:Character)\nWHERE a.name = 'Aegon-V-Targaryen' AND b.name = 'Cersei-Lannister'\nRETURN count(DISTINCT a.name) AS interaction_count\n```",
            "To answer the question, we need to find characters who interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book. Here's how you can write the Cypher query to achieve this:\n\n```cypher\nMATCH (a:Character {name: 'Aegon-V-Targaryen'})-[:INTERACTS45]->(b:Character)-[:INTERACTS45]->(c:Character)\nWHERE a <> b AND b <> c AND c <> a\nRETURN count(c) AS count_of_characters\n```\n\nThis query does the following:\n- `MATCH (a:Character {name: 'Aegon-V-Targaryen'})`: Matches the node for \"Aegon-V-Targaryen\".\n- `-[:INTERACTS45]->(b:Character)`: Follows the `INTERACTS45` relationship to find characters that interacted with \"Aegon-V-Targaryen\".\n- `-[:INTERACTS45]->(c:Character)`: Follows the `INTERACTS45` relationship again to find characters that interacted with the characters found in the first step.\n- `WHERE a <> b AND b <> c AND c <> a`: Ensures that the characters are not the same person.\n- `RETURN count(c) AS count_of_characters`: Returns the count of unique characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\"."
        ],
        "generated_cyphers": [
            "To answer this question, we need to find characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book. This involves identifying the common characters between the two sets of nodes and then checking if they have any interactions.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (a:Character)-[r:INTERACTS*1..3]-(b:Character)\nWHERE a.name = 'Aegon-V-Targaryen' AND b.name = 'Cersei-Lannister'\nRETURN a, b\n```\n\nThis query uses a recursive relationship pattern (`-[r:INTERACTS*1..3]`) to find characters who are directly or indirectly interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\". The `LIMIT 1` clause can be added to return only one pair of characters if you are only interested in the first interaction found, but in this case, it returns all pairs that meet the criteria.",
            "To answer the question, we need to find characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book. We will use the `MATCH` clause to find characters that have relationships with both characters, and then count them using the `COUNT` function.\n\nHere is the Cypher query:\n\n```cypher\nMATCH (char1:Character)-[rel1:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(char2:Character)\nWHERE char1.name = 'Aegon-V-Targaryen' AND char2.name = 'Cersei-Lannister'\nRETURN count(char1)\n```\n\nThis query will return the number of characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book.",
            "To answer this question, we need to find characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book. Here's the Cypher query to achieve that:\n\n```cypher\nMATCH (a:Character {name: 'Aegon-V-Targaryen'})-[:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(c:Character {name: 'Cersei-Lannister'})\nRETURN count(DISTINCT c)\n```\n\nThis query does the following:\n- `MATCH (a:Character {name: 'Aegon-V-Targaryen'})-[:INTERACTS|INTERACTS1|INTERACTS2|INTERACTS3|INTERACTS45]->(c:Character {name: 'Cersei-Lannister'})`: Matches any character named \"Aegon-V-Targaryen\" and any character named \"Cersei-Lannister\" who are connected by the specified relationships.\n- `RETURN count(DISTINCT c)`: Counts the number of distinct characters who satisfy the condition and returns the count.",
            "```cypher\nMATCH (a:Character)-[:INTERACTS45]->(b:Character)\nWHERE a.name = 'Aegon-V-Targaryen' AND b.name = 'Cersei-Lannister'\nRETURN count(DISTINCT a.name) AS interaction_count\n```",
            "To answer the question, we need to find characters who interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\" in any book. Here's how you can write the Cypher query to achieve this:\n\n```cypher\nMATCH (a:Character {name: 'Aegon-V-Targaryen'})-[:INTERACTS45]->(b:Character)-[:INTERACTS45]->(c:Character)\nWHERE a <> b AND b <> c AND c <> a\nRETURN count(c) AS count_of_characters\n```\n\nThis query does the following:\n- `MATCH (a:Character {name: 'Aegon-V-Targaryen'})`: Matches the node for \"Aegon-V-Targaryen\".\n- `-[:INTERACTS45]->(b:Character)`: Follows the `INTERACTS45` relationship to find characters that interacted with \"Aegon-V-Targaryen\".\n- `-[:INTERACTS45]->(c:Character)`: Follows the `INTERACTS45` relationship again to find characters that interacted with the characters found in the first step.\n- `WHERE a <> b AND b <> c AND c <> a`: Ensures that the characters are not the same person.\n- `RETURN count(c) AS count_of_characters`: Returns the count of unique characters that interacted with both \"Aegon-V-Targaryen\" and \"Cersei-Lannister\"."
        ]
    },
    {
        "question": "Which person has produced the most movies?",
        "schema": "Node properties:\n- **Movie**\n  - `title`: STRING Example: \"The Matrix\"\n  - `votes`: INTEGER Min: 1, Max: 5259\n  - `tagline`: STRING Example: \"Welcome to the Real World\"\n  - `released`: INTEGER Min: 1975, Max: 2012\n- **Person**\n  - `born`: INTEGER Min: 1929, Max: 1996\n  - `name`: STRING Example: \"Keanu Reeves\"\nRelationship properties:\n- **ACTED_IN**\n  - `roles: LIST` Min Size: 1, Max Size: 6\n- **REVIEWED**\n  - `summary: STRING` Available options: ['Pretty funny at times', 'A solid romp', 'Silly, but fun', 'You had me at Jerry', 'An amazing journey', 'Slapstick redeemed only by the Robin Williams and ', 'Dark, but compelling', 'The coolest football movie ever', 'Fun, but a little far fetched']\n  - `rating: INTEGER` Min: 45, Max:  100\nThe relationships:\n(:Person)-[:ACTED_IN]->(:Movie)\n(:Person)-[:DIRECTED]->(:Movie)\n(:Person)-[:PRODUCED]->(:Movie)\n(:Person)-[:WROTE]->(:Movie)\n(:Person)-[:FOLLOWS]->(:Person)\n(:Person)-[:REVIEWED]->(:Movie)",
        "gold_cypher": "MATCH (p:Person)-[:PRODUCED]->(m:Movie) RETURN p.name AS producer, count(m) AS movie_count ORDER BY movie_count DESC LIMIT 1",
        "database": "movies",
        "full_responses": [
            "To find which person has produced the most movies, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[:PRODUCED]->(m:Movie)\nRETURN p.name AS PersonName, COUNT(m) AS NumberOfMoviesProduced\nORDER BY NumberOfMoviesProduced DESC\nLIMIT 1;\n```\n\nThis query performs the following steps:\n- `MATCH (p:Person)-[:PRODUCED]->(m:Movie)`: Matches all relationships of type `PRODUCED` where the source node is a `Person` and the destination node is a `Movie`.\n- `RETURN p.name AS PersonName, COUNT(m) AS NumberOfMoviesProduced`: Returns the name of the person and the count of movies they have produced.\n- `ORDER BY NumberOfMoviesProduced DESC`: Sorts the results by the number of movies produced in descending order.\n- `LIMIT 1`: Limits the results to the top row, which will be the person with the most movies produced.",
            "To find the person who has produced the most movies, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:PRODUCED]->(m:Movie)\nRETURN p.name AS PersonName, COUNT(m) AS MovieCount\nORDER BY MovieCount DESC\nLIMIT 1;\n```\n\nThis query does the following:\n- `MATCH (p:Person)-[r:PRODUCED]->(m:Movie)`: Matches all relationships where a person produces a movie.\n- `RETURN p.name AS PersonName, COUNT(m) AS MovieCount`: Returns the name of the person and the count of movies they have produced.\n- `ORDER BY MovieCount DESC`: Orders the results by the number of movies in descending order.\n- `LIMIT 1`: Limits the result to the top person with the most movies.",
            "To find the person who has produced the most movies, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:PRODUCED]->(m:Movie)\nRETURN p.name AS Producer, COUNT(m) AS NumberOfMoviesProduced\nORDER BY NumberOfMoviesProduced DESC\nLIMIT 1;\n```\n\nThis query does the following:\n- Matches all relationships of type `PRODUCED` between `Person` nodes and `Movie` nodes.\n- Counts the number of movies produced by each person.\n- Orders the results by the number of movies produced in descending order.\n- Limits the result to the top producer, who has produced the most movies.",
            "To find the person who has produced the most movies, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:PRODUCED]->(m:Movie)\nRETURN p.name AS PersonName, COUNT(m) AS MovieCount\nORDER BY MovieCount DESC\nLIMIT 1;\n```\n\nThis query does the following:\n- `MATCH (p:Person)-[r:PRODUCED]->(m:Movie)`: Matches all nodes of type `Person` that are related to `Movie` through the `PRODUCED` relationship.\n- `RETURN p.name AS PersonName, COUNT(m) AS MovieCount`: Returns the name of the person and the count of movies they have produced.\n- `ORDER BY MovieCount DESC`: Orders the results by the count of movies in descending order, so the person with the most movies comes first.\n- `LIMIT 1`: Limits the results to the top 1 person with the most movies.",
            "```cypher\nMATCH (p:Person)-[:PRODUCED]->(m:Movie)\nRETURN p.name AS Name, COUNT(m) AS NumberOfMoviesProduced\nORDER BY NumberOfMoviesProduced DESC\nLIMIT 1;\n```"
        ],
        "generated_cyphers": [
            "To find which person has produced the most movies, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[:PRODUCED]->(m:Movie)\nRETURN p.name AS PersonName, COUNT(m) AS NumberOfMoviesProduced\nORDER BY NumberOfMoviesProduced DESC\nLIMIT 1;\n```\n\nThis query performs the following steps:\n- `MATCH (p:Person)-[:PRODUCED]->(m:Movie)`: Matches all relationships of type `PRODUCED` where the source node is a `Person` and the destination node is a `Movie`.\n- `RETURN p.name AS PersonName, COUNT(m) AS NumberOfMoviesProduced`: Returns the name of the person and the count of movies they have produced.\n- `ORDER BY NumberOfMoviesProduced DESC`: Sorts the results by the number of movies produced in descending order.\n- `LIMIT 1`: Limits the results to the top row, which will be the person with the most movies produced.",
            "To find the person who has produced the most movies, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:PRODUCED]->(m:Movie)\nRETURN p.name AS PersonName, COUNT(m) AS MovieCount\nORDER BY MovieCount DESC\nLIMIT 1;\n```\n\nThis query does the following:\n- `MATCH (p:Person)-[r:PRODUCED]->(m:Movie)`: Matches all relationships where a person produces a movie.\n- `RETURN p.name AS PersonName, COUNT(m) AS MovieCount`: Returns the name of the person and the count of movies they have produced.\n- `ORDER BY MovieCount DESC`: Orders the results by the number of movies in descending order.\n- `LIMIT 1`: Limits the result to the top person with the most movies.",
            "To find the person who has produced the most movies, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:PRODUCED]->(m:Movie)\nRETURN p.name AS Producer, COUNT(m) AS NumberOfMoviesProduced\nORDER BY NumberOfMoviesProduced DESC\nLIMIT 1;\n```\n\nThis query does the following:\n- Matches all relationships of type `PRODUCED` between `Person` nodes and `Movie` nodes.\n- Counts the number of movies produced by each person.\n- Orders the results by the number of movies produced in descending order.\n- Limits the result to the top producer, who has produced the most movies.",
            "To find the person who has produced the most movies, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:PRODUCED]->(m:Movie)\nRETURN p.name AS PersonName, COUNT(m) AS MovieCount\nORDER BY MovieCount DESC\nLIMIT 1;\n```\n\nThis query does the following:\n- `MATCH (p:Person)-[r:PRODUCED]->(m:Movie)`: Matches all nodes of type `Person` that are related to `Movie` through the `PRODUCED` relationship.\n- `RETURN p.name AS PersonName, COUNT(m) AS MovieCount`: Returns the name of the person and the count of movies they have produced.\n- `ORDER BY MovieCount DESC`: Orders the results by the count of movies in descending order, so the person with the most movies comes first.\n- `LIMIT 1`: Limits the results to the top 1 person with the most movies.",
            "```cypher\nMATCH (p:Person)-[:PRODUCED]->(m:Movie)\nRETURN p.name AS Name, COUNT(m) AS NumberOfMoviesProduced\nORDER BY NumberOfMoviesProduced DESC\nLIMIT 1;\n```"
        ]
    },
    {
        "question": "List all tweets by 'neo4j' that have more than 200 favorites and show the first 5.",
        "schema": "Node properties:\n- **User**\n  - `betweenness`: FLOAT Example: \"3.49332601E8\"\n  - `location`: STRING Example: \"Graphs Are Everywhere\"\n  - `followers`: INTEGER Example: \"34507\"\n  - `following`: INTEGER Example: \"10124\"\n  - `profile_image_url`: STRING Example: \"http://pbs.twimg.com/profile_images/11837552737537\"\n  - `screen_name`: STRING Example: \"neo4j\"\n  - `name`: STRING Example: \"Neo4j\"\n  - `url`: STRING Example: \"https://t.co/JSIaZFJEaE\"\n  - `statuses`: INTEGER Example: \"512\"\n- **Me**\n  - `profile_image_url`: STRING Available options: ['http://pbs.twimg.com/profile_images/11837552737537']\n  - `betweenness`: FLOAT Min: 3.49332601E8, Max: 3.49332601E8\n  - `following`: INTEGER Min: 10124, Max: 10124\n  - `url`: STRING Available options: ['https://t.co/JSIaZFJEaE']\n  - `location`: STRING Available options: ['Graphs Are Everywhere']\n  - `followers`: INTEGER Min: 34507, Max: 34507\n  - `screen_name`: STRING Available options: ['neo4j']\n  - `name`: STRING Available options: ['Neo4j']\n- **Tweet**\n  - `created_at`: DATE_TIME Min: 2020-12-06T05:12:02Z, Max: 2021-03-16T15:30:07Z\n  - `id`: INTEGER Min: 690028662083612672, Max: 1371846247913512966\n  - `id_str`: STRING Example: \"1371815021265747970\"\n  - `text`: STRING Example: \"Proud to help @educationgovuk deliver critical ser\"\n  - `favorites`: INTEGER Min: 0, Max: 394\n  - `import_method`: STRING Available options: ['user']\n- **Hashtag**\n  - `name`: STRING Example: \"education\"\n- **Link**\n  - `url`: STRING Example: \"https://twitter.com/i/web/status/13718150212657479\"\n- **Source**\n  - `name`: STRING Example: \"Buffer\"\nRelationship properties:\n- **SIMILAR_TO**\n  - `score: FLOAT` Min: 0.0030581039755351682, Max:  1.0\nThe relationships:\n(:User)-[:FOLLOWS]->(:User)\n(:User)-[:FOLLOWS]->(:Me)\n(:User)-[:POSTS]->(:Tweet)\n(:User)-[:INTERACTS_WITH]->(:User)\n(:User)-[:SIMILAR_TO]->(:User)\n(:User)-[:SIMILAR_TO]->(:Me)\n(:Me)-[:FOLLOWS]->(:User)\n(:Me)-[:POSTS]->(:Tweet)\n(:Me)-[:INTERACTS_WITH]->(:User)\n(:Me)-[:RT_MENTIONS]->(:User)\n(:Me)-[:AMPLIFIES]->(:User)\n(:Tweet)-[:MENTIONS]->(:User)\n(:Tweet)-[:MENTIONS]->(:Me)\n(:Tweet)-[:USING]->(:Source)\n(:Tweet)-[:TAGS]->(:Hashtag)\n(:Tweet)-[:CONTAINS]->(:Link)\n(:Tweet)-[:RETWEETS]->(:Tweet)\n(:Tweet)-[:REPLY_TO]->(:Tweet)",
        "gold_cypher": "MATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet) WHERE t.favorites > 200 RETURN t ORDER BY t.favorites DESC LIMIT 5",
        "database": "twitter",
        "full_responses": [
            "```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)-[:RETWEETS]->(t2:Tweet)\nWHERE t.favorites > 200\nRETURN t2.id_str LIMIT 5\n```",
            "```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)\nWHERE t.favorites > 200\nRETURN t.text AS tweetText, t.created_at AS tweetDate\nLIMIT 5\n```",
            "```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)\nWHERE t.favorites > 200\nRETURN t.text LIMIT 5;\n```",
            "```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)\nWHERE t.favorites > 200\nRETURN t\nLIMIT 5\n```",
            "Certainly! To list all tweets by 'neo4j' that have more than 200 favorites and show the first 5, you can use the following Cypher query:\n\n```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)\nWHERE t.favorites > 200\nRETURN t\nLIMIT 5;\n```\n\nThis query matches the user 'neo4j' and finds all tweets they have posted, then filters those tweets to include only those with more than 200 favorites, and finally returns the first 5 such tweets."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)-[:RETWEETS]->(t2:Tweet)\nWHERE t.favorites > 200\nRETURN t2.id_str LIMIT 5\n```",
            "```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)\nWHERE t.favorites > 200\nRETURN t.text AS tweetText, t.created_at AS tweetDate\nLIMIT 5\n```",
            "```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)\nWHERE t.favorites > 200\nRETURN t.text LIMIT 5;\n```",
            "```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)\nWHERE t.favorites > 200\nRETURN t\nLIMIT 5\n```",
            "Certainly! To list all tweets by 'neo4j' that have more than 200 favorites and show the first 5, you can use the following Cypher query:\n\n```cypher\nMATCH (u:User {screen_name: 'neo4j'})-[:POSTS]->(t:Tweet)\nWHERE t.favorites > 200\nRETURN t\nLIMIT 5;\n```\n\nThis query matches the user 'neo4j' and finds all tweets they have posted, then filters those tweets to include only those with more than 200 favorites, and finally returns the first 5 such tweets."
        ]
    },
    {
        "question": "What are the top 5 movies with the longest runtime and released after 2010?",
        "schema": "Node properties:\n- **Movie**\n  - `average_vote`: FLOAT Example: \"7.7\"\n  - `overview`: STRING Example: \"Led by Woody, Andy's toys live happily in his room\"\n  - `revenue`: FLOAT Example: \"3.73554033E8\"\n  - `vote_count`: INTEGER Example: \"5415\"\n  - `tagline`: STRING Example: \"Roll the dice and unleash the excitement!\"\n  - `budget`: INTEGER Example: \"30000000\"\n  - `title`: STRING Example: \"Toy Story\"\n  - `poster_path`: STRING Example: \"/rhIRbceoE9lR4veEXuwCC2wARtG.jpg\"\n  - `imdb_id`: STRING Example: \"tt0114709\"\n  - `status`: STRING Example: \"Released\"\n  - `runtime`: FLOAT Example: \"81.0\"\n  - `popularity`: FLOAT Example: \"21.946943\"\n  - `homepage`: STRING Example: \"http://toystory.disney.com/toy-story\"\n  - `release_date`: DATE Example: \"1995-10-30\"\n  - `id`: INTEGER Min: 862, Max: 31357\n  - `original_title`: STRING Example: \"Toy Story\"\n  - `original_language`: STRING Example: \"en\"\n- **Language**\n  - `id`: STRING Example: \"en\"\n  - `name`: STRING Available options: ['', 'Gaeilge', 'Kiswahili', 'Az\u0259rbaycan', 'Somali', '\u0431\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f \u043c\u043e\u0432\u0430', 'Fulfulde', 'Hausa']\n- **Country**\n  - `id`: STRING Example: \"US\"\n  - `name`: STRING Example: \"United States of America\"\n- **Genre**\n  - `id`: INTEGER Min: 12, Max: 10770\n  - `name`: STRING Example: \"Animation\"\n- **ProductionCompany**\n  - `id`: INTEGER Min: 3, Max: 10201\n  - `name`: STRING Example: \"Pixar Animation Studios\"\n- **Collection**\n  - `name`: STRING Example: \"Toy Story Collection\"\n  - `id`: INTEGER Min: 10, Max: 480160\n  - `backdrop_path`: STRING Example: \"/9FBwqcd9IRruEDUrTdcaafOMKUq.jpg\"\n  - `poster_path`: STRING Example: \"/7G9915LfUQ2lVfwMEEhDsn3kT4B.jpg\"\n- **Person**\n  - `gender`: INTEGER Example: \"2\"\n  - `profile_path`: STRING Example: \"/pQFoyx7rp09CJTAb932F2g8Nlho.jpg\"\n  - `id`: INTEGER Min: 31, Max: 12900\n  - `name`: STRING Example: \"Tom Hanks\"\n- **User**\n  - `id`: INTEGER Min: 27490cf6-22eb-495d-9dd6-902c0f89c627, Max: 4\n- **Keyword**\n  - `id`: INTEGER Min: 931, Max: 9713\n  - `name`: STRING Example: \"jealousy\"\n- **Video**\n  - `tagline`: STRING Example: \"Fresh Fish. Mixed Vegetables.\"\n  - `average_vote`: FLOAT Min: 0.0, Max: 10.0\n  - `overview`: STRING Example: \"Get ready as Bob the Tomato, Larry the Cucumber an\"\n  - `revenue`: FLOAT Min: 0.0, Max: 0.0\n  - `poster_path`: STRING Example: \"/iWahPsY3hsKOizZHgzQcAxv4O3B.jpg\"\n  - `vote_count`: INTEGER Min: 0, Max: 115\n  - `title`: STRING Example: \"Jonah: A VeggieTales Movie\"\n  - `release_date`: DATE Min: 1973-01-12, Max: 2017-03-17\n  - `status`: STRING Available options: ['Released']\n  - `budget`: INTEGER Min: 0, Max: 2219684\n  - `popularity`: FLOAT Min: 0.0, Max: 9.22546\n  - `imdb_id`: STRING Example: \"tt0298388\"\n  - `original_title`: STRING Example: \"Jonah: A VeggieTales Movie\"\n  - `id`: INTEGER Min: 13284, Max: 461088\n  - `runtime`: FLOAT Min: 0.0, Max: 583.0\n  - `original_language`: STRING Example: \"en\"\n  - `homepage`: STRING Example: \"http://www.loosechange911.com/\"\n- **Adult**\n  - `average_vote`: FLOAT Min: 0.0, Max: 6.3\n  - `overview`: STRING Available options: ['A sailor takes an American businessman and his gir', 'The FBI and Texas police make ready to storm the h', 'Electrical Girl centers around a horny young woman', '\u00c1gata suffers from a psychological disorder which ', \"Shane Ryan's sequel to the disturbing Amateur Porn\", 'Australian film about a fictional sub-par Australi', 'Olaf and his mother run a boarding house and a whi', 'A man who returns home to find his wife cheating o', 'An American scientific research facility opens a p']\n  - `revenue`: FLOAT Min: 0.0, Max: 0.0\n  - `poster_path`: STRING Available options: ['/tzVK7nTnzUiVeFSZhOAIHmrgXUS.jpg', '/1VzwIa8HTykNiCCW8PBaJnyTvO8.jpg', '/yTfqRQlJMTAuTNDG01XjNg5KPPg.jpg', '/oP2WvKIWxqSBVHjfYAizFHOqBLG.jpg', '/zpycBSiBFp5Uib6gWJpgEvfOgdn.jpg', '/e7CAc8OadcUoKNPIX86SEPSX7f.jpg', '/jjncR0vECvXVrBvr0A1vLghL4pN.jpg', '/pJLmZBruOmn2c9mYWe3h1xcXaA0.jpg', '/3uv9oaqOJkkdZiQp6r9lf24tkHW.jpg']\n  - `vote_count`: INTEGER Min: 0, Max: 16\n  - `title`: STRING Available options: ['Erotic Nights of the Living Dead', 'Standoff', 'Electrical Girl', 'Diet of Sex', 'Amateur Porn Star Killer 2', 'The Band', 'The Sinful Dwarf', 'Adulterers', 'Half -Life']\n  - `release_date`: DATE Min: 1973-12-20, Max: 2016-01-05\n  - `status`: STRING Available options: ['Released', 'In Production']\n  - `budget`: INTEGER Min: 0, Max: 750000\n  - `popularity`: FLOAT Min: 0.001803, Max: 6.889832\n  - `imdb_id`: STRING Available options: ['tt0079642', 'tt0119931', 'tt0322232', 'tt3094816', 'tt1161951', 'tt1153101', 'tt0070696', 'tt4044464', 'tt2697688']\n  - `original_title`: STRING Available options: ['Le notti erotiche dei morti viventi', 'Standoff', '\u767c\u96fb\u6084\u5b0c\u5a03', 'Diet of Sex', 'Amateur Porn Star Killer 2', 'The Band', 'Dv\u00e6rgen', 'Adulterers', 'Half -Life']\n  - `id`: INTEGER Min: 5422, Max: 448290\n  - `runtime`: FLOAT Min: 0.0, Max: 112.0\n  - `original_language`: STRING Available options: ['it', 'en', 'cn', 'es', 'da']\n  - `tagline`: STRING Available options: ['Trust Will Get You Killed', 'Comedy, food, drama and sex, a lot of sex', 'Humiliation. Rape. Murder. You know the drill.', \"Sex, drugs and Rock 'n Roll\", 'The Mother of all Dwarfsploitation films!', 'Love. Betrayal. Vengeance']\n  - `homepage`: STRING Available options: ['http://www.imdb.com/title/tt0119931/', 'http://www.dietofsex.com/']\n- **Package**\n  - `price`: FLOAT Min: 0.0, Max: 99.99\n  - `duration`: DURATION \n  - `id`: INTEGER Min: 0, Max: 6\n  - `name`: STRING Available options: ['Childrens', 'Bronze', 'Silver', 'Gold', 'Platinum', 'Ultimate', 'Free Trial']\n- **Subscription**\n  - `expiresAt`: DATE_TIME Min: 2020-08-23T16:20:52.383Z, Max: 2020-08-23T16:20:52.383Z\n  - `id`: STRING Available options: ['e74f7163-eace-4169-8043-41627f1fe236']\nRelationship properties:\n- **CAST_FOR**\n  - `credit_id: STRING` Example: \"52fe4459c3a36847f8090d7d\"\n  - `order: INTEGER` Example: \"0\"\n  - `character: STRING` Example: \"Charlie Wilson\"\n  - `cast_id: INTEGER` Example: \"12\"\n- **CREW_FOR**\n  - `credit_id: STRING` Example: \"55e4f0abc3a368140800047e\"\n  - `job: STRING` Example: \"Producer\"\n  - `department: STRING` Example: \"Production\"\n- **RATED**\n  - `timestamp: DATE_TIME` Example: \"2015-03-09T22:49:42Z\"\n  - `rating: FLOAT` Example: \"5.0\"\nThe relationships:\n(:Movie)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Movie)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Movie)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Movie)-[:IN_GENRE]->(:Genre)\n(:Movie)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Movie)-[:HAS_KEYWORD]->(:Keyword)\n(:Movie)-[:IN_COLLECTION]->(:Collection)\n(:Person)-[:CAST_FOR]->(:Movie)\n(:Person)-[:CREW_FOR]->(:Movie)\n(:Person)-[:CREW_FOR]->(:Video)\n(:User)-[:RATED]->(:Movie)\n(:User)-[:RATED]->(:Video)\n(:Video)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Video)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Video)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Video)-[:IN_GENRE]->(:Genre)\n(:Video)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Video)-[:HAS_KEYWORD]->(:Keyword)\n(:Video)-[:IN_COLLECTION]->(:Collection)\n(:Adult)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Adult)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Adult)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Adult)-[:IN_GENRE]->(:Genre)\n(:Adult)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Adult)-[:HAS_KEYWORD]->(:Keyword)\n(:Package)-[:PROVIDES_ACCESS_TO]->(:Genre)\n(:Subscription)-[:FOR_PACKAGE]->(:Package)",
        "gold_cypher": "MATCH (m:Movie) WHERE m.release_date > date('2010-01-01') AND m.runtime IS NOT NULL RETURN m ORDER BY m.runtime DESC LIMIT 5",
        "database": "eoflix",
        "full_responses": [
            "```cypher\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre)\nWHERE m.runtime > 240 AND m.release_date > '2010-01-01'\nRETURN m.title AS MovieTitle, m.runtime AS Runtime\nORDER BY m.runtime DESC\nLIMIT 5\n```",
            "To find the top 5 movies with the longest runtime and released after 2010, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01' AND m.runtime > 0\nORDER BY m.runtime DESC\nLIMIT 5\n```\n\nThis query matches all movies (`m:Movie`) where the `release_date` is after 2010 and the `runtime` is greater than 0. It then orders these movies by their runtime in descending order and limits the result to the top 5 movies.",
            "To find the top 5 movies with the longest runtime and released after 2010, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01' AND m.runtime IS NOT NULL\nORDER BY m.runtime DESC\nLIMIT 5;\n```\n\nThis query selects movies that meet the criteria of having a runtime greater than 0 and released after 2010. It then orders the results by runtime in descending order and limits the output to the top 5 movies.",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01'\nORDER BY m.runtime DESC\nLIMIT 5\n```",
            "To answer the question about the top 5 movies with the longest runtime and released after 2010, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01'\nORDER BY m.runtime DESC\nLIMIT 5\n```\n\nThis query does the following:\n- `MATCH (m:Movie)`: Matches all nodes of type `Movie`.\n- `WHERE m.release_date > '2010-01-01'`: Filters the movies to include only those released after 2010.\n- `ORDER BY m.runtime DESC`: Orders the movies by their runtime in descending order, so the longest movies come first.\n- `LIMIT 5`: Limits the result to the top 5 movies based on the order specified."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre)\nWHERE m.runtime > 240 AND m.release_date > '2010-01-01'\nRETURN m.title AS MovieTitle, m.runtime AS Runtime\nORDER BY m.runtime DESC\nLIMIT 5\n```",
            "To find the top 5 movies with the longest runtime and released after 2010, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01' AND m.runtime > 0\nORDER BY m.runtime DESC\nLIMIT 5\n```\n\nThis query matches all movies (`m:Movie`) where the `release_date` is after 2010 and the `runtime` is greater than 0. It then orders these movies by their runtime in descending order and limits the result to the top 5 movies.",
            "To find the top 5 movies with the longest runtime and released after 2010, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01' AND m.runtime IS NOT NULL\nORDER BY m.runtime DESC\nLIMIT 5;\n```\n\nThis query selects movies that meet the criteria of having a runtime greater than 0 and released after 2010. It then orders the results by runtime in descending order and limits the output to the top 5 movies.",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01'\nORDER BY m.runtime DESC\nLIMIT 5\n```",
            "To answer the question about the top 5 movies with the longest runtime and released after 2010, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01'\nORDER BY m.runtime DESC\nLIMIT 5\n```\n\nThis query does the following:\n- `MATCH (m:Movie)`: Matches all nodes of type `Movie`.\n- `WHERE m.release_date > '2010-01-01'`: Filters the movies to include only those released after 2010.\n- `ORDER BY m.runtime DESC`: Orders the movies by their runtime in descending order, so the longest movies come first.\n- `LIMIT 5`: Limits the result to the top 5 movies based on the order specified."
        ]
    },
    {
        "question": "Identify characters who have both high pagerank and high degree of centrality. Limit to top 5.",
        "schema": "Node properties:\n- **Character**\n  - `centrality`: FLOAT Min: 0.0, Max: 1.0\n  - `book45PageRank`: FLOAT Min: 0.15000000000000002, Max: 11.409916274911177\n  - `fastrf_embedding`: LIST Min Size: 10, Max Size: 10\n  - `book1BetweennessCentrality`: FLOAT Min: 0.0, Max: 4638.53495125504\n  - `book1PageRank`: FLOAT Min: 0.15000000000000002, Max: 8.164174336296284\n  - `louvain`: INTEGER Min: 0, Max: 10\n  - `community`: INTEGER Min: 504, Max: 795\n  - `degree`: FLOAT Min: 0.0, Max: 300.0\n  - `name`: STRING Example: \"Addam-Marbrand\"\n  - `pagerank`: FLOAT Min: 0.15000000000000002, Max: 9.473142454730429\nRelationship properties:\n- **INTERACTS**\n  - `weight: INTEGER` Min: 3, Max:  334\n- **INTERACTS1**\n  - `weight: INTEGER` Min: 3, Max:  291\n  - `book: INTEGER` Min: 1, Max:  1\n- **INTERACTS2**\n  - `weight: INTEGER` Min: 3, Max:  92\n  - `book: INTEGER` Min: 2, Max:  2\n- **INTERACTS3**\n  - `weight: INTEGER` Min: 3, Max:  95\n  - `book: INTEGER` Min: 3, Max:  3\n- **INTERACTS45**\n  - `weight: INTEGER` Min: 3, Max:  96\n  - `book: INTEGER` Min: 45, Max:  45\nThe relationships:\n(:Character)-[:INTERACTS45]->(:Character)\n(:Character)-[:INTERACTS]->(:Character)\n(:Character)-[:INTERACTS1]->(:Character)\n(:Character)-[:INTERACTS3]->(:Character)\n(:Character)-[:INTERACTS2]->(:Character)",
        "gold_cypher": "MATCH (c:Character) WHERE c.pagerank > 5 AND c.centrality > 0.5 RETURN c ORDER BY c.pagerank DESC, c.centrality DESC LIMIT 5",
        "database": "gameofthrones",
        "full_responses": [
            "```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 5.0 AND c.centrality > 0.5\nRETURN c.name, c.pagerank, c.centrality\nORDER BY c.pagerank DESC, c.centrality DESC\nLIMIT 5;\n```",
            "```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 9.473142454730429 AND c.centrality > 0.9\nRETURN c.name, c.pagerank, c.centrality\nORDER BY c.centrality DESC\nLIMIT 5\n```",
            "To identify characters who have both high pagerank and high degree of centrality and limit the results to the top 5, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 8.164174336296284 AND c.degree > 200\nRETURN c.name, c.pagerank, c.degree\nORDER BY c.pagerank DESC, c.degree DESC\nLIMIT 5;\n```\n\nThis query filters characters based on having a pagerank greater than 8.164174336296284 and a degree greater than 200. It then orders the results by pagerank in descending order and degree in descending order, and limits the output to the top 5 characters.",
            "To identify characters who have both high pagerank and high degree of centrality from the given database schema, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 0.3 AND c.centrality > 0.8\nRETURN c.name, c.pagerank, c.centrality\nORDER BY c.centrality DESC, c.pagerank DESC\nLIMIT 5;\n```\n\nThis query does the following:\n1. Matches all nodes of type `Character`.\n2. Filters nodes where the `pagerank` is greater than 0.3 and the `centrality` is greater than 0.8.\n3. Returns the `name`, `pagerank`, and `centrality` of these nodes.\n4. Orders the results by `centrality` in descending order and `pagerank` in descending order to ensure that characters with higher centrality and higher pagerank are listed first.\n5. Limits the results to the top 5 characters.",
            "To find characters with high pagerank and high degree of centrality, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 0.7 AND c.degree > 100\nRETURN c.name, c.pagerank, c.degree\nORDER BY c.pagerank DESC, c.degree DESC\nLIMIT 5;\n```\n\nThis query filters characters with a pagerank greater than 0.7 and a degree greater than 100. It then orders the results by pagerank and degree in descending order and limits the output to the top 5 characters."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 5.0 AND c.centrality > 0.5\nRETURN c.name, c.pagerank, c.centrality\nORDER BY c.pagerank DESC, c.centrality DESC\nLIMIT 5;\n```",
            "```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 9.473142454730429 AND c.centrality > 0.9\nRETURN c.name, c.pagerank, c.centrality\nORDER BY c.centrality DESC\nLIMIT 5\n```",
            "To identify characters who have both high pagerank and high degree of centrality and limit the results to the top 5, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 8.164174336296284 AND c.degree > 200\nRETURN c.name, c.pagerank, c.degree\nORDER BY c.pagerank DESC, c.degree DESC\nLIMIT 5;\n```\n\nThis query filters characters based on having a pagerank greater than 8.164174336296284 and a degree greater than 200. It then orders the results by pagerank in descending order and degree in descending order, and limits the output to the top 5 characters.",
            "To identify characters who have both high pagerank and high degree of centrality from the given database schema, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 0.3 AND c.centrality > 0.8\nRETURN c.name, c.pagerank, c.centrality\nORDER BY c.centrality DESC, c.pagerank DESC\nLIMIT 5;\n```\n\nThis query does the following:\n1. Matches all nodes of type `Character`.\n2. Filters nodes where the `pagerank` is greater than 0.3 and the `centrality` is greater than 0.8.\n3. Returns the `name`, `pagerank`, and `centrality` of these nodes.\n4. Orders the results by `centrality` in descending order and `pagerank` in descending order to ensure that characters with higher centrality and higher pagerank are listed first.\n5. Limits the results to the top 5 characters.",
            "To find characters with high pagerank and high degree of centrality, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nWHERE c.pagerank > 0.7 AND c.degree > 100\nRETURN c.name, c.pagerank, c.degree\nORDER BY c.pagerank DESC, c.degree DESC\nLIMIT 5;\n```\n\nThis query filters characters with a pagerank greater than 0.7 and a degree greater than 100. It then orders the results by pagerank and degree in descending order and limits the output to the top 5 characters."
        ]
    },
    {
        "question": "Identify the top 3 filings in terms of amount that concern entities in Singapore.",
        "schema": "Node properties:\n- **Country**\n  - `location`: POINT \n  - `code`: STRING Example: \"AFG\"\n  - `name`: STRING Example: \"Afghanistan\"\n  - `tld`: STRING Example: \"AF\"\n- **Filing**\n  - `begin`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-09-05T00:00:00Z\n  - `end`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-11-03T00:00:00Z\n  - `originator_bank_id`: STRING Example: \"cimb-bank-berhad\"\n  - `sar_id`: STRING Example: \"3297\"\n  - `beneficiary_bank`: STRING Example: \"Barclays Bank Plc\"\n  - `filer_org_name_id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `originator_bank_country`: STRING Example: \"Singapore\"\n  - `beneficiary_bank_country`: STRING Example: \"United Kingdom\"\n  - `filer_org_name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `originator_iso`: STRING Example: \"SGP\"\n  - `beneficiary_bank_id`: STRING Example: \"barclays-bank-plc-london-england-gbr\"\n  - `origin_lat`: STRING Example: \"1.3667\"\n  - `origin_lng`: STRING Example: \"103.8\"\n  - `end_date_format`: STRING Example: \"2015-09-25T00:00:00Z\"\n  - `begin_date_format`: STRING Example: \"2015-03-25T00:00:00Z\"\n  - `originator_bank`: STRING Example: \"CIMB Bank Berhad\"\n  - `beneficiary_lat`: STRING Example: \"54\"\n  - `beneficiary_iso`: STRING Example: \"GBR\"\n  - `beneficiary_lng`: STRING Example: \"-2\"\n  - `begin_date`: STRING Example: \"Mar 25, 2015\"\n  - `id`: STRING Example: \"223254\"\n  - `end_date`: STRING Example: \"Sep 25, 2015\"\n  - `amount`: INTEGER Min: 1.18, Max: 2721000000\n  - `number`: INTEGER Min: 1, Max: 174\n- **Entity**\n  - `id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `location`: POINT \n  - `name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `country`: STRING Example: \"CHN\"\nRelationship properties:\n\nThe relationships:\n(:Filing)-[:BENEFITS]->(:Entity)\n(:Filing)-[:CONCERNS]->(:Entity)\n(:Filing)-[:ORIGINATOR]->(:Entity)\n(:Entity)-[:FILED]->(:Filing)\n(:Entity)-[:COUNTRY]->(:Country)",
        "gold_cypher": "MATCH (f:Filing)-[:CONCERNS]->(e:Entity)-[:COUNTRY]->(c:Country {name: \"Singapore\"}) RETURN f ORDER BY f.amount DESC LIMIT 3",
        "database": "fincen",
        "full_responses": [
            "To identify the top 3 filings in terms of amount that concern entities in Singapore, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity)-[:COUNTRY]->(c:Country {name: 'Singapore'})\nWITH e, c\nMATCH (e)-[r:FILING]->(f:Filing)\nWHERE c.code = 'SGP'\nRETURN f.amount, f.id, f.begin, f.end, f.begin_date_format, f.end_date_format\nORDER BY f.amount DESC\nLIMIT 3;\n```\n\nThis query performs the following steps:\n1. Matches entities in Singapore.\n2. Finds the filings associated with these entities.\n3. Filters the filings to include only those from Singapore.\n4. Sorts the results by the filing amount in descending order.\n5. Limits the output to the top 3 filings.",
            "To answer the question, we need to identify the top 3 filings based on their amount that concern entities located in Singapore. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (f:Filing)-[:CONCERNS]->(e:Entity)-[:COUNTRY]->(c:Country)\nWHERE c.code = 'SGP' AND f.amount > 0\nWITH f.amount, f.id\nORDER BY f.amount DESC\nLIMIT 3\n```\n\n### Explanation:\n1. **MATCH**: We start by matching the `Filing` node to the `Entity` nodes and then to the `Country` node to ensure that we are only considering filings that concern entities located in Singapore.\n2. **WHERE**: We filter the filings to only include those with an amount greater than 0 and are located in Singapore.\n3. **WITH**: We extract the `amount` and `id` properties of the filings for further processing.\n4. **ORDER BY**: We order the filtered filings by their amount in descending order to get the top 3 filings.\n5. **LIMIT**: We limit the result to the top 3 filings.",
            "```cypher\nMATCH (e:Entity)-[r:CONCERNS]->(f:Filing)\nWHERE e.country = 'SGP'\nRETURN f.amount AS amount, f.id AS filing_id\nORDER BY f.amount DESC\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Filing)-[:CONCERNS]->(e:Entity)-[:COUNTRY]->(c:Country {code: \"SGP\"})\nWITH f, e, c, f.amount AS amount\nORDER BY amount DESC\nLIMIT 3\nRETURN f.id AS filing_id, f.amount AS amount, e.name AS entity_name, c.name AS country_name\n```",
            "```cypher\nMATCH (f:Filing)-[:CONCERNS]->(e:Entity)\nWHERE e.country = 'SGP'\nRETURN f.amount DESC, f, e LIMIT 3\n```"
        ],
        "generated_cyphers": [
            "To identify the top 3 filings in terms of amount that concern entities in Singapore, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity)-[:COUNTRY]->(c:Country {name: 'Singapore'})\nWITH e, c\nMATCH (e)-[r:FILING]->(f:Filing)\nWHERE c.code = 'SGP'\nRETURN f.amount, f.id, f.begin, f.end, f.begin_date_format, f.end_date_format\nORDER BY f.amount DESC\nLIMIT 3;\n```\n\nThis query performs the following steps:\n1. Matches entities in Singapore.\n2. Finds the filings associated with these entities.\n3. Filters the filings to include only those from Singapore.\n4. Sorts the results by the filing amount in descending order.\n5. Limits the output to the top 3 filings.",
            "To answer the question, we need to identify the top 3 filings based on their amount that concern entities located in Singapore. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (f:Filing)-[:CONCERNS]->(e:Entity)-[:COUNTRY]->(c:Country)\nWHERE c.code = 'SGP' AND f.amount > 0\nWITH f.amount, f.id\nORDER BY f.amount DESC\nLIMIT 3\n```\n\n### Explanation:\n1. **MATCH**: We start by matching the `Filing` node to the `Entity` nodes and then to the `Country` node to ensure that we are only considering filings that concern entities located in Singapore.\n2. **WHERE**: We filter the filings to only include those with an amount greater than 0 and are located in Singapore.\n3. **WITH**: We extract the `amount` and `id` properties of the filings for further processing.\n4. **ORDER BY**: We order the filtered filings by their amount in descending order to get the top 3 filings.\n5. **LIMIT**: We limit the result to the top 3 filings.",
            "```cypher\nMATCH (e:Entity)-[r:CONCERNS]->(f:Filing)\nWHERE e.country = 'SGP'\nRETURN f.amount AS amount, f.id AS filing_id\nORDER BY f.amount DESC\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Filing)-[:CONCERNS]->(e:Entity)-[:COUNTRY]->(c:Country {code: \"SGP\"})\nWITH f, e, c, f.amount AS amount\nORDER BY amount DESC\nLIMIT 3\nRETURN f.id AS filing_id, f.amount AS amount, e.name AS entity_name, c.name AS country_name\n```",
            "```cypher\nMATCH (f:Filing)-[:CONCERNS]->(e:Entity)\nWHERE e.country = 'SGP'\nRETURN f.amount DESC, f, e LIMIT 3\n```"
        ]
    },
    {
        "question": "What are the names of streams with the oldest creation dates and their associated games?",
        "schema": "Node properties:\n- **Stream**\n  - `createdAt`: DATE_TIME Min: 2007-05-22T10:39:53.259969Z, Max: 2021-05-09T14:16:40.370294Z\n  - `id`: STRING Example: \"129004176\"\n  - `description`: STRING Example: \"Welcome to my Channel, I'm Big Chase, 31 living in\"\n  - `url`: STRING Example: \"https://www.twitch.tv/itsbigchase\"\n  - `name`: STRING Example: \"itsbigchase\"\n  - `followers`: INTEGER Min: 0, Max: 10243195\n  - `total_view_count`: INTEGER Min: 21, Max: 1451487256\n- **Game**\n  - `name`: STRING Example: \"Rust\"\n- **Language**\n  - `name`: STRING Example: \"en\"\n- **User**\n  - `name`: STRING Example: \"itsbigchase\"\n- **Team**\n  - `createdAt`: DATE_TIME Min: 2011-10-11T23:59:43.548701Z, Max: 2021-05-07T17:19:09.946382Z\n  - `name`: STRING Example: \"ESO Stream Team\"\n  - `id`: STRING Example: \"5893\"\nRelationship properties:\n\nThe relationships:\n(:Stream)-[:PLAYS]->(:Game)\n(:Stream)-[:HAS_LANGUAGE]->(:Language)\n(:Stream)-[:MODERATOR]->(:Stream)\n(:Stream)-[:MODERATOR]->(:User)\n(:Stream)-[:CHATTER]->(:Stream)\n(:Stream)-[:CHATTER]->(:User)\n(:Stream)-[:HAS_TEAM]->(:Team)\n(:Stream)-[:VIP]->(:Stream)\n(:Stream)-[:VIP]->(:User)\n(:User)-[:CHATTER]->(:Stream)\n(:User)-[:CHATTER]->(:User)\n(:User)-[:MODERATOR]->(:Stream)\n(:User)-[:MODERATOR]->(:User)",
        "gold_cypher": "MATCH (s:Stream)-[:PLAYS]->(g:Game) WITH s, g ORDER BY s.createdAt LIMIT 1 RETURN s.name AS stream_name, g.name AS game_name",
        "database": "twitch",
        "full_responses": [
            "To find the names of streams with the oldest creation dates and their associated games, you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[p:PLAYS]->(g:Game)\nWHERE p.createdAt = (SELECT MIN(createdAt) FROM Stream)\nRETURN s.name AS StreamName, g.name AS GameName\n```\n\nThis query works as follows:\n- `MATCH (s:Stream)-[p:PLAYS]->(g:Game)` matches all relationships between streams and their associated games.\n- `WHERE p.createdAt = (SELECT MIN(createdAt) FROM Stream)` filters the results to only include streams with the oldest creation dates. This is done by selecting the minimum `createdAt` value from the `Stream` nodes and comparing it to each stream's creation date.\n- `RETURN s.name AS StreamName, g.name AS GameName` returns the names of the streams and their associated games for the filtered results.",
            "```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game)\nWHERE r.createdAt = (SELECT min(createdAt) FROM Stream)\nRETURN s.name, g.name\n```",
            "To answer the question \"What are the names of streams with the oldest creation dates and their associated games?\", you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game)\nWHERE r.createdAt = MAX(r.createdAt)\nRETURN s.name AS StreamName, g.name AS GameName\n```\n\nThis query works as follows:\n- It matches all relationships of type `PLAYS` between `Stream` and `Game`.\n- It filters the relationships to only include those where the `createdAt` date is the maximum, which corresponds to the oldest streams.\n- It returns the names of the streams (`s.name`) and the games they play (`g.name`).",
            "To find the streams with the oldest creation dates and their associated games, you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game)\nWHERE r.createdAt = (SELECT MIN(r.createdAt) FROM (MATCH (s:Stream)-[r:PLAYS]->(g:Game)) AS T)\nRETURN s.name, g.name\nORDER BY s.createdAt ASC;\n```\n\nThis query does the following:\n1. Matches all streams and their associated games using the `PLAYS` relationship.\n2. Finds the minimum creation date of any stream by using a subquery `(SELECT MIN(r.createdAt) FROM (MATCH (s:Stream)-[r:PLAYS]->(g:Game)) AS T)`.\n3. Returns the names of streams and their associated games where the creation date matches the minimum creation date found.\n4. Orders the results by the creation date in ascending order to get the oldest streams first.",
            "To find the names of streams with the oldest creation dates and their associated games, you can use the following Cypher query. This query will select the stream name, game name, and sort the results by the creation date of the stream in ascending order to get the oldest streams first.\n\n```cypher\nMATCH (s:Stream)\nRETURN s.name AS stream_name, g.name AS game_name\nORDER BY s.createdAt ASC\n```\n\nThis query matches all nodes of type `Stream` and returns the `name` of the stream and the `name` of the game it is associated with. The results are then ordered by the `createdAt` property of the stream in ascending order, ensuring that the oldest streams appear first."
        ],
        "generated_cyphers": [
            "To find the names of streams with the oldest creation dates and their associated games, you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[p:PLAYS]->(g:Game)\nWHERE p.createdAt = (SELECT MIN(createdAt) FROM Stream)\nRETURN s.name AS StreamName, g.name AS GameName\n```\n\nThis query works as follows:\n- `MATCH (s:Stream)-[p:PLAYS]->(g:Game)` matches all relationships between streams and their associated games.\n- `WHERE p.createdAt = (SELECT MIN(createdAt) FROM Stream)` filters the results to only include streams with the oldest creation dates. This is done by selecting the minimum `createdAt` value from the `Stream` nodes and comparing it to each stream's creation date.\n- `RETURN s.name AS StreamName, g.name AS GameName` returns the names of the streams and their associated games for the filtered results.",
            "```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game)\nWHERE r.createdAt = (SELECT min(createdAt) FROM Stream)\nRETURN s.name, g.name\n```",
            "To answer the question \"What are the names of streams with the oldest creation dates and their associated games?\", you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game)\nWHERE r.createdAt = MAX(r.createdAt)\nRETURN s.name AS StreamName, g.name AS GameName\n```\n\nThis query works as follows:\n- It matches all relationships of type `PLAYS` between `Stream` and `Game`.\n- It filters the relationships to only include those where the `createdAt` date is the maximum, which corresponds to the oldest streams.\n- It returns the names of the streams (`s.name`) and the games they play (`g.name`).",
            "To find the streams with the oldest creation dates and their associated games, you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game)\nWHERE r.createdAt = (SELECT MIN(r.createdAt) FROM (MATCH (s:Stream)-[r:PLAYS]->(g:Game)) AS T)\nRETURN s.name, g.name\nORDER BY s.createdAt ASC;\n```\n\nThis query does the following:\n1. Matches all streams and their associated games using the `PLAYS` relationship.\n2. Finds the minimum creation date of any stream by using a subquery `(SELECT MIN(r.createdAt) FROM (MATCH (s:Stream)-[r:PLAYS]->(g:Game)) AS T)`.\n3. Returns the names of streams and their associated games where the creation date matches the minimum creation date found.\n4. Orders the results by the creation date in ascending order to get the oldest streams first.",
            "To find the names of streams with the oldest creation dates and their associated games, you can use the following Cypher query. This query will select the stream name, game name, and sort the results by the creation date of the stream in ascending order to get the oldest streams first.\n\n```cypher\nMATCH (s:Stream)\nRETURN s.name AS stream_name, g.name AS game_name\nORDER BY s.createdAt ASC\n```\n\nThis query matches all nodes of type `Stream` and returns the `name` of the stream and the `name` of the game it is associated with. The results are then ordered by the `createdAt` property of the stream in ascending order, ensuring that the oldest streams appear first."
        ]
    },
    {
        "question": "List the 3 movies with the lowest average ratings in the REVIEWED relationship.",
        "schema": "Node properties:\n- **Movie**\n  - `title`: STRING Example: \"The Matrix\"\n  - `votes`: INTEGER Min: 1, Max: 5259\n  - `tagline`: STRING Example: \"Welcome to the Real World\"\n  - `released`: INTEGER Min: 1975, Max: 2012\n- **Person**\n  - `born`: INTEGER Min: 1929, Max: 1996\n  - `name`: STRING Example: \"Keanu Reeves\"\nRelationship properties:\n- **ACTED_IN**\n  - `roles: LIST` Min Size: 1, Max Size: 6\n- **REVIEWED**\n  - `summary: STRING` Available options: ['Pretty funny at times', 'A solid romp', 'Silly, but fun', 'You had me at Jerry', 'An amazing journey', 'Slapstick redeemed only by the Robin Williams and ', 'Dark, but compelling', 'The coolest football movie ever', 'Fun, but a little far fetched']\n  - `rating: INTEGER` Min: 45, Max:  100\nThe relationships:\n(:Person)-[:ACTED_IN]->(:Movie)\n(:Person)-[:DIRECTED]->(:Movie)\n(:Person)-[:PRODUCED]->(:Movie)\n(:Person)-[:WROTE]->(:Movie)\n(:Person)-[:FOLLOWS]->(:Person)\n(:Person)-[:REVIEWED]->(:Movie)",
        "gold_cypher": "MATCH (m:Movie)<-[r:REVIEWED]-() WITH m, AVG(r.rating) AS avgRating RETURN m.title, avgRating ORDER BY avgRating ASC LIMIT 3",
        "database": "movies",
        "full_responses": [
            "```cypher\nMATCH (p:Person)-[r:REVIEWED]->(m:Movie)\nRETURN m.title, AVG(r.rating) AS averageRating\nORDER BY averageRating ASC\nLIMIT 3;\n```",
            "To list the 3 movies with the lowest average ratings from the `REVIEWED` relationship, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:REVIEWED]->(m:Movie)\nRETURN m.title AS Title, AVG(r.rating) AS AverageRating\nORDER BY AverageRating ASC\nLIMIT 3;\n```\n\nThis query does the following:\n- `MATCH (p:Person)-[r:REVIEWED]->(m:Movie)`: Matches all relationships of type `REVIEWED` between persons and movies.\n- `RETURN m.title AS Title, AVG(r.rating) AS AverageRating`: Selects the movie title and calculates the average rating for each movie.\n- `ORDER BY AverageRating ASC`: Orders the results by the average rating in ascending order.\n- `LIMIT 3`: Limits the results to the top 3 movies with the lowest average ratings.",
            "To list the 3 movies with the lowest average ratings in the `REVIEWED` relationship, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:REVIEWED]->(m:Movie)\nRETURN m.title, AVG(r.rating) AS averageRating\nORDER BY averageRating\nLIMIT 3;\n```\n\nThis query performs the following steps:\n1. `MATCH (p:Person)-[r:REVIEWED]->(m:Movie)`: This matches all the relationships of type `REVIEWED` between persons and movies.\n2. `RETURN m.title, AVG(r.rating) AS averageRating`: This returns the title of the movie and the average rating of the reviews.\n3. `ORDER BY averageRating`: This orders the results by the average rating in ascending order, so the lowest ratings appear first.\n4. `LIMIT 3`: This limits the result to the top 3 movies with the lowest average ratings.",
            "To list the 3 movies with the lowest average ratings in the `REVIEWED` relationship, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)-[r:REVIEWED]->(p:Person)\nRETURN m.title, AVG(r.rating) AS averageRating\nORDER BY averageRating ASC\nLIMIT 3;\n```\n\nThis query does the following:\n1. Matches all nodes and relationships related to movies and people.\n2. Filters for the `REVIEWED` relationship between `Person` and `Movie`.\n3. Calculates the average rating for each movie using the `AVG` function.\n4. Orders the results by the average rating in ascending order to get the movies with the lowest ratings at the top.\n5. Limits the results to the top 3 movies.",
            "To list the 3 movies with the lowest average ratings in the `REVIEWED` relationship, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)-[r:REVIEWED]-(p:Person)\nWITH m, avg(r.rating) AS avgRating\nORDER BY avgRating\nLIMIT 3\nRETURN m.title, avgRating\n```\n\nThis query does the following:\n1. Matches all nodes `m` of type `Movie` and all relationships `r` of type `REVIEWED`.\n2. Groups the results by movie `m` and calculates the average rating for each movie using `avg(r.rating)`.\n3. Orders the movies by their average rating in ascending order.\n4. Limits the results to the top 3 movies with the lowest average ratings.\n5. Returns the movie title and its average rating."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (p:Person)-[r:REVIEWED]->(m:Movie)\nRETURN m.title, AVG(r.rating) AS averageRating\nORDER BY averageRating ASC\nLIMIT 3;\n```",
            "To list the 3 movies with the lowest average ratings from the `REVIEWED` relationship, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:REVIEWED]->(m:Movie)\nRETURN m.title AS Title, AVG(r.rating) AS AverageRating\nORDER BY AverageRating ASC\nLIMIT 3;\n```\n\nThis query does the following:\n- `MATCH (p:Person)-[r:REVIEWED]->(m:Movie)`: Matches all relationships of type `REVIEWED` between persons and movies.\n- `RETURN m.title AS Title, AVG(r.rating) AS AverageRating`: Selects the movie title and calculates the average rating for each movie.\n- `ORDER BY AverageRating ASC`: Orders the results by the average rating in ascending order.\n- `LIMIT 3`: Limits the results to the top 3 movies with the lowest average ratings.",
            "To list the 3 movies with the lowest average ratings in the `REVIEWED` relationship, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Person)-[r:REVIEWED]->(m:Movie)\nRETURN m.title, AVG(r.rating) AS averageRating\nORDER BY averageRating\nLIMIT 3;\n```\n\nThis query performs the following steps:\n1. `MATCH (p:Person)-[r:REVIEWED]->(m:Movie)`: This matches all the relationships of type `REVIEWED` between persons and movies.\n2. `RETURN m.title, AVG(r.rating) AS averageRating`: This returns the title of the movie and the average rating of the reviews.\n3. `ORDER BY averageRating`: This orders the results by the average rating in ascending order, so the lowest ratings appear first.\n4. `LIMIT 3`: This limits the result to the top 3 movies with the lowest average ratings.",
            "To list the 3 movies with the lowest average ratings in the `REVIEWED` relationship, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)-[r:REVIEWED]->(p:Person)\nRETURN m.title, AVG(r.rating) AS averageRating\nORDER BY averageRating ASC\nLIMIT 3;\n```\n\nThis query does the following:\n1. Matches all nodes and relationships related to movies and people.\n2. Filters for the `REVIEWED` relationship between `Person` and `Movie`.\n3. Calculates the average rating for each movie using the `AVG` function.\n4. Orders the results by the average rating in ascending order to get the movies with the lowest ratings at the top.\n5. Limits the results to the top 3 movies.",
            "To list the 3 movies with the lowest average ratings in the `REVIEWED` relationship, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)-[r:REVIEWED]-(p:Person)\nWITH m, avg(r.rating) AS avgRating\nORDER BY avgRating\nLIMIT 3\nRETURN m.title, avgRating\n```\n\nThis query does the following:\n1. Matches all nodes `m` of type `Movie` and all relationships `r` of type `REVIEWED`.\n2. Groups the results by movie `m` and calculates the average rating for each movie using `avg(r.rating)`.\n3. Orders the movies by their average rating in ascending order.\n4. Limits the results to the top 3 movies with the lowest average ratings.\n5. Returns the movie title and its average rating."
        ]
    },
    {
        "question": "Which 3 products have the highest units on order?",
        "schema": "Node properties:\n- **Product**\n  - `productName`: STRING Example: \"Chai\"\n  - `quantityPerUnit`: STRING Example: \"10 boxes x 20 bags\"\n  - `unitsOnOrder`: INTEGER Min: 0, Max: 100\n  - `supplierID`: STRING Example: \"1\"\n  - `productID`: STRING Example: \"1\"\n  - `discontinued`: BOOLEAN \n  - `categoryID`: STRING Available options: ['1', '2', '7', '6', '8', '4', '3', '5']\n  - `reorderLevel`: INTEGER Min: 0, Max: 30\n  - `unitsInStock`: INTEGER Min: 0, Max: 125\n  - `unitPrice`: FLOAT Min: 2.5, Max: 263.5\n- **Category**\n  - `picture`: STRING Available options: ['0x151C2F00020000000D000E0014002100FFFFFFFF4269746D']\n  - `categoryID`: STRING Available options: ['1', '2', '3', '4', '5', '6', '7', '8']\n  - `description`: STRING Available options: ['Soft drinks, coffees, teas, beers, and ales', 'Sweet and savory sauces, relishes, spreads, and se', 'Desserts, candies, and sweet breads', 'Cheeses', 'Breads, crackers, pasta, and cereal', 'Prepared meats', 'Dried fruit and bean curd', 'Seaweed and fish']\n  - `categoryName`: STRING Available options: ['Beverages', 'Condiments', 'Confections', 'Dairy Products', 'Grains/Cereals', 'Meat/Poultry', 'Produce', 'Seafood']\n- **Supplier**\n  - `companyName`: STRING Example: \"Exotic Liquids\"\n  - `contactName`: STRING Example: \"Charlotte Cooper\"\n  - `homePage`: STRING Available options: ['NULL', '#CAJUN.HTM#', \"Mayumi's (on the World Wide Web)#http://www.micros\", '(03) 444-6588', 'Plutzer (on the World Wide Web)#http://www.microso', '(0544) 60603', '(1) 03.83.00.62', '(02) 555-4873', '(089) 6547667', '38.76.98.58']\n  - `phone`: STRING Example: \"(171) 555-2222\"\n  - `postalCode`: STRING Example: \"EC1 4SD\"\n  - `contactTitle`: STRING Example: \"Purchasing Manager\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"49 Gilbert St.\"\n  - `fax`: STRING Example: \"NULL\"\n  - `supplierID`: STRING Example: \"1\"\n  - `country`: STRING Example: \"UK\"\n  - `city`: STRING Example: \"London\"\n- **Customer**\n  - `fax`: STRING Example: \"030-0076545\"\n  - `companyName`: STRING Example: \"Alfreds Futterkiste\"\n  - `customerID`: STRING Example: \"ALFKI\"\n  - `phone`: STRING Example: \"030-0074321\"\n  - `contactName`: STRING Example: \"Maria Anders\"\n  - `contactTitle`: STRING Example: \"Sales Representative\"\n  - `region`: STRING Example: \"NULL\"\n  - `address`: STRING Example: \"Obere Str. 57\"\n  - `postalCode`: STRING Example: \"12209\"\n  - `country`: STRING Example: \"Germany\"\n  - `city`: STRING Example: \"Berlin\"\n- **Order**\n  - `shipName`: STRING Example: \"Vins et alcools Chevalier\"\n  - `requiredDate`: STRING Example: \"1996-08-01 00:00:00.000\"\n  - `shipCity`: STRING Example: \"Reims\"\n  - `employeeID`: STRING Available options: ['5', '6', '4', '3', '9', '1', '8', '2', '7']\n  - `shipPostalCode`: STRING Example: \"51100\"\n  - `shippedDate`: STRING Example: \"1996-07-16 00:00:00.000\"\n  - `freight`: STRING Example: \"32.38\"\n  - `orderDate`: STRING Example: \"1996-07-04 00:00:00.000\"\n  - `orderID`: STRING Example: \"10248\"\n  - `shipAddress`: STRING Example: \"59 rue de l'Abbaye\"\n  - `customerID`: STRING Example: \"VINET\"\n  - `shipCountry`: STRING Example: \"France\"\n  - `shipVia`: STRING Available options: ['3', '1', '2']\n  - `shipRegion`: STRING Example: \"NULL\"\nRelationship properties:\n- **ORDERS**\n  - `orderID: STRING` Example: \"10248\"\n  - `unitPrice: STRING` Example: \"34.80\"\n  - `productID: STRING` Example: \"72\"\n  - `quantity: INTEGER` Min: 1, Max:  130\n  - `discount: STRING` Example: \"0\"\nThe relationships:\n(:Product)-[:PART_OF]->(:Category)\n(:Supplier)-[:SUPPLIES]->(:Product)\n(:Customer)-[:PURCHASED]->(:Order)\n(:Order)-[:ORDERS]->(:Product)",
        "gold_cypher": "MATCH (p:Product) WHERE p.unitsOnOrder IS NOT NULL RETURN p.productName, p.unitsOnOrder ORDER BY p.unitsOnOrder DESC LIMIT 3",
        "database": "northwind",
        "full_responses": [
            "```cypher\nMATCH (p:Product)-[o:ORDERS]-(o2:Order)\nWITH p, SUM(o.quantity) AS totalUnitsOnOrder\nORDER BY totalUnitsOnOrder DESC\nLIMIT 3\nRETURN p.productName, totalUnitsOnOrder\n```",
            "To find the top 3 products with the highest units on order, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Product)-[r:ORDERS]->(o:Order)\nWHERE r.quantity > 0\nRETURN p.productName, p.unitsOnOrder\nORDER BY p.unitsOnOrder DESC\nLIMIT 3;\n```\n\nThis query matches all relationships between products and orders, filters out orders with a quantity of 0, orders the products by units on order in descending order, and returns the top 3 products with the highest units on order.",
            "```cypher\nMATCH (p:Product)-[r:PART_OF]->(c:Category)\nWITH p, r\nWHERE p.unitsOnOrder > 0\nORDER BY p.unitsOnOrder DESC\nLIMIT 3\nRETURN p.productName, p.unitsOnOrder\n```",
            "```cypher\nMATCH (p:Product)-[:PART_OF]->(c:Category)\nWHERE p.unitsOnOrder > 0\nRETURN p.productName, p.unitsOnOrder\nORDER BY p.unitsOnOrder DESC\nLIMIT 3\n```",
            "To find the 3 products with the highest units on order, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Product)-[r:PART_OF]->(c:Category)\nWITH p, r\nORDER BY p.unitsOnOrder DESC\nLIMIT 3\nRETURN p.productName, p.unitsOnOrder\n```\n\nThis query retrieves the top 3 products based on the `unitsOnOrder` property, ordered in descending order. It then selects the `productName` and `unitsOnOrder` for these products."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (p:Product)-[o:ORDERS]-(o2:Order)\nWITH p, SUM(o.quantity) AS totalUnitsOnOrder\nORDER BY totalUnitsOnOrder DESC\nLIMIT 3\nRETURN p.productName, totalUnitsOnOrder\n```",
            "To find the top 3 products with the highest units on order, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Product)-[r:ORDERS]->(o:Order)\nWHERE r.quantity > 0\nRETURN p.productName, p.unitsOnOrder\nORDER BY p.unitsOnOrder DESC\nLIMIT 3;\n```\n\nThis query matches all relationships between products and orders, filters out orders with a quantity of 0, orders the products by units on order in descending order, and returns the top 3 products with the highest units on order.",
            "```cypher\nMATCH (p:Product)-[r:PART_OF]->(c:Category)\nWITH p, r\nWHERE p.unitsOnOrder > 0\nORDER BY p.unitsOnOrder DESC\nLIMIT 3\nRETURN p.productName, p.unitsOnOrder\n```",
            "```cypher\nMATCH (p:Product)-[:PART_OF]->(c:Category)\nWHERE p.unitsOnOrder > 0\nRETURN p.productName, p.unitsOnOrder\nORDER BY p.unitsOnOrder DESC\nLIMIT 3\n```",
            "To find the 3 products with the highest units on order, you can use the following Cypher query:\n\n```cypher\nMATCH (p:Product)-[r:PART_OF]->(c:Category)\nWITH p, r\nORDER BY p.unitsOnOrder DESC\nLIMIT 3\nRETURN p.productName, p.unitsOnOrder\n```\n\nThis query retrieves the top 3 products based on the `unitsOnOrder` property, ordered in descending order. It then selects the `productName` and `unitsOnOrder` for these products."
        ]
    },
    {
        "question": "Which users are moderators of streams that play the game \"Apex Legends\"?",
        "schema": "Node properties:\n- **Stream**\n  - `createdAt`: DATE_TIME Min: 2007-05-22T10:39:53.259969Z, Max: 2021-05-09T14:16:40.370294Z\n  - `id`: STRING Example: \"129004176\"\n  - `description`: STRING Example: \"Welcome to my Channel, I'm Big Chase, 31 living in\"\n  - `url`: STRING Example: \"https://www.twitch.tv/itsbigchase\"\n  - `name`: STRING Example: \"itsbigchase\"\n  - `followers`: INTEGER Min: 0, Max: 10243195\n  - `total_view_count`: INTEGER Min: 21, Max: 1451487256\n- **Game**\n  - `name`: STRING Example: \"Rust\"\n- **Language**\n  - `name`: STRING Example: \"en\"\n- **User**\n  - `name`: STRING Example: \"itsbigchase\"\n- **Team**\n  - `createdAt`: DATE_TIME Min: 2011-10-11T23:59:43.548701Z, Max: 2021-05-07T17:19:09.946382Z\n  - `name`: STRING Example: \"ESO Stream Team\"\n  - `id`: STRING Example: \"5893\"\nRelationship properties:\n\nThe relationships:\n(:Stream)-[:PLAYS]->(:Game)\n(:Stream)-[:HAS_LANGUAGE]->(:Language)\n(:Stream)-[:MODERATOR]->(:Stream)\n(:Stream)-[:MODERATOR]->(:User)\n(:Stream)-[:CHATTER]->(:Stream)\n(:Stream)-[:CHATTER]->(:User)\n(:Stream)-[:HAS_TEAM]->(:Team)\n(:Stream)-[:VIP]->(:Stream)\n(:Stream)-[:VIP]->(:User)\n(:User)-[:CHATTER]->(:Stream)\n(:User)-[:CHATTER]->(:User)\n(:User)-[:MODERATOR]->(:Stream)\n(:User)-[:MODERATOR]->(:User)",
        "gold_cypher": "MATCH (g:Game {name: \"Apex Legends\"}) MATCH (g)<-[:PLAYS]-(s:Stream) MATCH (s)<-[:MODERATOR]-(u:User) RETURN DISTINCT u.name",
        "database": "twitch",
        "full_responses": [
            "To answer the question \"Which users are moderators of streams that play the game 'Apex Legends'?\", we need to query the Neo4j database for the following information:\n\n1. Streams that play the game \"Apex Legends\".\n2. Users who are moderators of these streams.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (stream:Stream)-[rel:PLAYS]->(game:Game {name: 'Apex Legends'})\nWHERE TYPE(rel) = 'PLAYS'\nWITH stream\nMATCH (stream)-[mod:MODERATOR]->(moderator:User)\nRETURN moderator.name\n```\n\nThis query works as follows:\n\n1. `MATCH (stream:Stream)-[rel:PLAYS]->(game:Game {name: 'Apex Legends'})`: This part finds all streams that play the game \"Apex Legends\".\n2. `WITH stream`: This clause captures the stream nodes that play \"Apex Legends\".\n3. `MATCH (stream)-[mod:MODERATOR]->(moderator:User)`: This part finds all users who are moderators of the streams that play \"Apex Legends\".\n4. `RETURN moderator.name`: This part returns the names of the moderators.\n\nThis query will return the names of all users who are moderators of streams that play the game \"Apex Legends\".",
            "```cypher\nMATCH (s:Stream)-[p:PLAYS]->(g:Game {name: \"Apex Legends\"})\nWHERE p HAS {stream: s}\nAND (s)-[:MODERATOR]->(u:User)\nRETURN u.name AS ModeratorName\n```",
            "```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game {name: \"Apex Legends\"})\nWHERE r.name = \"Moderator\"\nRETURN s.name AS StreamName, r.name AS RelationshipName, u.name AS UserName\n```",
            "To find users who are moderators of streams that play the game \"Apex Legends\", you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game {name: \"Apex Legends\"})\nMATCH (s)-[m:MODERATOR]->(u:User)\nRETURN u.name AS user_name\n```\n\nThis query does the following:\n1. `MATCH (s:Stream)-[r:PLAYS]->(g:Game {name: \"Apex Legends\"})`: This part finds all streams that play the game \"Apex Legends\".\n2. `MATCH (s)-[m:MODERATOR]->(u:User)`: This part finds all users who are moderators of these streams.\n3. `RETURN u.name AS user_name`: This part returns the names of the users who are moderators of streams that play \"Apex Legends\".",
            "To find the users who are moderators of streams that play the game \"Apex Legends\", you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[:PLAYS]->(g:Game {name: 'Apex Legends'})\nMATCH (s)-[:MODERATOR]->(u:User)\nRETURN u.name\n```\n\nThis query does the following:\n1. It matches streams (`s`) that play the game \"Apex Legends\" (`g`).\n2. It then matches the streams to their moderators (`u`).\n3. Finally, it returns the names of the users who are moderators of those streams."
        ],
        "generated_cyphers": [
            "To answer the question \"Which users are moderators of streams that play the game 'Apex Legends'?\", we need to query the Neo4j database for the following information:\n\n1. Streams that play the game \"Apex Legends\".\n2. Users who are moderators of these streams.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (stream:Stream)-[rel:PLAYS]->(game:Game {name: 'Apex Legends'})\nWHERE TYPE(rel) = 'PLAYS'\nWITH stream\nMATCH (stream)-[mod:MODERATOR]->(moderator:User)\nRETURN moderator.name\n```\n\nThis query works as follows:\n\n1. `MATCH (stream:Stream)-[rel:PLAYS]->(game:Game {name: 'Apex Legends'})`: This part finds all streams that play the game \"Apex Legends\".\n2. `WITH stream`: This clause captures the stream nodes that play \"Apex Legends\".\n3. `MATCH (stream)-[mod:MODERATOR]->(moderator:User)`: This part finds all users who are moderators of the streams that play \"Apex Legends\".\n4. `RETURN moderator.name`: This part returns the names of the moderators.\n\nThis query will return the names of all users who are moderators of streams that play the game \"Apex Legends\".",
            "```cypher\nMATCH (s:Stream)-[p:PLAYS]->(g:Game {name: \"Apex Legends\"})\nWHERE p HAS {stream: s}\nAND (s)-[:MODERATOR]->(u:User)\nRETURN u.name AS ModeratorName\n```",
            "```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game {name: \"Apex Legends\"})\nWHERE r.name = \"Moderator\"\nRETURN s.name AS StreamName, r.name AS RelationshipName, u.name AS UserName\n```",
            "To find users who are moderators of streams that play the game \"Apex Legends\", you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[r:PLAYS]->(g:Game {name: \"Apex Legends\"})\nMATCH (s)-[m:MODERATOR]->(u:User)\nRETURN u.name AS user_name\n```\n\nThis query does the following:\n1. `MATCH (s:Stream)-[r:PLAYS]->(g:Game {name: \"Apex Legends\"})`: This part finds all streams that play the game \"Apex Legends\".\n2. `MATCH (s)-[m:MODERATOR]->(u:User)`: This part finds all users who are moderators of these streams.\n3. `RETURN u.name AS user_name`: This part returns the names of the users who are moderators of streams that play \"Apex Legends\".",
            "To find the users who are moderators of streams that play the game \"Apex Legends\", you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[:PLAYS]->(g:Game {name: 'Apex Legends'})\nMATCH (s)-[:MODERATOR]->(u:User)\nRETURN u.name\n```\n\nThis query does the following:\n1. It matches streams (`s`) that play the game \"Apex Legends\" (`g`).\n2. It then matches the streams to their moderators (`u`).\n3. Finally, it returns the names of the users who are moderators of those streams."
        ]
    },
    {
        "question": "What is the sum of the sizes of the first 3 users who have a size greater than 2 and have interacted with users with an area less than 3?",
        "schema": "Node properties:\n- **User**\n  - `label`: STRING Example: \"inchristbl.bsky.social\"\n  - `key`: STRING Example: \"0\"\n  - `y`: FLOAT Example: \"6000.659\"\n  - `color`: STRING Example: \"#3CB371\"\n  - `x`: FLOAT Example: \"-4383.217\"\n  - `area`: FLOAT Example: \"2.6\"\n  - `size`: FLOAT Example: \"1.82\"\nRelationship properties:\n- **INTERACTED**\n  - `weight: INTEGER` Example: \"1\"\n  - `ogWeight: INTEGER` Example: \"1\"\n  - `size: FLOAT` Example: \"0.2\"\n  - `key: STRING` Example: \"geid_68_0\"\nThe relationships:\n(:User)-[:INTERACTED]->(:User)",
        "gold_cypher": "MATCH (u1:User)-[:INTERACTED]->(u2:User) WHERE u1.size > 2 AND u2.area < 3 WITH u1 LIMIT 3 RETURN sum(u1.size) AS total_size",
        "database": "bluesky",
        "full_responses": [
            "To answer this question, we need to follow these steps in the Cypher query:\n\n1. **Find Users with Size Greater than 2**: Start by selecting users whose size is greater than 2.\n2. **Filter Users Who Have Interacted with Users with Area Less than 3**: For each of these users, filter out those who have interacted with other users with an area less than 3.\n3. **Sum the Sizes of the First 3 Such Users**: Finally, sum the sizes of the first 3 users who meet these criteria.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (u1:User)\nWHERE u1.size > 2\nWITH u1\nMATCH (u1)-[r:INTERACTED]->(u2:User)\nWHERE u2.area < 3\nRETURN SUM(u1.size) AS total_size\nLIMIT 3\n```\n\n### Explanation:\n- **MATCH (u1:User)**: Start by matching any user node with the label `User`.\n- **WHERE u1.size > 2**: Filter users whose size is greater than 2.\n- **WITH u1**: Use a `WITH` clause to capture the users who meet the first condition.\n- **MATCH (u1)-[r:INTERACTED]->(u2:User)**: Match relationships where `u1` interacts with `u2`.\n- **WHERE u2.area < 3**: Filter the interactions where the area of `u2` is less than 3.\n- **RETURN SUM(u1.size) AS total_size**: Sum the sizes of the users and return the total sum as `total_size`.\n- **LIMIT 3**: Limit the result to the first 3 users who meet the criteria.",
            "To answer the question, you need to perform a few steps: filter users based on their size, filter users who have interacted with others, filter users based on the area of the interacted users, and then sum the sizes of the first 3 users that meet all these criteria.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (u1:User)\nWHERE u1.size > 2\nWITH u1, u1.x, u1.y, u1.color, u1.area, u1.size AS u1Size\nOPTIONAL MATCH (u1)-[:INTERACTED]->(u2:User)\nWHERE u2.area < 3\nWITH u1, u1.x, u1.y, u1.color, u1.area, u1Size, COLLECT(u2) AS interactedUsers\nUNWIND interactedUsers AS interactedUser\nWITH u1, u1.x, u1.y, u1.color, u1.area, u1Size, interactedUser\nWHERE NOT EXISTS (\n    MATCH (u1)-[:INTERACTED]->(interactedUser)\n    WHERE NOT EXISTS (\n        MATCH (u2:User)-[:INTERACTED]->(interactedUser)\n        WHERE NOT EXISTS (\n            MATCH (u3:User)-[:INTERACTED]->(u2)\n            WHERE u3.area < 3\n        )\n    )\n)\nRETURN u1Size\nORDER BY u1Size DESC\nLIMIT 3\n```\n\n### Explanation:\n1. **MATCH (u1:User):** This matches all users with a size greater than 2.\n2. **WITH u1, u1.x, u1.y, u1.color, u1.area, u1Size:** This extracts the necessary properties of the user and stores the size in a variable `u1Size`.\n3. **OPTIONAL MATCH (u1)-[:INTERACTED]->(u2:User):** This finds users who interacted with other users.\n4. **WHERE u2.area < 3:** This filters the interacted users to have an area less than 3.\n5. **UNWIND interactedUsers AS interactedUser:** This iterates over the interacted users.\n6. **WITH u1, u1.x, u1.y, u1.color, u1.area, u1Size, interactedUser:** This extracts the necessary properties of the user and the interacted user.\n7. **WHERE NOT EXISTS (...) AND NOT EXISTS (...) AND NOT EXISTS (...):** This ensures that the user has interacted with users who have interacted with other users with an area less than 3. The innermost `NOT EXISTS` ensures that no user has interacted with a user who has interacted with another user with an area less than 3, and so on.\n8. **RETURN u1Size ORDER BY u1Size DESC LIMIT 3:** This returns the sizes of the first 3 users that meet all the criteria, ordered by size in descending order.",
            "```cypher\nMATCH (u:User)\nWHERE u.size > 2 AND u.area < 3\nWITH u\nORDER BY u.size DESC\nLIMIT 3\nRETURN sum(u.size) AS total_size\n```",
            "```cypher\nMATCH (u1:User)-[r:INTERACTED]->(u2:User)\nWHERE u1.size > 2 AND u2.area < 3\nWITH u1, SUM(r.size) AS sizeSum\nORDER BY u1.size DESC\nLIMIT 3\nRETURN sizeSum\n```",
            "To answer this question, we need to find the first 3 users who have a size greater than 2 and have interacted with users with an area less than 3. We then sum up the sizes of these users.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (u1:User)-[r:INTERACTED]->(u2:User)\nWHERE u1.size > 2 AND u2.area < 3\nWITH u1, u2, r.size AS interactionSize\nORDER BY interactionSize DESC\nLIMIT 3\nRETURN sum(interactionSize)\n```\n\nThis query does the following:\n1. Matches relationships where `u1` interacts with `u2`.\n2. Filters the users based on the specified conditions (`u1.size > 2` and `u2.area < 3`).\n3. Selects the interaction size for each relationship.\n4. Orders the users by the interaction size in descending order.\n5. Limits the result to the first 3 users.\n6. Returns the sum of their interaction sizes."
        ],
        "generated_cyphers": [
            "To answer this question, we need to follow these steps in the Cypher query:\n\n1. **Find Users with Size Greater than 2**: Start by selecting users whose size is greater than 2.\n2. **Filter Users Who Have Interacted with Users with Area Less than 3**: For each of these users, filter out those who have interacted with other users with an area less than 3.\n3. **Sum the Sizes of the First 3 Such Users**: Finally, sum the sizes of the first 3 users who meet these criteria.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (u1:User)\nWHERE u1.size > 2\nWITH u1\nMATCH (u1)-[r:INTERACTED]->(u2:User)\nWHERE u2.area < 3\nRETURN SUM(u1.size) AS total_size\nLIMIT 3\n```\n\n### Explanation:\n- **MATCH (u1:User)**: Start by matching any user node with the label `User`.\n- **WHERE u1.size > 2**: Filter users whose size is greater than 2.\n- **WITH u1**: Use a `WITH` clause to capture the users who meet the first condition.\n- **MATCH (u1)-[r:INTERACTED]->(u2:User)**: Match relationships where `u1` interacts with `u2`.\n- **WHERE u2.area < 3**: Filter the interactions where the area of `u2` is less than 3.\n- **RETURN SUM(u1.size) AS total_size**: Sum the sizes of the users and return the total sum as `total_size`.\n- **LIMIT 3**: Limit the result to the first 3 users who meet the criteria.",
            "To answer the question, you need to perform a few steps: filter users based on their size, filter users who have interacted with others, filter users based on the area of the interacted users, and then sum the sizes of the first 3 users that meet all these criteria.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (u1:User)\nWHERE u1.size > 2\nWITH u1, u1.x, u1.y, u1.color, u1.area, u1.size AS u1Size\nOPTIONAL MATCH (u1)-[:INTERACTED]->(u2:User)\nWHERE u2.area < 3\nWITH u1, u1.x, u1.y, u1.color, u1.area, u1Size, COLLECT(u2) AS interactedUsers\nUNWIND interactedUsers AS interactedUser\nWITH u1, u1.x, u1.y, u1.color, u1.area, u1Size, interactedUser\nWHERE NOT EXISTS (\n    MATCH (u1)-[:INTERACTED]->(interactedUser)\n    WHERE NOT EXISTS (\n        MATCH (u2:User)-[:INTERACTED]->(interactedUser)\n        WHERE NOT EXISTS (\n            MATCH (u3:User)-[:INTERACTED]->(u2)\n            WHERE u3.area < 3\n        )\n    )\n)\nRETURN u1Size\nORDER BY u1Size DESC\nLIMIT 3\n```\n\n### Explanation:\n1. **MATCH (u1:User):** This matches all users with a size greater than 2.\n2. **WITH u1, u1.x, u1.y, u1.color, u1.area, u1Size:** This extracts the necessary properties of the user and stores the size in a variable `u1Size`.\n3. **OPTIONAL MATCH (u1)-[:INTERACTED]->(u2:User):** This finds users who interacted with other users.\n4. **WHERE u2.area < 3:** This filters the interacted users to have an area less than 3.\n5. **UNWIND interactedUsers AS interactedUser:** This iterates over the interacted users.\n6. **WITH u1, u1.x, u1.y, u1.color, u1.area, u1Size, interactedUser:** This extracts the necessary properties of the user and the interacted user.\n7. **WHERE NOT EXISTS (...) AND NOT EXISTS (...) AND NOT EXISTS (...):** This ensures that the user has interacted with users who have interacted with other users with an area less than 3. The innermost `NOT EXISTS` ensures that no user has interacted with a user who has interacted with another user with an area less than 3, and so on.\n8. **RETURN u1Size ORDER BY u1Size DESC LIMIT 3:** This returns the sizes of the first 3 users that meet all the criteria, ordered by size in descending order.",
            "```cypher\nMATCH (u:User)\nWHERE u.size > 2 AND u.area < 3\nWITH u\nORDER BY u.size DESC\nLIMIT 3\nRETURN sum(u.size) AS total_size\n```",
            "```cypher\nMATCH (u1:User)-[r:INTERACTED]->(u2:User)\nWHERE u1.size > 2 AND u2.area < 3\nWITH u1, SUM(r.size) AS sizeSum\nORDER BY u1.size DESC\nLIMIT 3\nRETURN sizeSum\n```",
            "To answer this question, we need to find the first 3 users who have a size greater than 2 and have interacted with users with an area less than 3. We then sum up the sizes of these users.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (u1:User)-[r:INTERACTED]->(u2:User)\nWHERE u1.size > 2 AND u2.area < 3\nWITH u1, u2, r.size AS interactionSize\nORDER BY interactionSize DESC\nLIMIT 3\nRETURN sum(interactionSize)\n```\n\nThis query does the following:\n1. Matches relationships where `u1` interacts with `u2`.\n2. Filters the users based on the specified conditions (`u1.size > 2` and `u2.area < 3`).\n3. Selects the interaction size for each relationship.\n4. Orders the users by the interaction size in descending order.\n5. Limits the result to the first 3 users.\n6. Returns the sum of their interaction sizes."
        ]
    },
    {
        "question": "Who are the characters with the lowest book45PageRank?",
        "schema": "Node properties:\n- **Character**\n  - `centrality`: FLOAT Min: 0.0, Max: 1.0\n  - `book45PageRank`: FLOAT Min: 0.15000000000000002, Max: 11.409916274911177\n  - `fastrf_embedding`: LIST Min Size: 10, Max Size: 10\n  - `book1BetweennessCentrality`: FLOAT Min: 0.0, Max: 4638.53495125504\n  - `book1PageRank`: FLOAT Min: 0.15000000000000002, Max: 8.164174336296284\n  - `louvain`: INTEGER Min: 0, Max: 10\n  - `community`: INTEGER Min: 504, Max: 795\n  - `degree`: FLOAT Min: 0.0, Max: 300.0\n  - `name`: STRING Example: \"Addam-Marbrand\"\n  - `pagerank`: FLOAT Min: 0.15000000000000002, Max: 9.473142454730429\nRelationship properties:\n- **INTERACTS**\n  - `weight: INTEGER` Min: 3, Max:  334\n- **INTERACTS1**\n  - `weight: INTEGER` Min: 3, Max:  291\n  - `book: INTEGER` Min: 1, Max:  1\n- **INTERACTS2**\n  - `weight: INTEGER` Min: 3, Max:  92\n  - `book: INTEGER` Min: 2, Max:  2\n- **INTERACTS3**\n  - `weight: INTEGER` Min: 3, Max:  95\n  - `book: INTEGER` Min: 3, Max:  3\n- **INTERACTS45**\n  - `weight: INTEGER` Min: 3, Max:  96\n  - `book: INTEGER` Min: 45, Max:  45\nThe relationships:\n(:Character)-[:INTERACTS45]->(:Character)\n(:Character)-[:INTERACTS]->(:Character)\n(:Character)-[:INTERACTS1]->(:Character)\n(:Character)-[:INTERACTS3]->(:Character)\n(:Character)-[:INTERACTS2]->(:Character)",
        "gold_cypher": "MATCH (c:Character) WHERE c.book45PageRank IS NOT NULL RETURN c.name, c.book45PageRank ORDER BY c.book45PageRank ASC LIMIT 1",
        "database": "gameofthrones",
        "full_responses": [
            "To find the characters with the lowest `book45PageRank`, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name, c.book45PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 1\n```\n\nThis query will return the character with the lowest `book45PageRank`. If you want to find all characters with the same lowest `book45PageRank`, you can modify the query to include the `LIMIT` clause:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name, c.book45PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 10\n```\n\nThis will return the top 10 characters with the lowest `book45PageRank`. Adjust the `LIMIT` value as needed to find more or fewer characters.",
            "To answer the question \"Who are the characters with the lowest book45PageRank? \", you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name AS CharacterName, c.book45PageRank AS PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 1;\n```\n\nThis query selects the character with the lowest `book45PageRank` and returns their name along with the page rank. The `ORDER BY` clause sorts the characters by `book45PageRank` in ascending order, and the `LIMIT 1` ensures that only the character with the lowest page rank is returned.",
            "To find the characters with the lowest `book45PageRank`, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name, c.book45PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 1;\n```\n\nThis query selects the `name` and `book45PageRank` of the character with the lowest `book45PageRank` from the `Character` nodes, ordering the results in ascending order by `book45PageRank` and limiting the result to the top one. If you want to find all characters with the lowest `book45PageRank`, you can remove the `LIMIT 1` clause:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name, c.book45PageRank\nORDER BY c.book45PageRank ASC;\n```",
            "To find the characters with the lowest `book45PageRank`, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nORDER BY c.book45PageRank ASC\nLIMIT 1\n```\n\nThis query will return the character with the lowest `book45PageRank`. The `ORDER BY` clause sorts the characters in ascending order based on their `book45PageRank`, and the `LIMIT 1` clause ensures that only the top result (i.e., the character with the lowest `book45PageRank`) is returned.",
            "To find the characters with the lowest `book45PageRank`, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name AS CharacterName, c.book45PageRank AS Book45PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 1\n```\n\nThis query selects the character with the lowest `book45PageRank` by ordering the characters by their `book45PageRank` in ascending order and limiting the results to the top entry."
        ],
        "generated_cyphers": [
            "To find the characters with the lowest `book45PageRank`, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name, c.book45PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 1\n```\n\nThis query will return the character with the lowest `book45PageRank`. If you want to find all characters with the same lowest `book45PageRank`, you can modify the query to include the `LIMIT` clause:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name, c.book45PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 10\n```\n\nThis will return the top 10 characters with the lowest `book45PageRank`. Adjust the `LIMIT` value as needed to find more or fewer characters.",
            "To answer the question \"Who are the characters with the lowest book45PageRank? \", you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name AS CharacterName, c.book45PageRank AS PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 1;\n```\n\nThis query selects the character with the lowest `book45PageRank` and returns their name along with the page rank. The `ORDER BY` clause sorts the characters by `book45PageRank` in ascending order, and the `LIMIT 1` ensures that only the character with the lowest page rank is returned.",
            "To find the characters with the lowest `book45PageRank`, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name, c.book45PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 1;\n```\n\nThis query selects the `name` and `book45PageRank` of the character with the lowest `book45PageRank` from the `Character` nodes, ordering the results in ascending order by `book45PageRank` and limiting the result to the top one. If you want to find all characters with the lowest `book45PageRank`, you can remove the `LIMIT 1` clause:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name, c.book45PageRank\nORDER BY c.book45PageRank ASC;\n```",
            "To find the characters with the lowest `book45PageRank`, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nORDER BY c.book45PageRank ASC\nLIMIT 1\n```\n\nThis query will return the character with the lowest `book45PageRank`. The `ORDER BY` clause sorts the characters in ascending order based on their `book45PageRank`, and the `LIMIT 1` clause ensures that only the top result (i.e., the character with the lowest `book45PageRank`) is returned.",
            "To find the characters with the lowest `book45PageRank`, you can use the following Cypher query:\n\n```cypher\nMATCH (c:Character)\nRETURN c.name AS CharacterName, c.book45PageRank AS Book45PageRank\nORDER BY c.book45PageRank ASC\nLIMIT 1\n```\n\nThis query selects the character with the lowest `book45PageRank` by ordering the characters by their `book45PageRank` in ascending order and limiting the results to the top entry."
        ]
    },
    {
        "question": "List the first 3 filings that originated from an entity in China.",
        "schema": "Node properties:\n- **Country**\n  - `location`: POINT \n  - `code`: STRING Example: \"AFG\"\n  - `name`: STRING Example: \"Afghanistan\"\n  - `tld`: STRING Example: \"AF\"\n- **Filing**\n  - `begin`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-09-05T00:00:00Z\n  - `end`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-11-03T00:00:00Z\n  - `originator_bank_id`: STRING Example: \"cimb-bank-berhad\"\n  - `sar_id`: STRING Example: \"3297\"\n  - `beneficiary_bank`: STRING Example: \"Barclays Bank Plc\"\n  - `filer_org_name_id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `originator_bank_country`: STRING Example: \"Singapore\"\n  - `beneficiary_bank_country`: STRING Example: \"United Kingdom\"\n  - `filer_org_name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `originator_iso`: STRING Example: \"SGP\"\n  - `beneficiary_bank_id`: STRING Example: \"barclays-bank-plc-london-england-gbr\"\n  - `origin_lat`: STRING Example: \"1.3667\"\n  - `origin_lng`: STRING Example: \"103.8\"\n  - `end_date_format`: STRING Example: \"2015-09-25T00:00:00Z\"\n  - `begin_date_format`: STRING Example: \"2015-03-25T00:00:00Z\"\n  - `originator_bank`: STRING Example: \"CIMB Bank Berhad\"\n  - `beneficiary_lat`: STRING Example: \"54\"\n  - `beneficiary_iso`: STRING Example: \"GBR\"\n  - `beneficiary_lng`: STRING Example: \"-2\"\n  - `begin_date`: STRING Example: \"Mar 25, 2015\"\n  - `id`: STRING Example: \"223254\"\n  - `end_date`: STRING Example: \"Sep 25, 2015\"\n  - `amount`: INTEGER Min: 1.18, Max: 2721000000\n  - `number`: INTEGER Min: 1, Max: 174\n- **Entity**\n  - `id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `location`: POINT \n  - `name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `country`: STRING Example: \"CHN\"\nRelationship properties:\n\nThe relationships:\n(:Filing)-[:BENEFITS]->(:Entity)\n(:Filing)-[:CONCERNS]->(:Entity)\n(:Filing)-[:ORIGINATOR]->(:Entity)\n(:Entity)-[:FILED]->(:Filing)\n(:Entity)-[:COUNTRY]->(:Country)",
        "gold_cypher": "MATCH (e:Entity)-[:COUNTRY]->(c:Country {code: \"CHN\"}) MATCH (f:Filing)-[:ORIGINATOR]->(e) RETURN f ORDER BY f.begin LIMIT 3",
        "database": "fincen",
        "full_responses": [
            "To list the first 3 filings that originated from an entity in China, you can use the following Cypher query:\n\n```cypher\nMATCH (entity:Entity)-[originator:FILING]-[beneficiary:CONCERNS]->(beneficiary_entity:Entity)\nWHERE entity.country = 'CHN'\nRETURN originator AS filing\nORDER BY originator.begin ASC\nLIMIT 3;\n```\n\nThis query does the following:\n- Matches entities in China (`entity.country = 'CHN'`).\n- Finds filings (`:FILING`) that originated from these entities (`-[:ORIGINATOR]->(entity)`) and concern another entity (`-[:CONCERNS]->(beneficiary_entity)`).\n- Returns the first 3 filings based on their `begin` date in ascending order.",
            "```cypher\nMATCH (e:Entity)-[:ORIGINATOR]->(f:Filing)\nWHERE e.country = 'CHN'\nRETURN f ORDER BY f.begin LIMIT 3\n```",
            "```cypher\nMATCH (e:Entity)-[r:FILED]->(f:Filing)\nWHERE e.country = 'CHN'\nRETURN f.id, f.begin_date_format, f.end_date_format, f.amount\nORDER BY f.begin_date ASC\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Entity)-[:COUNTRY]->(c:Country {name: 'China'})\nWITH f\nMATCH (f)-[r:FILING]->(filings)\nRETURN filings\nORDER BY filings.begin ASC\nLIMIT 3\n```",
            "Certainly! To list the first 3 filings that originated from an entity in China, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity)-[r:FILER]->(f:Filing)\nWHERE e.country = 'CHN'\nRETURN f\nLIMIT 3\n```\n\nThis query does the following:\n1. Matches entities (`e`) that are related to filings (`f`) through the `FILER` relationship.\n2. Filters the entities to only include those from China (`e.country = 'CHN'`).\n3. Returns the first 3 filings that meet these criteria."
        ],
        "generated_cyphers": [
            "To list the first 3 filings that originated from an entity in China, you can use the following Cypher query:\n\n```cypher\nMATCH (entity:Entity)-[originator:FILING]-[beneficiary:CONCERNS]->(beneficiary_entity:Entity)\nWHERE entity.country = 'CHN'\nRETURN originator AS filing\nORDER BY originator.begin ASC\nLIMIT 3;\n```\n\nThis query does the following:\n- Matches entities in China (`entity.country = 'CHN'`).\n- Finds filings (`:FILING`) that originated from these entities (`-[:ORIGINATOR]->(entity)`) and concern another entity (`-[:CONCERNS]->(beneficiary_entity)`).\n- Returns the first 3 filings based on their `begin` date in ascending order.",
            "```cypher\nMATCH (e:Entity)-[:ORIGINATOR]->(f:Filing)\nWHERE e.country = 'CHN'\nRETURN f ORDER BY f.begin LIMIT 3\n```",
            "```cypher\nMATCH (e:Entity)-[r:FILED]->(f:Filing)\nWHERE e.country = 'CHN'\nRETURN f.id, f.begin_date_format, f.end_date_format, f.amount\nORDER BY f.begin_date ASC\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Entity)-[:COUNTRY]->(c:Country {name: 'China'})\nWITH f\nMATCH (f)-[r:FILING]->(filings)\nRETURN filings\nORDER BY filings.begin ASC\nLIMIT 3\n```",
            "Certainly! To list the first 3 filings that originated from an entity in China, you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity)-[r:FILER]->(f:Filing)\nWHERE e.country = 'CHN'\nRETURN f\nLIMIT 3\n```\n\nThis query does the following:\n1. Matches entities (`e`) that are related to filings (`f`) through the `FILER` relationship.\n2. Filters the entities to only include those from China (`e.country = 'CHN'`).\n3. Returns the first 3 filings that meet these criteria."
        ]
    },
    {
        "question": "What are the top 3 questions with the highest scores of comments?",
        "schema": "Node properties:\n- **Question**\n  - `link`: STRING Example: \"https://stackoverflow.com/q/65697972\"\n  - `accepted_answer_id`: INTEGER Min: 61447621, Max: 69272967\n  - `creation_date`: INTEGER Min: 1587746198, Max: 1632249176\n  - `view_count`: INTEGER Min: 4, Max: 1851\n  - `answer_count`: INTEGER Min: 0, Max: 4\n  - `body_markdown`: STRING Example: \"I want to create a graph from my recursive JSON fi\"\n  - `uuid`: INTEGER Min: 61413144, Max: 69273945\n  - `title`: STRING Example: \"Create graph from recursive JSON data using apoc.l\"\n- **User**\n  - `uuid`: INTEGER Min: deleted, Max: 16922964\n  - `display_name`: STRING Example: \"schernichkin\"\n- **Tag**\n  - `name`: STRING Example: \"neo4j\"\n  - `link`: STRING Example: \"https://stackoverflow.com/questions/tagged/neo4j\"\n- **Answer**\n  - `link`: STRING Example: \"https://stackoverflow.com/a/69272967\"\n  - `title`: STRING Example: \"Return &#39;biggest fan of a tag&#39; neo4j\"\n  - `is_accepted`: BOOLEAN \n  - `body_markdown`: STRING Example: \"The error is here:    ```  WHERE COUNT(posted) &lt\"\n  - `score`: INTEGER Min: -2, Max: 6\n  - `uuid`: INTEGER Min: 61445468, Max: 69273049\n- **Comment**\n  - `score`: INTEGER Min: 0, Max: 3\n  - `uuid`: INTEGER Min: 108645245, Max: 122427099\n  - `link`: STRING Example: \"https://stackoverflow.com/questions/69208813/confi\"\nRelationship properties:\n\nThe relationships:\n(:Question)-[:TAGGED]->(:Tag)\n(:User)-[:ASKED]->(:Question)\n(:User)-[:COMMENTED]->(:Comment)\n(:User)-[:PROVIDED]->(:Answer)\n(:Answer)-[:ANSWERED]->(:Question)\n(:Comment)-[:COMMENTED_ON]->(:Question)",
        "gold_cypher": "MATCH (q:Question)<-[:COMMENTED_ON]-(c:Comment) WITH q, sum(c.score) AS totalScore ORDER BY totalScore DESC LIMIT 3 RETURN q",
        "database": "stackoverflow2",
        "full_responses": [
            "To answer the question \"What are the top 3 questions with the highest scores of comments?\", you can use the following Cypher query. This query calculates the total score of comments for each question and then orders the results to find the top 3 questions with the highest comment scores.\n\n```cypher\nMATCH (q:Question)-[c:COMMENTED_ON]->(c:Comment)\nWITH q, SUM(c.score) AS totalCommentScore\nORDER BY totalCommentScore DESC\nLIMIT 3\n```\n\nThis query does the following:\n- Matches all nodes of type `Question` and the relationship type `COMMENTED_ON`.\n- Sums up the `score` property of all comments associated with each question.\n- Orders the results by the total comment score in descending order.\n- Limits the output to the top 3 questions with the highest comment scores.",
            "To find the top 3 questions with the highest scores of comments, you can use the following Cypher query. This query calculates the average score of comments for each question and then orders the results by this average score in descending order to get the top questions.\n\n```cypher\nMATCH (q:Question)\nWITH q, avg(c.score) AS comment_score\nWHERE comment_score IS NOT NULL\nORDER BY comment_score DESC\nLIMIT 3;\n```\n\nThis query works as follows:\n1. **MATCH (q:Question)**: Matches all nodes of type `Question`.\n2. **WITH q, avg(c.score) AS comment_score**: For each `Question`, calculates the average score of comments. This is done by joining the `Question` node with the `Comment` node through the `COMMENTED_ON` relationship and calculating the average score of the comments.\n3. **WHERE comment_score IS NOT NULL**: Filters out any questions that do not have any comments.\n4. **ORDER BY comment_score DESC**: Orders the questions by the average comment score in descending order.\n5. **LIMIT 3**: Limits the results to the top 3 questions based on the comment score.",
            "```cypher\nMATCH (q:Question)-[r:COMMENTED_ON]-(c:Comment)\nRETURN q.title, q.link, count(*) AS comment_count, avg(c.score) AS average_comment_score\nORDER BY comment_count DESC, average_comment_score DESC\nLIMIT 3\n```",
            "To answer the question \"What are the top 3 questions with the highest scores of comments?\", you can use the following Cypher query:\n\n```cypher\nMATCH (q:Question)-[c:COMMENTED_ON]->(c:Comment)\nRETURN q.link, COUNT(c) AS comment_count, SUM(c.score) AS total_score\nORDER BY total_score DESC\nLIMIT 3;\n```\n\nThis query performs the following steps:\n1. It matches all nodes and relationships related to comments on questions.\n2. It returns the `link` of the question, the count of comments, and the total score of those comments.\n3. It orders the results by the total score in descending order to get the questions with the highest scores at the top.\n4. It limits the results to the top 3 questions.",
            "To find the top 3 questions with the highest scores of comments, you can use the following Cypher query. This query joins the `Comment` node with the `Question` node through the `COMMENTED_ON` relationship, groups the results by question, and orders them by the total score of comments in descending order. The top 3 results are returned.\n\n```cypher\nMATCH (c:Comment)-[r:COMMENTED_ON]->(q:Question)\nWITH q, SUM(c.score) AS totalCommentScore\nORDER BY totalCommentScore DESC\nLIMIT 3\nRETURN q.title, q.link, totalCommentScore;\n```\n\nThis query does the following:\n- `MATCH (c:Comment)-[r:COMMENTED_ON]->(q:Question)`: Matches all comments and the questions they are associated with.\n- `WITH q, SUM(c.score) AS totalCommentScore`: Groups the results by question and calculates the total score of comments for each question.\n- `ORDER BY totalCommentScore DESC`: Orders the questions by the total comment score in descending order.\n- `LIMIT 3`: Limits the results to the top 3 questions with the highest scores.\n- `RETURN q.title, q.link, totalCommentScore`: Returns the title, link, and total comment score for the top 3 questions."
        ],
        "generated_cyphers": [
            "To answer the question \"What are the top 3 questions with the highest scores of comments?\", you can use the following Cypher query. This query calculates the total score of comments for each question and then orders the results to find the top 3 questions with the highest comment scores.\n\n```cypher\nMATCH (q:Question)-[c:COMMENTED_ON]->(c:Comment)\nWITH q, SUM(c.score) AS totalCommentScore\nORDER BY totalCommentScore DESC\nLIMIT 3\n```\n\nThis query does the following:\n- Matches all nodes of type `Question` and the relationship type `COMMENTED_ON`.\n- Sums up the `score` property of all comments associated with each question.\n- Orders the results by the total comment score in descending order.\n- Limits the output to the top 3 questions with the highest comment scores.",
            "To find the top 3 questions with the highest scores of comments, you can use the following Cypher query. This query calculates the average score of comments for each question and then orders the results by this average score in descending order to get the top questions.\n\n```cypher\nMATCH (q:Question)\nWITH q, avg(c.score) AS comment_score\nWHERE comment_score IS NOT NULL\nORDER BY comment_score DESC\nLIMIT 3;\n```\n\nThis query works as follows:\n1. **MATCH (q:Question)**: Matches all nodes of type `Question`.\n2. **WITH q, avg(c.score) AS comment_score**: For each `Question`, calculates the average score of comments. This is done by joining the `Question` node with the `Comment` node through the `COMMENTED_ON` relationship and calculating the average score of the comments.\n3. **WHERE comment_score IS NOT NULL**: Filters out any questions that do not have any comments.\n4. **ORDER BY comment_score DESC**: Orders the questions by the average comment score in descending order.\n5. **LIMIT 3**: Limits the results to the top 3 questions based on the comment score.",
            "```cypher\nMATCH (q:Question)-[r:COMMENTED_ON]-(c:Comment)\nRETURN q.title, q.link, count(*) AS comment_count, avg(c.score) AS average_comment_score\nORDER BY comment_count DESC, average_comment_score DESC\nLIMIT 3\n```",
            "To answer the question \"What are the top 3 questions with the highest scores of comments?\", you can use the following Cypher query:\n\n```cypher\nMATCH (q:Question)-[c:COMMENTED_ON]->(c:Comment)\nRETURN q.link, COUNT(c) AS comment_count, SUM(c.score) AS total_score\nORDER BY total_score DESC\nLIMIT 3;\n```\n\nThis query performs the following steps:\n1. It matches all nodes and relationships related to comments on questions.\n2. It returns the `link` of the question, the count of comments, and the total score of those comments.\n3. It orders the results by the total score in descending order to get the questions with the highest scores at the top.\n4. It limits the results to the top 3 questions.",
            "To find the top 3 questions with the highest scores of comments, you can use the following Cypher query. This query joins the `Comment` node with the `Question` node through the `COMMENTED_ON` relationship, groups the results by question, and orders them by the total score of comments in descending order. The top 3 results are returned.\n\n```cypher\nMATCH (c:Comment)-[r:COMMENTED_ON]->(q:Question)\nWITH q, SUM(c.score) AS totalCommentScore\nORDER BY totalCommentScore DESC\nLIMIT 3\nRETURN q.title, q.link, totalCommentScore;\n```\n\nThis query does the following:\n- `MATCH (c:Comment)-[r:COMMENTED_ON]->(q:Question)`: Matches all comments and the questions they are associated with.\n- `WITH q, SUM(c.score) AS totalCommentScore`: Groups the results by question and calculates the total score of comments for each question.\n- `ORDER BY totalCommentScore DESC`: Orders the questions by the total comment score in descending order.\n- `LIMIT 3`: Limits the results to the top 3 questions with the highest scores.\n- `RETURN q.title, q.link, totalCommentScore`: Returns the title, link, and total comment score for the top 3 questions."
        ]
    },
    {
        "question": "Retrieve the first 3 filings where the beneficiary bank country is 'United Kingdom' and the amount is above 100000.",
        "schema": "Node properties:\n- **Country**\n  - `location`: POINT \n  - `code`: STRING Example: \"AFG\"\n  - `name`: STRING Example: \"Afghanistan\"\n  - `tld`: STRING Example: \"AF\"\n- **Filing**\n  - `begin`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-09-05T00:00:00Z\n  - `end`: DATE_TIME Min: 2000-02-08T00:00:00Z, Max: 2017-11-03T00:00:00Z\n  - `originator_bank_id`: STRING Example: \"cimb-bank-berhad\"\n  - `sar_id`: STRING Example: \"3297\"\n  - `beneficiary_bank`: STRING Example: \"Barclays Bank Plc\"\n  - `filer_org_name_id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `originator_bank_country`: STRING Example: \"Singapore\"\n  - `beneficiary_bank_country`: STRING Example: \"United Kingdom\"\n  - `filer_org_name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `originator_iso`: STRING Example: \"SGP\"\n  - `beneficiary_bank_id`: STRING Example: \"barclays-bank-plc-london-england-gbr\"\n  - `origin_lat`: STRING Example: \"1.3667\"\n  - `origin_lng`: STRING Example: \"103.8\"\n  - `end_date_format`: STRING Example: \"2015-09-25T00:00:00Z\"\n  - `begin_date_format`: STRING Example: \"2015-03-25T00:00:00Z\"\n  - `originator_bank`: STRING Example: \"CIMB Bank Berhad\"\n  - `beneficiary_lat`: STRING Example: \"54\"\n  - `beneficiary_iso`: STRING Example: \"GBR\"\n  - `beneficiary_lng`: STRING Example: \"-2\"\n  - `begin_date`: STRING Example: \"Mar 25, 2015\"\n  - `id`: STRING Example: \"223254\"\n  - `end_date`: STRING Example: \"Sep 25, 2015\"\n  - `amount`: INTEGER Min: 1.18, Max: 2721000000\n  - `number`: INTEGER Min: 1, Max: 174\n- **Entity**\n  - `id`: STRING Example: \"the-bank-of-new-york-mellon-corp\"\n  - `location`: POINT \n  - `name`: STRING Example: \"The Bank of New York Mellon Corp.\"\n  - `country`: STRING Example: \"CHN\"\nRelationship properties:\n\nThe relationships:\n(:Filing)-[:BENEFITS]->(:Entity)\n(:Filing)-[:CONCERNS]->(:Entity)\n(:Filing)-[:ORIGINATOR]->(:Entity)\n(:Entity)-[:FILED]->(:Filing)\n(:Entity)-[:COUNTRY]->(:Country)",
        "gold_cypher": "MATCH (f:Filing) WHERE f.beneficiary_bank_country = 'United Kingdom' AND f.amount > 100000 RETURN f ORDER BY f.begin LIMIT 3",
        "database": "fincen",
        "full_responses": [
            "```cypher\nMATCH (f:Filing)-[:BENEFITS]->(e:Entity)-[:COUNTRY]->(c:Country)\nWHERE c.name = 'United Kingdom' AND f.amount > 100000\nRETURN f\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Filing)-[:BENEFITS]->(b:Entity)\nWHERE b.country = 'United Kingdom' AND f.amount > 100000\nRETURN f\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Filing)-[r:BENEFITS]->(e:Entity)\nWHERE e.country = 'United Kingdom' AND f.amount > 100000\nRETURN f\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Filing)-[:BENEFITS]->(e:Entity)\nWHERE e.country = 'United Kingdom' AND f.amount > 100000\nRETURN f\nORDER BY f.begin ASC\nLIMIT 3\n```",
            "Certainly! Below is the Cypher query to retrieve the first 3 filings where the beneficiary bank country is 'United Kingdom' and the amount is above 100,000.\n\n```cypher\nMATCH (f:Filing)-[:BENEFITS]->(e:Entity)\nWHERE e.country = 'United Kingdom' AND f.amount > 100000\nRETURN f\nORDER BY f.begin ASC\nLIMIT 3\n```\n\nThis query uses a `MATCH` clause to find all relationships between `Filing` and `Entity` where the `Entity` has a country of 'United Kingdom' and the `Filing` has an amount greater than 100,000. It then orders the results by the `begin` date in ascending order and limits the results to the first 3 entries."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (f:Filing)-[:BENEFITS]->(e:Entity)-[:COUNTRY]->(c:Country)\nWHERE c.name = 'United Kingdom' AND f.amount > 100000\nRETURN f\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Filing)-[:BENEFITS]->(b:Entity)\nWHERE b.country = 'United Kingdom' AND f.amount > 100000\nRETURN f\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Filing)-[r:BENEFITS]->(e:Entity)\nWHERE e.country = 'United Kingdom' AND f.amount > 100000\nRETURN f\nLIMIT 3\n```",
            "```cypher\nMATCH (f:Filing)-[:BENEFITS]->(e:Entity)\nWHERE e.country = 'United Kingdom' AND f.amount > 100000\nRETURN f\nORDER BY f.begin ASC\nLIMIT 3\n```",
            "Certainly! Below is the Cypher query to retrieve the first 3 filings where the beneficiary bank country is 'United Kingdom' and the amount is above 100,000.\n\n```cypher\nMATCH (f:Filing)-[:BENEFITS]->(e:Entity)\nWHERE e.country = 'United Kingdom' AND f.amount > 100000\nRETURN f\nORDER BY f.begin ASC\nLIMIT 3\n```\n\nThis query uses a `MATCH` clause to find all relationships between `Filing` and `Entity` where the `Entity` has a country of 'United Kingdom' and the `Filing` has an amount greater than 100,000. It then orders the results by the `begin` date in ascending order and limits the results to the first 3 entries."
        ]
    },
    {
        "question": "Show the 3 streams with the most users as chatters.",
        "schema": "Node properties:\n- **Stream**\n  - `createdAt`: DATE_TIME Min: 2007-05-22T10:39:53.259969Z, Max: 2021-05-09T14:16:40.370294Z\n  - `id`: STRING Example: \"129004176\"\n  - `description`: STRING Example: \"Welcome to my Channel, I'm Big Chase, 31 living in\"\n  - `url`: STRING Example: \"https://www.twitch.tv/itsbigchase\"\n  - `name`: STRING Example: \"itsbigchase\"\n  - `followers`: INTEGER Min: 0, Max: 10243195\n  - `total_view_count`: INTEGER Min: 21, Max: 1451487256\n- **Game**\n  - `name`: STRING Example: \"Rust\"\n- **Language**\n  - `name`: STRING Example: \"en\"\n- **User**\n  - `name`: STRING Example: \"itsbigchase\"\n- **Team**\n  - `createdAt`: DATE_TIME Min: 2011-10-11T23:59:43.548701Z, Max: 2021-05-07T17:19:09.946382Z\n  - `name`: STRING Example: \"ESO Stream Team\"\n  - `id`: STRING Example: \"5893\"\nRelationship properties:\n\nThe relationships:\n(:Stream)-[:PLAYS]->(:Game)\n(:Stream)-[:HAS_LANGUAGE]->(:Language)\n(:Stream)-[:MODERATOR]->(:Stream)\n(:Stream)-[:MODERATOR]->(:User)\n(:Stream)-[:CHATTER]->(:Stream)\n(:Stream)-[:CHATTER]->(:User)\n(:Stream)-[:HAS_TEAM]->(:Team)\n(:Stream)-[:VIP]->(:Stream)\n(:Stream)-[:VIP]->(:User)\n(:User)-[:CHATTER]->(:Stream)\n(:User)-[:CHATTER]->(:User)\n(:User)-[:MODERATOR]->(:Stream)\n(:User)-[:MODERATOR]->(:User)",
        "gold_cypher": "MATCH (s:Stream)<-[:CHATTER]-(u:User) RETURN s.name AS stream, count(u) AS chatter_count ORDER BY chatter_count DESC LIMIT 3",
        "database": "twitch",
        "full_responses": [
            "To show the 3 streams with the most users as chatters, you can use the following Cypher query. This query calculates the total number of chatters for each stream and then orders the results by the number of chatters in descending order to get the top 3 streams.\n\n```cypher\nMATCH (s:Stream)-[r:CHATTER]->(u:User)\nWITH s, COUNT(DISTINCT u) AS chatterCount\nRETURN s, chatterCount\nORDER BY chatterCount DESC\nLIMIT 3;\n```\n\nThis query works as follows:\n- It matches all relationships of type `CHATTER` between streams and users.\n- It groups the results by each stream and counts the distinct users for each stream using `COUNT(DISTINCT u)`.\n- It returns the stream and the number of chatters for each stream.\n- It orders the results by the number of chatters in descending order to get the top 3 streams.\n- Finally, it limits the results to the top 3 streams.",
            "```cypher\nMATCH (s:Stream)-[r:CHATTER]->(u:User)\nWITH s, COUNT(u) AS chatterCount\nORDER BY chatterCount DESC\nLIMIT 3;\n```",
            "To find the 3 streams with the most users as chatters, you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[:CHATTER]->(u:User)\nGROUP BY s.name, s.id, s.createdAt, s.description, s.url, s.name, s.followers, s.total_view_count\nORDER BY COUNT(u) DESC\nLIMIT 3\n```\n\nThis query does the following:\n1. Matches all streams (`:Stream`) that are chatted by users (`:User`).\n2. Groups the results by the stream's properties.\n3. Orders the groups by the count of users in descending order.\n4. Limits the result to the top 3 streams with the most chatters.",
            "To show the 3 streams with the most users as chatters, you can use the following Cypher query. This query calculates the total number of chatters for each stream and then orders them in descending order to find the streams with the most chatters.\n\n```cypher\nMATCH (s:Stream)-[r:CHATTER]->(u:User)\nWITH s, COUNT(u) AS chatterCount\nORDER BY chatterCount DESC\nLIMIT 3\nRETURN s, chatterCount;\n```\n\n### Explanation:\n- `MATCH (s:Stream)-[r:CHATTER]->(u:User)`: This pattern matches all the relationships where a stream (`s`) is a chatter (`u`).\n- `WITH s, COUNT(u) AS chatterCount`: This clause collects each stream and counts the number of chatters for that stream, storing the result in the `chatterCount` variable.\n- `ORDER BY chatterCount DESC`: This orders the streams by the number of chatters in descending order, so the streams with the most chatters come first.\n- `LIMIT 3`: This limits the results to the top 3 streams with the most chatters.\n- `RETURN s, chatterCount`: This returns the stream and the count of chatters for each of the top 3 streams.",
            "```cypher\nMATCH (stream:Stream)-[:CHATTER]->(user:User)\nWITH stream, count(user) AS chatter_count\nORDER BY chatter_count DESC\nLIMIT 3\nRETURN stream.id AS stream_id, stream.name AS stream_name, chatter_count AS chatter_count\n```"
        ],
        "generated_cyphers": [
            "To show the 3 streams with the most users as chatters, you can use the following Cypher query. This query calculates the total number of chatters for each stream and then orders the results by the number of chatters in descending order to get the top 3 streams.\n\n```cypher\nMATCH (s:Stream)-[r:CHATTER]->(u:User)\nWITH s, COUNT(DISTINCT u) AS chatterCount\nRETURN s, chatterCount\nORDER BY chatterCount DESC\nLIMIT 3;\n```\n\nThis query works as follows:\n- It matches all relationships of type `CHATTER` between streams and users.\n- It groups the results by each stream and counts the distinct users for each stream using `COUNT(DISTINCT u)`.\n- It returns the stream and the number of chatters for each stream.\n- It orders the results by the number of chatters in descending order to get the top 3 streams.\n- Finally, it limits the results to the top 3 streams.",
            "```cypher\nMATCH (s:Stream)-[r:CHATTER]->(u:User)\nWITH s, COUNT(u) AS chatterCount\nORDER BY chatterCount DESC\nLIMIT 3;\n```",
            "To find the 3 streams with the most users as chatters, you can use the following Cypher query:\n\n```cypher\nMATCH (s:Stream)-[:CHATTER]->(u:User)\nGROUP BY s.name, s.id, s.createdAt, s.description, s.url, s.name, s.followers, s.total_view_count\nORDER BY COUNT(u) DESC\nLIMIT 3\n```\n\nThis query does the following:\n1. Matches all streams (`:Stream`) that are chatted by users (`:User`).\n2. Groups the results by the stream's properties.\n3. Orders the groups by the count of users in descending order.\n4. Limits the result to the top 3 streams with the most chatters.",
            "To show the 3 streams with the most users as chatters, you can use the following Cypher query. This query calculates the total number of chatters for each stream and then orders them in descending order to find the streams with the most chatters.\n\n```cypher\nMATCH (s:Stream)-[r:CHATTER]->(u:User)\nWITH s, COUNT(u) AS chatterCount\nORDER BY chatterCount DESC\nLIMIT 3\nRETURN s, chatterCount;\n```\n\n### Explanation:\n- `MATCH (s:Stream)-[r:CHATTER]->(u:User)`: This pattern matches all the relationships where a stream (`s`) is a chatter (`u`).\n- `WITH s, COUNT(u) AS chatterCount`: This clause collects each stream and counts the number of chatters for that stream, storing the result in the `chatterCount` variable.\n- `ORDER BY chatterCount DESC`: This orders the streams by the number of chatters in descending order, so the streams with the most chatters come first.\n- `LIMIT 3`: This limits the results to the top 3 streams with the most chatters.\n- `RETURN s, chatterCount`: This returns the stream and the count of chatters for each of the top 3 streams.",
            "```cypher\nMATCH (stream:Stream)-[:CHATTER]->(user:User)\nWITH stream, count(user) AS chatter_count\nORDER BY chatter_count DESC\nLIMIT 3\nRETURN stream.id AS stream_id, stream.name AS stream_name, chatter_count AS chatter_count\n```"
        ]
    },
    {
        "question": "Which entities have a note stating 'Closed date stands for Cancelled date.'?",
        "schema": "Node properties:\n- **Entity**\n  - `countries`: STRING Example: \"Hong Kong\"\n  - `ibcRUC`: STRING Example: \"25221\"\n  - `valid_until`: STRING Example: \"The Panama Papers data is current through 2015\"\n  - `country_codes`: STRING Example: \"HKG\"\n  - `service_provider`: STRING Available options: ['Appleby', 'Portcullis Trustnet', 'Mossack Fonseca', 'Commonwealth Trust Limited']\n  - `address`: STRING Example: \"ORION HOUSE SERVICES (HK) LIMITED ROOM 1401; 14/F.\"\n  - `inactivation_date`: STRING Example: \"18-FEB-2013\"\n  - `struck_off_date`: STRING Example: \"15-FEB-2013\"\n  - `status`: STRING Example: \"Defaulted\"\n  - `jurisdiction_description`: STRING Example: \"Samoa\"\n  - `incorporation_date`: STRING Example: \"23-MAR-2006\"\n  - `original_name`: STRING Example: \"TIANSHENG INDUSTRY AND TRADING CO., LTD.\"\n  - `jurisdiction`: STRING Example: \"SAM\"\n  - `name`: STRING Example: \"TIANSHENG INDUSTRY AND TRADING CO., LTD.\"\n  - `internal_id`: STRING Example: \"1001256\"\n  - `lastEditTimestamp`: STRING Example: \"1638311020926\"\n  - `node_id`: INTEGER Min: 10000001, Max: 10000005\n  - `sourceID`: STRING Example: \"Panama Papers\"\n  - `former_name`: STRING \n  - `company_type`: STRING \n  - `tax_stat_description`: STRING \n  - `note`: STRING \n  - `dorm_date`: STRING \n  - `type`: STRING \n  - `closed_date`: STRING \n  - `company_number`: STRING \n  - `comments`: STRING \n  - `entity_number`: STRING \n- **Intermediary**\n  - `countries`: STRING Example: \"South Africa\"\n  - `lastEditTimestamp`: STRING Example: \"1638311034131\"\n  - `address`: STRING Example: \"MICHAEL PAPAGEORGE; MR. 106 NICHOLSON STREET BROOK\"\n  - `valid_until`: STRING Example: \"The Panama Papers  data is current through 2015\"\n  - `country_codes`: STRING Example: \"ZAF\"\n  - `name`: STRING Example: \"MICHAEL PAPAGEORGE, MR.\"\n  - `status`: STRING Available options: ['UNRECOVERABLE ACCOUNTS', 'CLIENT IN REPRESENTATIVE TERRITORY', 'ACTIVE', 'INACTIVE', 'SUSPENDED', 'DELINQUENT', 'PROSPECT', 'SUSPENDED LEGAL', 'ACTIVE LEGAL']\n  - `node_id`: INTEGER Min: 11000001, Max: 11000005\n  - `sourceID`: STRING Available options: ['Pandora Papers - Alem\u00e1n, Cordero, Galindo & Lee (Alcogal)', 'Paradise Papers - Appleby', 'Paradise Papers - Barbados corporate registry', 'Bahamas Leaks', 'Panama Papers', 'Paradise Papers - Nevis corporate registry', 'Paradise Papers - Bahamas corporate registry', 'Offshore Leaks', 'Paradise Papers - Aruba corporate registry']\n  - `internal_id`: STRING Example: \"10001\"\n  - `registered_office`: STRING \n- **Officer**\n  - `valid_until`: STRING Example: \"The Panama Papers data is current through 2015\"\n  - `name`: STRING Example: \"KIM SOO IN\"\n  - `sourceID`: STRING Example: \"Panama Papers\"\n  - `icij_id`: STRING Example: \"E72326DEA50F1A9C2876E112AAEB42BC\"\n  - `node_id`: INTEGER Min: 12000001, Max: 12000005\n  - `lastEditTimestamp`: STRING Example: \"1638311034062\"\n  - `country_codes`: STRING Example: \"KOR\"\n  - `countries`: STRING Example: \"South Korea\"\n  - `note`: STRING \n- **Address**\n  - `original_address`: STRING Example: \"ANNEX FREDERICK & SHIRLEY STS, P. O. BOX N-4805 NA\"\n  - `lastEditTimestamp`: STRING Example: \"1638311020926\"\n  - `countries`: STRING Example: \"Bahamas\"\n  - `address`: STRING Example: \"ANNEX FREDERICK & SHIRLEY STS, P.O. BOX N-4805, NA\"\n  - `valid_until`: STRING Example: \"The Bahamas Leaks data is current through early 20\"\n  - `icij_id`: STRING Example: \"7C1AAD6896EFDED57D680B82E7ADF7AB\"\n  - `node_id`: INTEGER Min: 24000001, Max: 24000005\n  - `sourceID`: STRING Example: \"Bahamas Leaks\"\n  - `country_codes`: STRING Example: \"BHS\"\n  - `name`: STRING \n  - `addressID`: STRING \n  - `country_code`: STRING \n  - `country`: STRING \n- **Other**\n  - `lastEditTimestamp`: STRING Available options: ['1638311068329', '1638311074502', '1638311074946', '1638311075268', '1638311075503']\n  - `incorporation_date`: STRING Example: \"18-MAY-1983\"\n  - `struck_off_date`: STRING Example: \"31-DEC-2002\"\n  - `jurisdiction`: STRING Available options: ['AW']\n  - `jurisdiction_description`: STRING Available options: ['Aruba']\n  - `valid_until`: STRING Available options: ['Aruba corporate registry data is current through 2', 'Appleby data is current through 2014']\n  - `sourceID`: STRING Available options: ['Paradise Papers - Aruba corporate registry', 'Paradise Papers - Appleby']\n  - `name`: STRING Example: \"ANTAM ENTERPRISES N.V.\"\n  - `type`: STRING Available options: ['LIMITED LIABILITY COMPANY', 'SOLE OWNERSHIP', 'FOREIGN FORMED CORPORATION']\n  - `node_id`: INTEGER Min: 80000012, Max: 85050056\n  - `closed_date`: STRING Example: \"28-NOV-2012\"\n  - `note`: STRING Available options: ['Closed date stands for Cancelled date.', 'Closed date stands for Liquidation date.']\n  - `countries`: STRING Example: \"Bermuda;Isle of Man\"\n  - `country_codes`: STRING Example: \"BMU;IMN\"\nRelationship properties:\n- **registered_address**\n  - `link: STRING` Example: \"registered address\"\n  - `sourceID: STRING` Example: \"Panama Papers\"\n  - `valid_until: STRING` \n- **intermediary_of**\n  - `valid_until: STRING` Example: \"The Panama Papers data is current through 2015\"\n  - `sourceID: STRING` Example: \"Panama Papers\"\n  - `link: STRING` Example: \"intermediary of\"\n  - `end_date: STRING` \n  - `start_date: STRING` \n- **officer_of**\n  - `link: STRING` Example: \"shareholder of\"\n  - `valid_until: STRING` Example: \"The Panama Papers data is current through 2015\"\n  - `sourceID: STRING` Example: \"Panama Papers\"\n  - `start_date: STRING` Example: \"19-NOV-1999\"\n  - `end_date: STRING` Example: \"04-JUL-2000\"\n  - `status: STRING` \n- **similar**\n  - `link: STRING` Example: \"similar name and address as\"\n- **same_as**\n  - `link: STRING` Available options: ['same name and registration date as', 'same address as', 'same as']\n- **same_name_as**\n  - `sourceID: STRING` Example: \"Bahamas Leaks\"\n  - `link: STRING` Example: \"same name as\"\n  - `valid_until: STRING` Example: \"The Bahamas Leaks data is current through early 20\"\n- **same_company_as**\n  - `valid_until: STRING` Example: \"The Bahamas Leaks data is current through early 20\"\n  - `sourceID: STRING` Example: \"Bahamas Leaks\"\n  - `link: STRING` Example: \"same company as\"\n- **same_id_as**\n  - `sourceID: STRING` Available options: ['Paradise Papers - Malta corporate registry']\n  - `link: STRING` Available options: ['same id as']\n  - `valid_until: STRING` Available options: ['Malta corporate registry data is current through 2']\n- **connected_to**\n  - `valid_until: STRING` Example: \"Aruba corporate registry data is current through 2\"\n  - `link: STRING` Example: \"connected to\"\n  - `sourceID: STRING` Example: \"Paradise Papers - Aruba corporate registry\"\nThe relationships:\n(:Entity)-[:same_as]->(:Entity)\n(:Entity)-[:registered_address]->(:Address)\n(:Entity)-[:same_company_as]->(:Entity)\n(:Entity)-[:same_name_as]->(:Other)\n(:Entity)-[:same_name_as]->(:Entity)\n(:Intermediary)-[:intermediary_of]->(:Entity)\n(:Intermediary)-[:registered_address]->(:Address)\n(:Intermediary)-[:officer_of]->(:Entity)\n(:Intermediary)-[:similar]->(:Officer)\n(:Intermediary)-[:same_name_as]->(:Intermediary)\n(:Intermediary)-[:same_name_as]->(:Officer)\n(:Intermediary)-[:same_as]->(:Officer)\n(:Officer)-[:officer_of]->(:Entity)\n(:Officer)-[:officer_of]->(:Other)\n(:Officer)-[:registered_address]->(:Address)\n(:Officer)-[:similar]->(:Officer)\n(:Officer)-[:similar]->(:Intermediary)\n(:Officer)-[:same_name_as]->(:Officer)\n(:Officer)-[:connected_to]->(:Entity)\n(:Officer)-[:same_id_as]->(:Officer)\n(:Address)-[:same_as]->(:Address)\n(:Other)-[:registered_address]->(:Address)\n(:Other)-[:connected_to]->(:Entity)\n(:Other)-[:same_name_as]->(:Entity)\n(:Other)-[:same_name_as]->(:Officer)\n(:Other)-[:same_name_as]->(:Other)",
        "gold_cypher": "MATCH (e:Other) WHERE e.note = 'Closed date stands for Cancelled date.' RETURN e.name AS entity_name, e.node_id AS entity_id",
        "database": "offshoreleaks",
        "full_responses": [
            "```cypher\nMATCH (e:Other {note: 'Closed date stands for Cancelled date.'})\nRETURN e.name, e.company_number, e.jurisdiction, e.entity_number\n```",
            "To find entities that have a note stating 'Closed date stands for Cancelled date.', you can use the following Cypher query:\n\n```cypher\nMATCH (e:Other {note: 'Closed date stands for Cancelled date.'})\nRETURN e.name AS entity_name, e.company_number AS company_number, e.company_type AS company_type, e.type AS entity_type\n```\n\nThis query matches nodes of type `Other` where the `note` property is 'Closed date stands for Cancelled date.' and returns the `name`, `company_number`, `company_type`, and `entity_type` of these entities.",
            "To answer the question \"Which entities have a note stating 'Closed date stands for Cancelled date.'?\", you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity)\nWHERE e.note = 'Closed date stands for Cancelled date.'\nRETURN e.name\n```\n\nThis query matches all nodes of type `Entity` where the `note` property is equal to 'Closed date stands for Cancelled date.' and returns the `name` property of these entities.",
            "To answer the question \"Which entities have a note stating 'Closed date stands for Cancelled date.'?\", we need to query the Neo4j database for entities that have the `note` property set to \"Closed date stands for Cancelled date.\" Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (e:Entity {note: \"Closed date stands for Cancelled date.\"})\nRETURN e.name\n```\n\nThis query uses the `MATCH` clause to find all nodes of type `Entity` where the `note` property matches the specified string. The `RETURN` clause then selects and returns the `name` property of these nodes.",
            "To answer the question \"Which entities have a note stating 'Closed date stands for Cancelled date.'?\", you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity {note: 'Closed date stands for Cancelled date.'})\nRETURN e.name\n```\n\nThis query matches all nodes of type `Entity` where the `note` property is exactly 'Closed date stands for Cancelled date.' and returns the `name` of those entities."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (e:Other {note: 'Closed date stands for Cancelled date.'})\nRETURN e.name, e.company_number, e.jurisdiction, e.entity_number\n```",
            "To find entities that have a note stating 'Closed date stands for Cancelled date.', you can use the following Cypher query:\n\n```cypher\nMATCH (e:Other {note: 'Closed date stands for Cancelled date.'})\nRETURN e.name AS entity_name, e.company_number AS company_number, e.company_type AS company_type, e.type AS entity_type\n```\n\nThis query matches nodes of type `Other` where the `note` property is 'Closed date stands for Cancelled date.' and returns the `name`, `company_number`, `company_type`, and `entity_type` of these entities.",
            "To answer the question \"Which entities have a note stating 'Closed date stands for Cancelled date.'?\", you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity)\nWHERE e.note = 'Closed date stands for Cancelled date.'\nRETURN e.name\n```\n\nThis query matches all nodes of type `Entity` where the `note` property is equal to 'Closed date stands for Cancelled date.' and returns the `name` property of these entities.",
            "To answer the question \"Which entities have a note stating 'Closed date stands for Cancelled date.'?\", we need to query the Neo4j database for entities that have the `note` property set to \"Closed date stands for Cancelled date.\" Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (e:Entity {note: \"Closed date stands for Cancelled date.\"})\nRETURN e.name\n```\n\nThis query uses the `MATCH` clause to find all nodes of type `Entity` where the `note` property matches the specified string. The `RETURN` clause then selects and returns the `name` property of these nodes.",
            "To answer the question \"Which entities have a note stating 'Closed date stands for Cancelled date.'?\", you can use the following Cypher query:\n\n```cypher\nMATCH (e:Entity {note: 'Closed date stands for Cancelled date.'})\nRETURN e.name\n```\n\nThis query matches all nodes of type `Entity` where the `note` property is exactly 'Closed date stands for Cancelled date.' and returns the `name` of those entities."
        ]
    },
    {
        "question": "Which sources are used in the top 5 most favorited tweets?",
        "schema": "Node properties:\n- **User**\n  - `betweenness`: FLOAT Example: \"3.49332601E8\"\n  - `location`: STRING Example: \"Graphs Are Everywhere\"\n  - `followers`: INTEGER Example: \"34507\"\n  - `following`: INTEGER Example: \"10124\"\n  - `profile_image_url`: STRING Example: \"http://pbs.twimg.com/profile_images/11837552737537\"\n  - `screen_name`: STRING Example: \"neo4j\"\n  - `name`: STRING Example: \"Neo4j\"\n  - `url`: STRING Example: \"https://t.co/JSIaZFJEaE\"\n  - `statuses`: INTEGER Example: \"512\"\n- **Me**\n  - `profile_image_url`: STRING Available options: ['http://pbs.twimg.com/profile_images/11837552737537']\n  - `betweenness`: FLOAT Min: 3.49332601E8, Max: 3.49332601E8\n  - `following`: INTEGER Min: 10124, Max: 10124\n  - `url`: STRING Available options: ['https://t.co/JSIaZFJEaE']\n  - `location`: STRING Available options: ['Graphs Are Everywhere']\n  - `followers`: INTEGER Min: 34507, Max: 34507\n  - `screen_name`: STRING Available options: ['neo4j']\n  - `name`: STRING Available options: ['Neo4j']\n- **Tweet**\n  - `created_at`: DATE_TIME Min: 2020-12-06T05:12:02Z, Max: 2021-03-16T15:30:07Z\n  - `id`: INTEGER Min: 690028662083612672, Max: 1371846247913512966\n  - `id_str`: STRING Example: \"1371815021265747970\"\n  - `text`: STRING Example: \"Proud to help @educationgovuk deliver critical ser\"\n  - `favorites`: INTEGER Min: 0, Max: 394\n  - `import_method`: STRING Available options: ['user']\n- **Hashtag**\n  - `name`: STRING Example: \"education\"\n- **Link**\n  - `url`: STRING Example: \"https://twitter.com/i/web/status/13718150212657479\"\n- **Source**\n  - `name`: STRING Example: \"Buffer\"\nRelationship properties:\n- **SIMILAR_TO**\n  - `score: FLOAT` Min: 0.0030581039755351682, Max:  1.0\nThe relationships:\n(:User)-[:FOLLOWS]->(:User)\n(:User)-[:FOLLOWS]->(:Me)\n(:User)-[:POSTS]->(:Tweet)\n(:User)-[:INTERACTS_WITH]->(:User)\n(:User)-[:SIMILAR_TO]->(:User)\n(:User)-[:SIMILAR_TO]->(:Me)\n(:Me)-[:FOLLOWS]->(:User)\n(:Me)-[:POSTS]->(:Tweet)\n(:Me)-[:INTERACTS_WITH]->(:User)\n(:Me)-[:RT_MENTIONS]->(:User)\n(:Me)-[:AMPLIFIES]->(:User)\n(:Tweet)-[:MENTIONS]->(:User)\n(:Tweet)-[:MENTIONS]->(:Me)\n(:Tweet)-[:USING]->(:Source)\n(:Tweet)-[:TAGS]->(:Hashtag)\n(:Tweet)-[:CONTAINS]->(:Link)\n(:Tweet)-[:RETWEETS]->(:Tweet)\n(:Tweet)-[:REPLY_TO]->(:Tweet)",
        "gold_cypher": "MATCH (t:Tweet)-[:USING]->(s:Source) RETURN s.name AS SourceName, t.favorites AS Favorites ORDER BY t.favorites DESC LIMIT 5",
        "database": "twitter",
        "full_responses": [
            "To answer this question, we need to find the sources used in the top 5 most favorited tweets and then list the unique sources from those tweets. Here's a step-by-step breakdown of how to derive the Cypher query:\n\n1. **Identify the relevant entities and relationships**:\n   - `Tweet` (id, text, favorites)\n   - `Source` (name)\n   - `Using` (tweet_id, source_name)\n\n2. **Filter tweets by the number of favorites**:\n   - Use the `ORDER BY` clause to sort tweets by their number of favorites in descending order.\n   - Use the `LIMIT` clause to get the top 5 tweets.\n\n3. **Extract the source names from the `Using` relationships**:\n   - Use the `MATCH` clause to match the top 5 tweets with their corresponding `Using` relationships.\n   - Use the `SELECT` clause to extract the `source_name` from the `Using` relationships.\n\n4. **Ensure unique source names**:\n   - Use the `COLLECT` clause to collect all the source names from the `Using` relationships.\n   - Use the `UNIQUE` function to remove duplicates.\n\nHere's the Cypher query that implements the above logic:\n\n```cypher\nMATCH (t:Tweet)-[r:USING]-(s:Source)\nWHERE r.score > 0.0030581039755351682\nORDER BY t.favorites DESC\nLIMIT 5\nRETURN UNIQUE s.name\n```\n\nThis query will return the unique source names used in the top 5 most favorited tweets.",
            "To answer this question, you need to retrieve the unique sources used in the top 5 most favorited tweets. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (t:Tweet)-[u:USING]->(s:Source)\nWHERE t.favorites >= 5\nWITH t, s\nORDER BY t.favorites DESC\nLIMIT 5\nUNIQUE s\nRETURN s.name AS SourceName\n```\n\n### Explanation:\n1. **MATCH (t:Tweet)-[u:USING]->(s:Source)**: This pattern matches all tweets (`t`) that have a `USING` relationship with a source (`s`).\n2. **WHERE t.favorites >= 5**: This filters the tweets to only include those with 5 or more favorites.\n3. **WITH t, s**: This clause collects the matched tweets and sources together for further processing.\n4. **ORDER BY t.favorites DESC**: This orders the tweets by the number of favorites in descending order, ensuring the most favorited tweets are first.\n5. **LIMIT 5**: This limits the results to the top 5 tweets.\n6. **UNIQUE s**: This ensures that only unique sources are returned, regardless of how many times they are used in the top 5 tweets.\n7. **RETURN s.name AS SourceName**: This returns the name of the sources used in the top 5 most favorited tweets.",
            "To answer the question \"Which sources are used in the top 5 most favorited tweets?\", you can use the following Cypher query. This query will find the top 5 most favorited tweets and then identify the unique sources used in those tweets.\n\n```cypher\nMATCH (t:Tweet)-[us:USING]->(s:Source)\nWHERE t.favorites > 0\nWITH t, s\nORDER BY t.favorites DESC\nLIMIT 5\nRETURN DISTINCT s.name\n```\n\nThis query does the following:\n1. `MATCH (t:Tweet)-[us:USING]->(s:Source)`: Matches all tweets that have a `USING` relationship to a `Source`.\n2. `WHERE t.favorites > 0`: Filters out tweets that have zero or fewer favorites.\n3. `WITH t, s`: Collects the tweets and sources in a single result set.\n4. `ORDER BY t.favorites DESC`: Orders the tweets by their favorites count in descending order.\n5. `LIMIT 5`: Limits the result to the top 5 tweets.\n6. `RETURN DISTINCT s.name`: Returns the distinct names of the sources used in these top 5 tweets.",
            "To answer the question \"Which sources are used in the top 5 most favorited tweets?\", we need to follow these steps:\n\n1. Find the top 5 most favorited tweets.\n2. Extract the sources used in those tweets.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (t:Tweet)-[s:USING]->(sr:Source)\nWITH t, s, COUNT(t) AS tweet_count\nORDER BY tweet_count DESC\nLIMIT 5\nRETURN sr.name;\n```\n\n### Explanation:\n- `MATCH (t:Tweet)-[s:USING]->(sr:Source)`: This pattern matches any tweet (`t`) and the source (`sr`) used in that tweet.\n- `WITH t, s, COUNT(t) AS tweet_count`: This clause collects the tweet (`t`), source (`s`), and counts the occurrences of each tweet (`tweet_count`).\n- `ORDER BY tweet_count DESC`: This orders the results by the count of tweets in descending order, so the most favorited tweets come first.\n- `LIMIT 5`: This limits the results to the top 5 tweets.\n- `RETURN sr.name`: This returns the name of the source used in the top 5 most favorited tweets.",
            "To answer the question \"Which sources are used in the top 5 most favorited tweets?\", we need to query the database to find the top 5 most favorite tweets and then determine the sources used in those tweets. Here's a Cypher query to achieve this:\n\n```cypher\nMATCH (t:Tweet)-[:USING]->(s:Source)\nWHERE t.favorites > 0\nRETURN s.name\nORDER BY t.favorites DESC\nLIMIT 5;\n```\n\n### Explanation:\n1. **MATCH (t:Tweet)-[:USING]->(s:Source)**: This part of the query matches tweets that have a `USING` relationship with a source.\n2. **WHERE t.favorites > 0**: This filters the tweets to include only those with a non-zero number of favorites.\n3. **RETURN s.name**: This returns the name of the source used in each tweet.\n4. **ORDER BY t.favorites DESC**: This orders the results by the number of favorites in descending order, so the top tweets come first.\n5. **LIMIT 5**: This limits the results to the top 5 tweets."
        ],
        "generated_cyphers": [
            "To answer this question, we need to find the sources used in the top 5 most favorited tweets and then list the unique sources from those tweets. Here's a step-by-step breakdown of how to derive the Cypher query:\n\n1. **Identify the relevant entities and relationships**:\n   - `Tweet` (id, text, favorites)\n   - `Source` (name)\n   - `Using` (tweet_id, source_name)\n\n2. **Filter tweets by the number of favorites**:\n   - Use the `ORDER BY` clause to sort tweets by their number of favorites in descending order.\n   - Use the `LIMIT` clause to get the top 5 tweets.\n\n3. **Extract the source names from the `Using` relationships**:\n   - Use the `MATCH` clause to match the top 5 tweets with their corresponding `Using` relationships.\n   - Use the `SELECT` clause to extract the `source_name` from the `Using` relationships.\n\n4. **Ensure unique source names**:\n   - Use the `COLLECT` clause to collect all the source names from the `Using` relationships.\n   - Use the `UNIQUE` function to remove duplicates.\n\nHere's the Cypher query that implements the above logic:\n\n```cypher\nMATCH (t:Tweet)-[r:USING]-(s:Source)\nWHERE r.score > 0.0030581039755351682\nORDER BY t.favorites DESC\nLIMIT 5\nRETURN UNIQUE s.name\n```\n\nThis query will return the unique source names used in the top 5 most favorited tweets.",
            "To answer this question, you need to retrieve the unique sources used in the top 5 most favorited tweets. Here's the Cypher query to achieve this:\n\n```cypher\nMATCH (t:Tweet)-[u:USING]->(s:Source)\nWHERE t.favorites >= 5\nWITH t, s\nORDER BY t.favorites DESC\nLIMIT 5\nUNIQUE s\nRETURN s.name AS SourceName\n```\n\n### Explanation:\n1. **MATCH (t:Tweet)-[u:USING]->(s:Source)**: This pattern matches all tweets (`t`) that have a `USING` relationship with a source (`s`).\n2. **WHERE t.favorites >= 5**: This filters the tweets to only include those with 5 or more favorites.\n3. **WITH t, s**: This clause collects the matched tweets and sources together for further processing.\n4. **ORDER BY t.favorites DESC**: This orders the tweets by the number of favorites in descending order, ensuring the most favorited tweets are first.\n5. **LIMIT 5**: This limits the results to the top 5 tweets.\n6. **UNIQUE s**: This ensures that only unique sources are returned, regardless of how many times they are used in the top 5 tweets.\n7. **RETURN s.name AS SourceName**: This returns the name of the sources used in the top 5 most favorited tweets.",
            "To answer the question \"Which sources are used in the top 5 most favorited tweets?\", you can use the following Cypher query. This query will find the top 5 most favorited tweets and then identify the unique sources used in those tweets.\n\n```cypher\nMATCH (t:Tweet)-[us:USING]->(s:Source)\nWHERE t.favorites > 0\nWITH t, s\nORDER BY t.favorites DESC\nLIMIT 5\nRETURN DISTINCT s.name\n```\n\nThis query does the following:\n1. `MATCH (t:Tweet)-[us:USING]->(s:Source)`: Matches all tweets that have a `USING` relationship to a `Source`.\n2. `WHERE t.favorites > 0`: Filters out tweets that have zero or fewer favorites.\n3. `WITH t, s`: Collects the tweets and sources in a single result set.\n4. `ORDER BY t.favorites DESC`: Orders the tweets by their favorites count in descending order.\n5. `LIMIT 5`: Limits the result to the top 5 tweets.\n6. `RETURN DISTINCT s.name`: Returns the distinct names of the sources used in these top 5 tweets.",
            "To answer the question \"Which sources are used in the top 5 most favorited tweets?\", we need to follow these steps:\n\n1. Find the top 5 most favorited tweets.\n2. Extract the sources used in those tweets.\n\nHere's the Cypher query to achieve this:\n\n```cypher\nMATCH (t:Tweet)-[s:USING]->(sr:Source)\nWITH t, s, COUNT(t) AS tweet_count\nORDER BY tweet_count DESC\nLIMIT 5\nRETURN sr.name;\n```\n\n### Explanation:\n- `MATCH (t:Tweet)-[s:USING]->(sr:Source)`: This pattern matches any tweet (`t`) and the source (`sr`) used in that tweet.\n- `WITH t, s, COUNT(t) AS tweet_count`: This clause collects the tweet (`t`), source (`s`), and counts the occurrences of each tweet (`tweet_count`).\n- `ORDER BY tweet_count DESC`: This orders the results by the count of tweets in descending order, so the most favorited tweets come first.\n- `LIMIT 5`: This limits the results to the top 5 tweets.\n- `RETURN sr.name`: This returns the name of the source used in the top 5 most favorited tweets.",
            "To answer the question \"Which sources are used in the top 5 most favorited tweets?\", we need to query the database to find the top 5 most favorite tweets and then determine the sources used in those tweets. Here's a Cypher query to achieve this:\n\n```cypher\nMATCH (t:Tweet)-[:USING]->(s:Source)\nWHERE t.favorites > 0\nRETURN s.name\nORDER BY t.favorites DESC\nLIMIT 5;\n```\n\n### Explanation:\n1. **MATCH (t:Tweet)-[:USING]->(s:Source)**: This part of the query matches tweets that have a `USING` relationship with a source.\n2. **WHERE t.favorites > 0**: This filters the tweets to include only those with a non-zero number of favorites.\n3. **RETURN s.name**: This returns the name of the source used in each tweet.\n4. **ORDER BY t.favorites DESC**: This orders the results by the number of favorites in descending order, so the top tweets come first.\n5. **LIMIT 5**: This limits the results to the top 5 tweets."
        ]
    },
    {
        "question": "Which 3 users have asked questions with the most tags?",
        "schema": "Node properties:\n- **Question**\n  - `favorites`: INTEGER Example: \"0\"\n  - `answered`: BOOLEAN \n  - `text`: STRING Example: \"### This is:  Bug    ### Specifications  OS: Win10\"\n  - `link`: STRING Example: \"https://stackoverflow.com/questions/62224586/playg\"\n  - `createdAt`: DATE_TIME Min: 2020-06-05T16:57:19Z, Max: 2020-06-05T21:49:16Z\n  - `title`: STRING Example: \"Playground is not loading with apollo-server-lambd\"\n  - `id`: INTEGER Min: 62220505, Max: 62224586\n  - `upVotes`: INTEGER Example: \"0\"\n  - `score`: INTEGER Example: \"-1\"\n  - `downVotes`: INTEGER Example: \"1\"\n- **Tag**\n  - `name`: STRING Example: \"aws-lambda\"\n- **User**\n  - `image`: STRING Example: \"https://lh3.googleusercontent.com/-NcFYSuXU0nk/AAA\"\n  - `link`: STRING Example: \"https://stackoverflow.com/users/10251021/alexandre\"\n  - `id`: INTEGER Min: 751, Max: 13681006\n  - `reputation`: INTEGER Min: 1, Max: 420137\n  - `display_name`: STRING Example: \"Alexandre Le\"\nRelationship properties:\n\nThe relationships:\n(:Question)-[:TAGGED]->(:Tag)\n(:User)-[:ASKED]->(:Question)",
        "gold_cypher": "MATCH (u:User)-[:ASKED]->(q:Question) WITH u, count{(q)-[:TAGGED]->(:Tag)} AS numTags ORDER BY numTags DESC LIMIT 3 RETURN u",
        "database": "buzzoverflow",
        "full_responses": [
            "To answer the question \"Which 3 users have asked questions with the most tags?\", you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)-[:TAGGED]->(t:Tag)\nWITH u, count(t) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n1. Matches all nodes of type `User` and `Question` and the relationship `ASKED` between them.\n2. Matches all relationships of type `TAGGED` between `Question` and `Tag`.\n3. Counts the number of tags associated with each user by grouping by `u` and counting the number of `t` nodes.\n4. Orders the results by the tag count in descending order.\n5. Limits the results to the top 3 users with the most tags.",
            "To answer the question \"Which 3 users have asked questions with the most tags?\", you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)\nWITH u, COUNT(DISTINCT a) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n\n1. `MATCH (u:User)-[a:ASKED]->(q:Question)`: Matches all nodes of type `User` and their relationships to `Question` nodes.\n2. `WITH u, COUNT(DISTINCT a) AS tagCount`: Collects each user and counts the number of distinct tags associated with their questions using the `COUNT(DISTINCT a)` function.\n3. `ORDER BY tagCount DESC`: Orders the results by the number of tags in descending order to get the users with the most tags first.\n4. `LIMIT 3`: Limits the results to the top 3 users with the most tags.",
            "To answer the question \"Which 3 users have asked questions with the most tags?\", you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)\nWITH u, count(*) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n1. Matches all users (`:User`) who have asked questions (`:ASKED` relationship).\n2. Counts the number of tags associated with each user's questions.\n3. Orders the users by the number of tags in descending order.\n4. Limits the results to the top 3 users.",
            "To find the 3 users who have asked questions with the most tags, you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)\nWITH u, COUNT(DISTINCT a) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n- `MATCH (u:User)-[a:ASKED]->(q:Question)`: Matches all users who have asked questions.\n- `WITH u, COUNT(DISTINCT a) AS tagCount`: For each user, counts the number of distinct tags associated with the questions they asked.\n- `ORDER BY tagCount DESC`: Orders the users by the number of tags in descending order.\n- `LIMIT 3`: Limits the result to the top 3 users with the most tags.",
            "To find the 3 users who have asked questions with the most tags, you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)\nWHERE a.tags IS NOT NULL\nWITH q, size(a.tags) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\n### Explanation:\n- `MATCH (u:User)-[a:ASKED]->(q:Question)`: This matches all relationships where a user (`u`) asks a question (`q`).\n- `WHERE a.tags IS NOT NULL`: This filters out questions that do not have any tags.\n- `WITH q, size(a.tags) AS tagCount`: This creates a temporary result set with each question and the number of tags it has.\n- `ORDER BY tagCount DESC`: This orders the results by the number of tags in descending order, so questions with more tags appear first.\n- `LIMIT 3`: This limits the results to the top 3 users with the most questions."
        ],
        "generated_cyphers": [
            "To answer the question \"Which 3 users have asked questions with the most tags?\", you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)-[:TAGGED]->(t:Tag)\nWITH u, count(t) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n1. Matches all nodes of type `User` and `Question` and the relationship `ASKED` between them.\n2. Matches all relationships of type `TAGGED` between `Question` and `Tag`.\n3. Counts the number of tags associated with each user by grouping by `u` and counting the number of `t` nodes.\n4. Orders the results by the tag count in descending order.\n5. Limits the results to the top 3 users with the most tags.",
            "To answer the question \"Which 3 users have asked questions with the most tags?\", you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)\nWITH u, COUNT(DISTINCT a) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n\n1. `MATCH (u:User)-[a:ASKED]->(q:Question)`: Matches all nodes of type `User` and their relationships to `Question` nodes.\n2. `WITH u, COUNT(DISTINCT a) AS tagCount`: Collects each user and counts the number of distinct tags associated with their questions using the `COUNT(DISTINCT a)` function.\n3. `ORDER BY tagCount DESC`: Orders the results by the number of tags in descending order to get the users with the most tags first.\n4. `LIMIT 3`: Limits the results to the top 3 users with the most tags.",
            "To answer the question \"Which 3 users have asked questions with the most tags?\", you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)\nWITH u, count(*) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n1. Matches all users (`:User`) who have asked questions (`:ASKED` relationship).\n2. Counts the number of tags associated with each user's questions.\n3. Orders the users by the number of tags in descending order.\n4. Limits the results to the top 3 users.",
            "To find the 3 users who have asked questions with the most tags, you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)\nWITH u, COUNT(DISTINCT a) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n- `MATCH (u:User)-[a:ASKED]->(q:Question)`: Matches all users who have asked questions.\n- `WITH u, COUNT(DISTINCT a) AS tagCount`: For each user, counts the number of distinct tags associated with the questions they asked.\n- `ORDER BY tagCount DESC`: Orders the users by the number of tags in descending order.\n- `LIMIT 3`: Limits the result to the top 3 users with the most tags.",
            "To find the 3 users who have asked questions with the most tags, you can use the following Cypher query:\n\n```cypher\nMATCH (u:User)-[a:ASKED]->(q:Question)\nWHERE a.tags IS NOT NULL\nWITH q, size(a.tags) AS tagCount\nORDER BY tagCount DESC\nLIMIT 3\n```\n\n### Explanation:\n- `MATCH (u:User)-[a:ASKED]->(q:Question)`: This matches all relationships where a user (`u`) asks a question (`q`).\n- `WHERE a.tags IS NOT NULL`: This filters out questions that do not have any tags.\n- `WITH q, size(a.tags) AS tagCount`: This creates a temporary result set with each question and the number of tags it has.\n- `ORDER BY tagCount DESC`: This orders the results by the number of tags in descending order, so questions with more tags appear first.\n- `LIMIT 3`: This limits the results to the top 3 users with the most questions."
        ]
    },
    {
        "question": "Which 3 movies have the longest runtime and were released before 2000?",
        "schema": "Node properties:\n- **Movie**\n  - `average_vote`: FLOAT Example: \"7.7\"\n  - `overview`: STRING Example: \"Led by Woody, Andy's toys live happily in his room\"\n  - `revenue`: FLOAT Example: \"3.73554033E8\"\n  - `vote_count`: INTEGER Example: \"5415\"\n  - `tagline`: STRING Example: \"Roll the dice and unleash the excitement!\"\n  - `budget`: INTEGER Example: \"30000000\"\n  - `title`: STRING Example: \"Toy Story\"\n  - `poster_path`: STRING Example: \"/rhIRbceoE9lR4veEXuwCC2wARtG.jpg\"\n  - `imdb_id`: STRING Example: \"tt0114709\"\n  - `status`: STRING Example: \"Released\"\n  - `runtime`: FLOAT Example: \"81.0\"\n  - `popularity`: FLOAT Example: \"21.946943\"\n  - `homepage`: STRING Example: \"http://toystory.disney.com/toy-story\"\n  - `release_date`: DATE Example: \"1995-10-30\"\n  - `id`: INTEGER Min: 862, Max: 31357\n  - `original_title`: STRING Example: \"Toy Story\"\n  - `original_language`: STRING Example: \"en\"\n- **Language**\n  - `id`: STRING Example: \"en\"\n  - `name`: STRING Available options: ['', 'Gaeilge', 'Kiswahili', 'Az\u0259rbaycan', 'Somali', '\u0431\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f \u043c\u043e\u0432\u0430', 'Fulfulde', 'Hausa']\n- **Country**\n  - `id`: STRING Example: \"US\"\n  - `name`: STRING Example: \"United States of America\"\n- **Genre**\n  - `id`: INTEGER Min: 12, Max: 10770\n  - `name`: STRING Example: \"Animation\"\n- **ProductionCompany**\n  - `id`: INTEGER Min: 3, Max: 10201\n  - `name`: STRING Example: \"Pixar Animation Studios\"\n- **Collection**\n  - `name`: STRING Example: \"Toy Story Collection\"\n  - `id`: INTEGER Min: 10, Max: 480160\n  - `backdrop_path`: STRING Example: \"/9FBwqcd9IRruEDUrTdcaafOMKUq.jpg\"\n  - `poster_path`: STRING Example: \"/7G9915LfUQ2lVfwMEEhDsn3kT4B.jpg\"\n- **Person**\n  - `gender`: INTEGER Example: \"2\"\n  - `profile_path`: STRING Example: \"/pQFoyx7rp09CJTAb932F2g8Nlho.jpg\"\n  - `id`: INTEGER Min: 31, Max: 12900\n  - `name`: STRING Example: \"Tom Hanks\"\n- **User**\n  - `id`: INTEGER Min: 27490cf6-22eb-495d-9dd6-902c0f89c627, Max: 4\n- **Keyword**\n  - `id`: INTEGER Min: 931, Max: 9713\n  - `name`: STRING Example: \"jealousy\"\n- **Video**\n  - `tagline`: STRING Example: \"Fresh Fish. Mixed Vegetables.\"\n  - `average_vote`: FLOAT Min: 0.0, Max: 10.0\n  - `overview`: STRING Example: \"Get ready as Bob the Tomato, Larry the Cucumber an\"\n  - `revenue`: FLOAT Min: 0.0, Max: 0.0\n  - `poster_path`: STRING Example: \"/iWahPsY3hsKOizZHgzQcAxv4O3B.jpg\"\n  - `vote_count`: INTEGER Min: 0, Max: 115\n  - `title`: STRING Example: \"Jonah: A VeggieTales Movie\"\n  - `release_date`: DATE Min: 1973-01-12, Max: 2017-03-17\n  - `status`: STRING Available options: ['Released']\n  - `budget`: INTEGER Min: 0, Max: 2219684\n  - `popularity`: FLOAT Min: 0.0, Max: 9.22546\n  - `imdb_id`: STRING Example: \"tt0298388\"\n  - `original_title`: STRING Example: \"Jonah: A VeggieTales Movie\"\n  - `id`: INTEGER Min: 13284, Max: 461088\n  - `runtime`: FLOAT Min: 0.0, Max: 583.0\n  - `original_language`: STRING Example: \"en\"\n  - `homepage`: STRING Example: \"http://www.loosechange911.com/\"\n- **Adult**\n  - `average_vote`: FLOAT Min: 0.0, Max: 6.3\n  - `overview`: STRING Available options: ['A sailor takes an American businessman and his gir', 'The FBI and Texas police make ready to storm the h', 'Electrical Girl centers around a horny young woman', '\u00c1gata suffers from a psychological disorder which ', \"Shane Ryan's sequel to the disturbing Amateur Porn\", 'Australian film about a fictional sub-par Australi', 'Olaf and his mother run a boarding house and a whi', 'A man who returns home to find his wife cheating o', 'An American scientific research facility opens a p']\n  - `revenue`: FLOAT Min: 0.0, Max: 0.0\n  - `poster_path`: STRING Available options: ['/tzVK7nTnzUiVeFSZhOAIHmrgXUS.jpg', '/1VzwIa8HTykNiCCW8PBaJnyTvO8.jpg', '/yTfqRQlJMTAuTNDG01XjNg5KPPg.jpg', '/oP2WvKIWxqSBVHjfYAizFHOqBLG.jpg', '/zpycBSiBFp5Uib6gWJpgEvfOgdn.jpg', '/e7CAc8OadcUoKNPIX86SEPSX7f.jpg', '/jjncR0vECvXVrBvr0A1vLghL4pN.jpg', '/pJLmZBruOmn2c9mYWe3h1xcXaA0.jpg', '/3uv9oaqOJkkdZiQp6r9lf24tkHW.jpg']\n  - `vote_count`: INTEGER Min: 0, Max: 16\n  - `title`: STRING Available options: ['Erotic Nights of the Living Dead', 'Standoff', 'Electrical Girl', 'Diet of Sex', 'Amateur Porn Star Killer 2', 'The Band', 'The Sinful Dwarf', 'Adulterers', 'Half -Life']\n  - `release_date`: DATE Min: 1973-12-20, Max: 2016-01-05\n  - `status`: STRING Available options: ['Released', 'In Production']\n  - `budget`: INTEGER Min: 0, Max: 750000\n  - `popularity`: FLOAT Min: 0.001803, Max: 6.889832\n  - `imdb_id`: STRING Available options: ['tt0079642', 'tt0119931', 'tt0322232', 'tt3094816', 'tt1161951', 'tt1153101', 'tt0070696', 'tt4044464', 'tt2697688']\n  - `original_title`: STRING Available options: ['Le notti erotiche dei morti viventi', 'Standoff', '\u767c\u96fb\u6084\u5b0c\u5a03', 'Diet of Sex', 'Amateur Porn Star Killer 2', 'The Band', 'Dv\u00e6rgen', 'Adulterers', 'Half -Life']\n  - `id`: INTEGER Min: 5422, Max: 448290\n  - `runtime`: FLOAT Min: 0.0, Max: 112.0\n  - `original_language`: STRING Available options: ['it', 'en', 'cn', 'es', 'da']\n  - `tagline`: STRING Available options: ['Trust Will Get You Killed', 'Comedy, food, drama and sex, a lot of sex', 'Humiliation. Rape. Murder. You know the drill.', \"Sex, drugs and Rock 'n Roll\", 'The Mother of all Dwarfsploitation films!', 'Love. Betrayal. Vengeance']\n  - `homepage`: STRING Available options: ['http://www.imdb.com/title/tt0119931/', 'http://www.dietofsex.com/']\n- **Package**\n  - `price`: FLOAT Min: 0.0, Max: 99.99\n  - `duration`: DURATION \n  - `id`: INTEGER Min: 0, Max: 6\n  - `name`: STRING Available options: ['Childrens', 'Bronze', 'Silver', 'Gold', 'Platinum', 'Ultimate', 'Free Trial']\n- **Subscription**\n  - `expiresAt`: DATE_TIME Min: 2020-08-23T16:20:52.383Z, Max: 2020-08-23T16:20:52.383Z\n  - `id`: STRING Available options: ['e74f7163-eace-4169-8043-41627f1fe236']\nRelationship properties:\n- **CAST_FOR**\n  - `credit_id: STRING` Example: \"52fe4459c3a36847f8090d7d\"\n  - `order: INTEGER` Example: \"0\"\n  - `character: STRING` Example: \"Charlie Wilson\"\n  - `cast_id: INTEGER` Example: \"12\"\n- **CREW_FOR**\n  - `credit_id: STRING` Example: \"55e4f0abc3a368140800047e\"\n  - `job: STRING` Example: \"Producer\"\n  - `department: STRING` Example: \"Production\"\n- **RATED**\n  - `timestamp: DATE_TIME` Example: \"2015-03-09T22:49:42Z\"\n  - `rating: FLOAT` Example: \"5.0\"\nThe relationships:\n(:Movie)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Movie)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Movie)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Movie)-[:IN_GENRE]->(:Genre)\n(:Movie)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Movie)-[:HAS_KEYWORD]->(:Keyword)\n(:Movie)-[:IN_COLLECTION]->(:Collection)\n(:Person)-[:CAST_FOR]->(:Movie)\n(:Person)-[:CREW_FOR]->(:Movie)\n(:Person)-[:CREW_FOR]->(:Video)\n(:User)-[:RATED]->(:Movie)\n(:User)-[:RATED]->(:Video)\n(:Video)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Video)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Video)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Video)-[:IN_GENRE]->(:Genre)\n(:Video)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Video)-[:HAS_KEYWORD]->(:Keyword)\n(:Video)-[:IN_COLLECTION]->(:Collection)\n(:Adult)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Adult)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Adult)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Adult)-[:IN_GENRE]->(:Genre)\n(:Adult)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Adult)-[:HAS_KEYWORD]->(:Keyword)\n(:Package)-[:PROVIDES_ACCESS_TO]->(:Genre)\n(:Subscription)-[:FOR_PACKAGE]->(:Package)",
        "gold_cypher": "MATCH (m:Movie) WHERE m.release_date < date('2000-01-01') AND m.runtime IS NOT NULL RETURN m ORDER BY m.runtime DESC LIMIT 3",
        "database": "eoflix",
        "full_responses": [
            "To answer the question, we need to find the 3 movies with the longest runtime that were released before 2000. We can achieve this by querying the `Movie` nodes and ordering them by `runtime` in descending order, then limiting the result to the top 3 movies. Here's the Cypher query to accomplish this:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date < '2000-01-01'\nORDER BY m.runtime DESC\nLIMIT 3\n```\n\nThis query matches all `Movie` nodes, filters them to include only those released before 2000, orders the results by `runtime` in descending order, and limits the output to the top 3 movies.",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date < '2000-01-01' AND m.runtime > 0\nORDER BY m.runtime DESC\nLIMIT 3\n```",
            "```cypher\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre)\nWHERE m.release_date < '2000-01-01'\nORDER BY m.runtime DESC\nLIMIT 3\nRETURN m.title, m.runtime\n```",
            "```cypher\nMATCH (m:Movie)-[rel:IN_GENRE]->(g:Genre)\nWHERE g.name = 'Animation' AND m.release_date < '2000-01-01'\nRETURN m.title, m.runtime\nORDER BY m.runtime DESC\nLIMIT 3\n```",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date < '2000-01-01'\nRETURN m.title, m.runtime ORDER BY m.runtime DESC LIMIT 3\n```"
        ],
        "generated_cyphers": [
            "To answer the question, we need to find the 3 movies with the longest runtime that were released before 2000. We can achieve this by querying the `Movie` nodes and ordering them by `runtime` in descending order, then limiting the result to the top 3 movies. Here's the Cypher query to accomplish this:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date < '2000-01-01'\nORDER BY m.runtime DESC\nLIMIT 3\n```\n\nThis query matches all `Movie` nodes, filters them to include only those released before 2000, orders the results by `runtime` in descending order, and limits the output to the top 3 movies.",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date < '2000-01-01' AND m.runtime > 0\nORDER BY m.runtime DESC\nLIMIT 3\n```",
            "```cypher\nMATCH (m:Movie)-[:IN_GENRE]->(g:Genre)\nWHERE m.release_date < '2000-01-01'\nORDER BY m.runtime DESC\nLIMIT 3\nRETURN m.title, m.runtime\n```",
            "```cypher\nMATCH (m:Movie)-[rel:IN_GENRE]->(g:Genre)\nWHERE g.name = 'Animation' AND m.release_date < '2000-01-01'\nRETURN m.title, m.runtime\nORDER BY m.runtime DESC\nLIMIT 3\n```",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date < '2000-01-01'\nRETURN m.title, m.runtime ORDER BY m.runtime DESC LIMIT 3\n```"
        ]
    },
    {
        "question": "Find the title of the question with the shortest body_markdown.",
        "schema": "Node properties:\n- **Question**\n  - `link`: STRING Example: \"https://stackoverflow.com/q/65697972\"\n  - `accepted_answer_id`: INTEGER Min: 61447621, Max: 69272967\n  - `creation_date`: INTEGER Min: 1587746198, Max: 1632249176\n  - `view_count`: INTEGER Min: 4, Max: 1851\n  - `answer_count`: INTEGER Min: 0, Max: 4\n  - `body_markdown`: STRING Example: \"I want to create a graph from my recursive JSON fi\"\n  - `uuid`: INTEGER Min: 61413144, Max: 69273945\n  - `title`: STRING Example: \"Create graph from recursive JSON data using apoc.l\"\n- **User**\n  - `uuid`: INTEGER Min: deleted, Max: 16922964\n  - `display_name`: STRING Example: \"schernichkin\"\n- **Tag**\n  - `name`: STRING Example: \"neo4j\"\n  - `link`: STRING Example: \"https://stackoverflow.com/questions/tagged/neo4j\"\n- **Answer**\n  - `link`: STRING Example: \"https://stackoverflow.com/a/69272967\"\n  - `title`: STRING Example: \"Return &#39;biggest fan of a tag&#39; neo4j\"\n  - `is_accepted`: BOOLEAN \n  - `body_markdown`: STRING Example: \"The error is here:    ```  WHERE COUNT(posted) &lt\"\n  - `score`: INTEGER Min: -2, Max: 6\n  - `uuid`: INTEGER Min: 61445468, Max: 69273049\n- **Comment**\n  - `score`: INTEGER Min: 0, Max: 3\n  - `uuid`: INTEGER Min: 108645245, Max: 122427099\n  - `link`: STRING Example: \"https://stackoverflow.com/questions/69208813/confi\"\nRelationship properties:\n\nThe relationships:\n(:Question)-[:TAGGED]->(:Tag)\n(:User)-[:ASKED]->(:Question)\n(:User)-[:COMMENTED]->(:Comment)\n(:User)-[:PROVIDED]->(:Answer)\n(:Answer)-[:ANSWERED]->(:Question)\n(:Comment)-[:COMMENTED_ON]->(:Question)",
        "gold_cypher": "MATCH (q:Question) WITH q.title AS title, size(q.body_markdown) AS body_length ORDER BY body_length ASC RETURN title LIMIT 1",
        "database": "stackoverflow2",
        "full_responses": [
            "To find the title of the question with the shortest `body_markdown`, you can use the following Cypher query:\n\n```cypher\nMATCH (q:Question)\nRETURN q.title ORDER BY LENGTH(q.body_markdown) ASC LIMIT 1\n```\n\nThis query matches all nodes of type `Question`, orders them by the length of the `body_markdown` property in ascending order, and returns the title of the first question, which will be the one with the shortest `body_markdown`.",
            "To find the title of the question with the shortest `body_markdown`, you can use the following Cypher query:\n\n```cypher\nMATCH (q:Question)\nRETURN q.title, q.body_markdown ORDER BY LENGTH(q.body_markdown) ASC LIMIT 1\n```\n\nThis query selects the `title` and `body_markdown` of questions, orders them by the length of `body_markdown` in ascending order, and returns the first result, which will be the question with the shortest `body_markdown`.",
            "```cypher\nMATCH (q:Question)\nRETURN q.title ORDER BY LENGTH(q.body_markdown) LIMIT 1\n```",
            "```cypher\nMATCH (q:Question)\nRETURN q.title ORDER BY LENGTH(q.body_markdown) LIMIT 1\n```",
            "To find the title of the question with the shortest `body_markdown`, you can use the following Cypher query:\n\n```cypher\nMATCH (q:Question)\nRETURN q.title, q.body_markdown\nORDER BY LENGTH(q.body_markdown) ASC\nLIMIT 1\n```\n\nThis query selects the `title` and `body_markdown` of questions, orders them by the length of the `body_markdown`, and limits the result to the question with the shortest `body_markdown`."
        ],
        "generated_cyphers": [
            "To find the title of the question with the shortest `body_markdown`, you can use the following Cypher query:\n\n```cypher\nMATCH (q:Question)\nRETURN q.title ORDER BY LENGTH(q.body_markdown) ASC LIMIT 1\n```\n\nThis query matches all nodes of type `Question`, orders them by the length of the `body_markdown` property in ascending order, and returns the title of the first question, which will be the one with the shortest `body_markdown`.",
            "To find the title of the question with the shortest `body_markdown`, you can use the following Cypher query:\n\n```cypher\nMATCH (q:Question)\nRETURN q.title, q.body_markdown ORDER BY LENGTH(q.body_markdown) ASC LIMIT 1\n```\n\nThis query selects the `title` and `body_markdown` of questions, orders them by the length of `body_markdown` in ascending order, and returns the first result, which will be the question with the shortest `body_markdown`.",
            "```cypher\nMATCH (q:Question)\nRETURN q.title ORDER BY LENGTH(q.body_markdown) LIMIT 1\n```",
            "```cypher\nMATCH (q:Question)\nRETURN q.title ORDER BY LENGTH(q.body_markdown) LIMIT 1\n```",
            "To find the title of the question with the shortest `body_markdown`, you can use the following Cypher query:\n\n```cypher\nMATCH (q:Question)\nRETURN q.title, q.body_markdown\nORDER BY LENGTH(q.body_markdown) ASC\nLIMIT 1\n```\n\nThis query selects the `title` and `body_markdown` of questions, orders them by the length of the `body_markdown`, and limits the result to the question with the shortest `body_markdown`."
        ]
    },
    {
        "question": "Which 3 directors have the longest filmography in the database?",
        "schema": "Node properties:\n- **Movie**\n  - `url`: STRING Example: \"https://themoviedb.org/movie/862\"\n  - `runtime`: INTEGER Min: 2, Max: 910\n  - `revenue`: INTEGER Min: 1, Max: 2787965087\n  - `imdbRating`: FLOAT Min: 1.6, Max: 9.6\n  - `released`: STRING Example: \"1995-11-22\"\n  - `countries`: LIST Min Size: 1, Max Size: 16\n  - `languages`: LIST Min Size: 1, Max Size: 19\n  - `plot`: STRING Example: \"A cowboy doll is profoundly threatened and jealous\"\n  - `imdbVotes`: INTEGER Min: 13, Max: 1626900\n  - `imdbId`: STRING Example: \"0114709\"\n  - `year`: INTEGER Min: 1902, Max: 2016\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/uXDf\"\n  - `movieId`: STRING Example: \"1\"\n  - `tmdbId`: STRING Example: \"862\"\n  - `title`: STRING Example: \"Toy Story\"\n  - `budget`: INTEGER Min: 1, Max: 380000000\n- **Genre**\n  - `name`: STRING Example: \"Adventure\"\n- **User**\n  - `userId`: STRING Example: \"1\"\n  - `name`: STRING Example: \"Omar Huffman\"\n- **Actor**\n  - `url`: STRING Example: \"https://themoviedb.org/person/1271225\"\n  - `name`: STRING Example: \"Fran\u00e7ois Lallement\"\n  - `tmdbId`: STRING Example: \"1271225\"\n  - `bornIn`: STRING Example: \"France\"\n  - `bio`: STRING Example: \"\u200bFrom Wikipedia, the free encyclopedia  Lillian Di\"\n  - `died`: DATE Example: \"1954-01-01\"\n  - `born`: DATE Example: \"1877-02-04\"\n  - `imdbId`: STRING Example: \"2083046\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/6DCW\"\n- **Director**\n  - `url`: STRING Example: \"https://themoviedb.org/person/88953\"\n  - `bornIn`: STRING Example: \"Burchard, Nebraska, USA\"\n  - `born`: DATE Min: 1861-12-08, Max: 2018-05-01\n  - `died`: DATE Min: 1930-08-26, Max: 2976-09-29\n  - `tmdbId`: STRING Example: \"88953\"\n  - `imdbId`: STRING Example: \"0516001\"\n  - `name`: STRING Example: \"Harold Lloyd\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/er4Z\"\n  - `bio`: STRING Example: \"Harold Lloyd has been called the cinema\u2019s \u201cfirst m\"\n- **Person**\n  - `url`: STRING Example: \"https://themoviedb.org/person/1271225\"\n  - `died`: DATE Example: \"1954-01-01\"\n  - `bornIn`: STRING Example: \"France\"\n  - `born`: DATE Example: \"1877-02-04\"\n  - `imdbId`: STRING Example: \"2083046\"\n  - `name`: STRING Example: \"Fran\u00e7ois Lallement\"\n  - `poster`: STRING Example: \"https://image.tmdb.org/t/p/w440_and_h660_face/6DCW\"\n  - `tmdbId`: STRING Example: \"1271225\"\n  - `bio`: STRING Example: \"\u200bFrom Wikipedia, the free encyclopedia  Lillian Di\"\nRelationship properties:\n- **RATED**\n  - `rating: FLOAT` Example: \"2.0\"\n  - `timestamp: INTEGER` Example: \"1260759108\"\n- **ACTED_IN**\n  - `role: STRING` Example: \"Officer of the Marines (uncredited)\"\n- **DIRECTED**\n  - `role: STRING` \nThe relationships:\n(:Movie)-[:IN_GENRE]->(:Genre)\n(:User)-[:RATED]->(:Movie)\n(:Actor)-[:ACTED_IN]->(:Movie)\n(:Actor)-[:DIRECTED]->(:Movie)\n(:Director)-[:DIRECTED]->(:Movie)\n(:Director)-[:ACTED_IN]->(:Movie)\n(:Person)-[:ACTED_IN]->(:Movie)\n(:Person)-[:DIRECTED]->(:Movie)",
        "gold_cypher": "MATCH (d:Director)-[:DIRECTED]->(m:Movie) RETURN d.name AS director, count(m) AS num_movies ORDER BY num_movies DESC LIMIT 3",
        "database": "recommendations",
        "full_responses": [
            "To find the three directors with the longest filmography in the database, you can use the following Cypher query:\n\n```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nWITH d, COUNT(m) AS movieCount\nORDER BY movieCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n- Matches all directors (`d`) and the movies they directed (`m`).\n- Counts the number of movies each director has directed using the `COUNT(m)` function.\n- Orders the directors by the number of movies in descending order.\n- Limits the result to the top 3 directors with the longest filmographies.",
            "To find the 3 directors with the longest filmography in the database, you can use a Cypher query that calculates the total number of movies directed by each director and then orders them by this count in descending order. Here's how you can write the query:\n\n```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nWITH d, count(*) AS filmography_count\nORDER BY filmography_count DESC\nLIMIT 3\nRETURN d.name AS director_name, filmography_count\n```\n\nThis query does the following:\n1. Matches all directors and the movies they directed using the `DIRECTED` relationship.\n2. Uses a `WITH` clause to count the number of movies directed by each director.\n3. Orders the results by the filmography count in descending order.\n4. Limits the results to the top 3 directors with the longest filmography.\n5. Returns the director's name and their filmography count.",
            "```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nRETURN d.name AS directorName, count(m) AS filmographyCount\nORDER BY filmographyCount DESC\nLIMIT 3;\n```",
            "```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nRETURN d.name, COUNT(m) AS filmographyCount\nORDER BY filmographyCount DESC\nLIMIT 3;\n```",
            "To find the 3 directors with the longest filmography in the database, you can use the following Cypher query:\n\n```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nRETURN d.name AS Director, COUNT(m) AS FilmographyCount\nORDER BY FilmographyCount DESC\nLIMIT 3;\n```\n\nThis query does the following:\n- It matches all directors (`:Director`) and the movies they directed (`:Movie`) through the `DIRECTED` relationship.\n- It counts the number of movies each director has directed.\n- It orders the results by the count of movies in descending order.\n- It limits the results to the top 3 directors with the longest filmographies."
        ],
        "generated_cyphers": [
            "To find the three directors with the longest filmography in the database, you can use the following Cypher query:\n\n```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nWITH d, COUNT(m) AS movieCount\nORDER BY movieCount DESC\nLIMIT 3\n```\n\nThis query does the following:\n- Matches all directors (`d`) and the movies they directed (`m`).\n- Counts the number of movies each director has directed using the `COUNT(m)` function.\n- Orders the directors by the number of movies in descending order.\n- Limits the result to the top 3 directors with the longest filmographies.",
            "To find the 3 directors with the longest filmography in the database, you can use a Cypher query that calculates the total number of movies directed by each director and then orders them by this count in descending order. Here's how you can write the query:\n\n```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nWITH d, count(*) AS filmography_count\nORDER BY filmography_count DESC\nLIMIT 3\nRETURN d.name AS director_name, filmography_count\n```\n\nThis query does the following:\n1. Matches all directors and the movies they directed using the `DIRECTED` relationship.\n2. Uses a `WITH` clause to count the number of movies directed by each director.\n3. Orders the results by the filmography count in descending order.\n4. Limits the results to the top 3 directors with the longest filmography.\n5. Returns the director's name and their filmography count.",
            "```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nRETURN d.name AS directorName, count(m) AS filmographyCount\nORDER BY filmographyCount DESC\nLIMIT 3;\n```",
            "```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nRETURN d.name, COUNT(m) AS filmographyCount\nORDER BY filmographyCount DESC\nLIMIT 3;\n```",
            "To find the 3 directors with the longest filmography in the database, you can use the following Cypher query:\n\n```cypher\nMATCH (d:Director)-[r:DIRECTED]->(m:Movie)\nRETURN d.name AS Director, COUNT(m) AS FilmographyCount\nORDER BY FilmographyCount DESC\nLIMIT 3;\n```\n\nThis query does the following:\n- It matches all directors (`:Director`) and the movies they directed (`:Movie`) through the `DIRECTED` relationship.\n- It counts the number of movies each director has directed.\n- It orders the results by the count of movies in descending order.\n- It limits the results to the top 3 directors with the longest filmographies."
        ]
    },
    {
        "question": "What is the average rating given by users from Missoula?",
        "schema": "Node properties:\n- **Business**\n  - `address`: STRING Available options: ['301 E Main St', '200 W Pine St', '313 N 1st St W', '1151 W Broadway St', '201 E Front St', '723 California Dr', '121 W Broadway St', '716 N San Mateo Dr', '111 E 5th Ave']\n  - `location`: POINT \n  - `city`: STRING Available options: ['Missoula', 'Burlingame', 'San Mateo']\n  - `state`: STRING Available options: ['MT', 'CA']\n  - `businessId`: STRING Available options: ['b5', 'b3', 'b1', 'b2', 'b4', 'b7', 'b6', 'b8', 'b9']\n  - `name`: STRING Available options: ['Missoula Public Library', \"Ninja Mike's\", 'KettleHouse Brewing Co.', 'Imagine Nation Brewing', 'Market on Front', 'Hanabi', 'Zootown Brew', \"Ducky's Car Wash\", 'Neo4j']\n- **User**\n  - `name`: STRING Available options: ['Will', 'Bob', 'Jenny', 'Angie']\n  - `userId`: STRING Available options: ['u1', 'u2', 'u3', 'u4']\n- **Review**\n  - `date`: DATE Min: 2015-08-29, Max: 2018-09-10\n  - `text`: STRING Available options: ['Not a great selection of books, but fortunately th', \"Best breakfast sandwich at the Farmer's Market. Al\", 'Great IPA selection!', \"Awesome full-service car wash. Love Ducky's!\", \"The world's leading graph database HQ!\"]\n  - `stars`: FLOAT Min: 3.0, Max: 5.0\n  - `reviewId`: STRING Example: \"r7\"\n- **Category**\n  - `name`: STRING Example: \"Library\"\nRelationship properties:\n\nThe relationships:\n(:Business)-[:IN_CATEGORY]->(:Category)\n(:User)-[:WROTE]->(:Review)\n(:Review)-[:REVIEWS]->(:Business)",
        "gold_cypher": "MATCH (u:User)-[:WROTE]->(r:Review)-[:REVIEWS]->(b:Business) WHERE b.city = \"Missoula\" RETURN avg(r.stars) AS average_rating",
        "database": "grandstack",
        "full_responses": [
            "To calculate the average rating given by users from Missoula, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business {city: 'Missoula'})-[:REVIEWS]->(r:Review)\nRETURN AVG(r.stars) AS averageRating\n```\n\nThis query matches businesses located in Missoula, then finds all reviews written by users who have reviewed these businesses. Finally, it calculates the average of the `stars` field in the `Review` nodes.",
            "```cypher\nMATCH (b:Business {city: 'Missoula'})<-[:IN_CATEGORY]-(c:Category)-[:REVIEWS]->(r:Review)\nRETURN avg(r.stars)\n```",
            "To find the average rating given by users from Missoula, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWHERE b.city = 'Missoula'\nRETURN avg(rev.stars) AS averageRating\n```\n\nThis query matches businesses located in Missoula, then retrieves the reviews associated with these businesses. It calculates the average rating from the `stars` property of the reviews and returns this average value as `averageRating`.",
            "To find the average rating given by users from Missoula, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business {city: 'Missoula'})<-[:IN_CATEGORY]-(:Category)<-[:REVIEWS]-(r:Review)\nRETURN AVG(r.stars) AS averageRating\n```\n\nThis query matches businesses located in Missoula, then finds the reviews associated with these businesses, and calculates the average rating from those reviews.",
            "To find the average rating given by users from Missoula, you can use the following Cypher query. This query retrieves the average rating from reviews associated with businesses in Missoula.\n\n```cypher\nMATCH (b:Business {city: 'Missoula'})\nWITH b\nMATCH (b)-[r:REVIEWS]->(rev:Review)\nRETURN avg(rev.stars)\n```\n\nThis query works as follows:\n1. `MATCH (b:Business {city: 'Missoula'})`: Matches all businesses located in Missoula.\n2. `WITH b`: Captures the matched business node `b`.\n3. `MATCH (b)-[r:REVIEWS]->(rev:Review)`: Finds all reviews associated with the matched businesses.\n4. `RETURN avg(rev.stars)`: Calculates and returns the average of the `stars` property of the reviews."
        ],
        "generated_cyphers": [
            "To calculate the average rating given by users from Missoula, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business {city: 'Missoula'})-[:REVIEWS]->(r:Review)\nRETURN AVG(r.stars) AS averageRating\n```\n\nThis query matches businesses located in Missoula, then finds all reviews written by users who have reviewed these businesses. Finally, it calculates the average of the `stars` field in the `Review` nodes.",
            "```cypher\nMATCH (b:Business {city: 'Missoula'})<-[:IN_CATEGORY]-(c:Category)-[:REVIEWS]->(r:Review)\nRETURN avg(r.stars)\n```",
            "To find the average rating given by users from Missoula, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business)-[r:REVIEWS]->(rev:Review)\nWHERE b.city = 'Missoula'\nRETURN avg(rev.stars) AS averageRating\n```\n\nThis query matches businesses located in Missoula, then retrieves the reviews associated with these businesses. It calculates the average rating from the `stars` property of the reviews and returns this average value as `averageRating`.",
            "To find the average rating given by users from Missoula, you can use the following Cypher query:\n\n```cypher\nMATCH (b:Business {city: 'Missoula'})<-[:IN_CATEGORY]-(:Category)<-[:REVIEWS]-(r:Review)\nRETURN AVG(r.stars) AS averageRating\n```\n\nThis query matches businesses located in Missoula, then finds the reviews associated with these businesses, and calculates the average rating from those reviews.",
            "To find the average rating given by users from Missoula, you can use the following Cypher query. This query retrieves the average rating from reviews associated with businesses in Missoula.\n\n```cypher\nMATCH (b:Business {city: 'Missoula'})\nWITH b\nMATCH (b)-[r:REVIEWS]->(rev:Review)\nRETURN avg(rev.stars)\n```\n\nThis query works as follows:\n1. `MATCH (b:Business {city: 'Missoula'})`: Matches all businesses located in Missoula.\n2. `WITH b`: Captures the matched business node `b`.\n3. `MATCH (b)-[r:REVIEWS]->(rev:Review)`: Finds all reviews associated with the matched businesses.\n4. `RETURN avg(rev.stars)`: Calculates and returns the average of the `stars` property of the reviews."
        ]
    },
    {
        "question": "List the first 3 languages spoken in movies released after 2010.",
        "schema": "Node properties:\n- **Movie**\n  - `average_vote`: FLOAT Example: \"7.7\"\n  - `overview`: STRING Example: \"Led by Woody, Andy's toys live happily in his room\"\n  - `revenue`: FLOAT Example: \"3.73554033E8\"\n  - `vote_count`: INTEGER Example: \"5415\"\n  - `tagline`: STRING Example: \"Roll the dice and unleash the excitement!\"\n  - `budget`: INTEGER Example: \"30000000\"\n  - `title`: STRING Example: \"Toy Story\"\n  - `poster_path`: STRING Example: \"/rhIRbceoE9lR4veEXuwCC2wARtG.jpg\"\n  - `imdb_id`: STRING Example: \"tt0114709\"\n  - `status`: STRING Example: \"Released\"\n  - `runtime`: FLOAT Example: \"81.0\"\n  - `popularity`: FLOAT Example: \"21.946943\"\n  - `homepage`: STRING Example: \"http://toystory.disney.com/toy-story\"\n  - `release_date`: DATE Example: \"1995-10-30\"\n  - `id`: INTEGER Min: 862, Max: 31357\n  - `original_title`: STRING Example: \"Toy Story\"\n  - `original_language`: STRING Example: \"en\"\n- **Language**\n  - `id`: STRING Example: \"en\"\n  - `name`: STRING Available options: ['', 'Gaeilge', 'Kiswahili', 'Az\u0259rbaycan', 'Somali', '\u0431\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f \u043c\u043e\u0432\u0430', 'Fulfulde', 'Hausa']\n- **Country**\n  - `id`: STRING Example: \"US\"\n  - `name`: STRING Example: \"United States of America\"\n- **Genre**\n  - `id`: INTEGER Min: 12, Max: 10770\n  - `name`: STRING Example: \"Animation\"\n- **ProductionCompany**\n  - `id`: INTEGER Min: 3, Max: 10201\n  - `name`: STRING Example: \"Pixar Animation Studios\"\n- **Collection**\n  - `name`: STRING Example: \"Toy Story Collection\"\n  - `id`: INTEGER Min: 10, Max: 480160\n  - `backdrop_path`: STRING Example: \"/9FBwqcd9IRruEDUrTdcaafOMKUq.jpg\"\n  - `poster_path`: STRING Example: \"/7G9915LfUQ2lVfwMEEhDsn3kT4B.jpg\"\n- **Person**\n  - `gender`: INTEGER Example: \"2\"\n  - `profile_path`: STRING Example: \"/pQFoyx7rp09CJTAb932F2g8Nlho.jpg\"\n  - `id`: INTEGER Min: 31, Max: 12900\n  - `name`: STRING Example: \"Tom Hanks\"\n- **User**\n  - `id`: INTEGER Min: 27490cf6-22eb-495d-9dd6-902c0f89c627, Max: 4\n- **Keyword**\n  - `id`: INTEGER Min: 931, Max: 9713\n  - `name`: STRING Example: \"jealousy\"\n- **Video**\n  - `tagline`: STRING Example: \"Fresh Fish. Mixed Vegetables.\"\n  - `average_vote`: FLOAT Min: 0.0, Max: 10.0\n  - `overview`: STRING Example: \"Get ready as Bob the Tomato, Larry the Cucumber an\"\n  - `revenue`: FLOAT Min: 0.0, Max: 0.0\n  - `poster_path`: STRING Example: \"/iWahPsY3hsKOizZHgzQcAxv4O3B.jpg\"\n  - `vote_count`: INTEGER Min: 0, Max: 115\n  - `title`: STRING Example: \"Jonah: A VeggieTales Movie\"\n  - `release_date`: DATE Min: 1973-01-12, Max: 2017-03-17\n  - `status`: STRING Available options: ['Released']\n  - `budget`: INTEGER Min: 0, Max: 2219684\n  - `popularity`: FLOAT Min: 0.0, Max: 9.22546\n  - `imdb_id`: STRING Example: \"tt0298388\"\n  - `original_title`: STRING Example: \"Jonah: A VeggieTales Movie\"\n  - `id`: INTEGER Min: 13284, Max: 461088\n  - `runtime`: FLOAT Min: 0.0, Max: 583.0\n  - `original_language`: STRING Example: \"en\"\n  - `homepage`: STRING Example: \"http://www.loosechange911.com/\"\n- **Adult**\n  - `average_vote`: FLOAT Min: 0.0, Max: 6.3\n  - `overview`: STRING Available options: ['A sailor takes an American businessman and his gir', 'The FBI and Texas police make ready to storm the h', 'Electrical Girl centers around a horny young woman', '\u00c1gata suffers from a psychological disorder which ', \"Shane Ryan's sequel to the disturbing Amateur Porn\", 'Australian film about a fictional sub-par Australi', 'Olaf and his mother run a boarding house and a whi', 'A man who returns home to find his wife cheating o', 'An American scientific research facility opens a p']\n  - `revenue`: FLOAT Min: 0.0, Max: 0.0\n  - `poster_path`: STRING Available options: ['/tzVK7nTnzUiVeFSZhOAIHmrgXUS.jpg', '/1VzwIa8HTykNiCCW8PBaJnyTvO8.jpg', '/yTfqRQlJMTAuTNDG01XjNg5KPPg.jpg', '/oP2WvKIWxqSBVHjfYAizFHOqBLG.jpg', '/zpycBSiBFp5Uib6gWJpgEvfOgdn.jpg', '/e7CAc8OadcUoKNPIX86SEPSX7f.jpg', '/jjncR0vECvXVrBvr0A1vLghL4pN.jpg', '/pJLmZBruOmn2c9mYWe3h1xcXaA0.jpg', '/3uv9oaqOJkkdZiQp6r9lf24tkHW.jpg']\n  - `vote_count`: INTEGER Min: 0, Max: 16\n  - `title`: STRING Available options: ['Erotic Nights of the Living Dead', 'Standoff', 'Electrical Girl', 'Diet of Sex', 'Amateur Porn Star Killer 2', 'The Band', 'The Sinful Dwarf', 'Adulterers', 'Half -Life']\n  - `release_date`: DATE Min: 1973-12-20, Max: 2016-01-05\n  - `status`: STRING Available options: ['Released', 'In Production']\n  - `budget`: INTEGER Min: 0, Max: 750000\n  - `popularity`: FLOAT Min: 0.001803, Max: 6.889832\n  - `imdb_id`: STRING Available options: ['tt0079642', 'tt0119931', 'tt0322232', 'tt3094816', 'tt1161951', 'tt1153101', 'tt0070696', 'tt4044464', 'tt2697688']\n  - `original_title`: STRING Available options: ['Le notti erotiche dei morti viventi', 'Standoff', '\u767c\u96fb\u6084\u5b0c\u5a03', 'Diet of Sex', 'Amateur Porn Star Killer 2', 'The Band', 'Dv\u00e6rgen', 'Adulterers', 'Half -Life']\n  - `id`: INTEGER Min: 5422, Max: 448290\n  - `runtime`: FLOAT Min: 0.0, Max: 112.0\n  - `original_language`: STRING Available options: ['it', 'en', 'cn', 'es', 'da']\n  - `tagline`: STRING Available options: ['Trust Will Get You Killed', 'Comedy, food, drama and sex, a lot of sex', 'Humiliation. Rape. Murder. You know the drill.', \"Sex, drugs and Rock 'n Roll\", 'The Mother of all Dwarfsploitation films!', 'Love. Betrayal. Vengeance']\n  - `homepage`: STRING Available options: ['http://www.imdb.com/title/tt0119931/', 'http://www.dietofsex.com/']\n- **Package**\n  - `price`: FLOAT Min: 0.0, Max: 99.99\n  - `duration`: DURATION \n  - `id`: INTEGER Min: 0, Max: 6\n  - `name`: STRING Available options: ['Childrens', 'Bronze', 'Silver', 'Gold', 'Platinum', 'Ultimate', 'Free Trial']\n- **Subscription**\n  - `expiresAt`: DATE_TIME Min: 2020-08-23T16:20:52.383Z, Max: 2020-08-23T16:20:52.383Z\n  - `id`: STRING Available options: ['e74f7163-eace-4169-8043-41627f1fe236']\nRelationship properties:\n- **CAST_FOR**\n  - `credit_id: STRING` Example: \"52fe4459c3a36847f8090d7d\"\n  - `order: INTEGER` Example: \"0\"\n  - `character: STRING` Example: \"Charlie Wilson\"\n  - `cast_id: INTEGER` Example: \"12\"\n- **CREW_FOR**\n  - `credit_id: STRING` Example: \"55e4f0abc3a368140800047e\"\n  - `job: STRING` Example: \"Producer\"\n  - `department: STRING` Example: \"Production\"\n- **RATED**\n  - `timestamp: DATE_TIME` Example: \"2015-03-09T22:49:42Z\"\n  - `rating: FLOAT` Example: \"5.0\"\nThe relationships:\n(:Movie)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Movie)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Movie)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Movie)-[:IN_GENRE]->(:Genre)\n(:Movie)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Movie)-[:HAS_KEYWORD]->(:Keyword)\n(:Movie)-[:IN_COLLECTION]->(:Collection)\n(:Person)-[:CAST_FOR]->(:Movie)\n(:Person)-[:CREW_FOR]->(:Movie)\n(:Person)-[:CREW_FOR]->(:Video)\n(:User)-[:RATED]->(:Movie)\n(:User)-[:RATED]->(:Video)\n(:Video)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Video)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Video)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Video)-[:IN_GENRE]->(:Genre)\n(:Video)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Video)-[:HAS_KEYWORD]->(:Keyword)\n(:Video)-[:IN_COLLECTION]->(:Collection)\n(:Adult)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Adult)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Adult)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Adult)-[:IN_GENRE]->(:Genre)\n(:Adult)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Adult)-[:HAS_KEYWORD]->(:Keyword)\n(:Package)-[:PROVIDES_ACCESS_TO]->(:Genre)\n(:Subscription)-[:FOR_PACKAGE]->(:Package)",
        "gold_cypher": "MATCH (m:Movie)-[:SPOKEN_IN_LANGUAGE]->(l:Language) WHERE m.release_date > date('2010-12-31') RETURN DISTINCT l.name LIMIT 3",
        "database": "eoflix",
        "full_responses": [
            "```cypher\nMATCH (m:Movie)-[r:SPOKEN_IN_LANGUAGE]->(l:Language)\nWHERE m.release_date > '2010-01-01'\nRETURN l.name\nLIMIT 3\n```",
            "```cypher\nMATCH (m:Movie)-[spoken_in_language:SPOKEN_IN_LANGUAGE]->(l:Language)\nWHERE m.release_date > '2010-01-01'\nRETURN l.name ORDER BY l.name LIMIT 3;\n```",
            "```cypher\nMATCH (m:Movie)-[rel:SPOKEN_IN_LANGUAGE]->(l:Language)\nWHERE m.release_date > '2010-01-01'\nRETURN l.name LIMIT 3\n```",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01'\nWITH m\nMATCH (m)-[r:SPOKEN_IN_LANGUAGE]->(l:Language)\nRETURN l.name ORDER BY l.name LIMIT 3\n```",
            "To list the first 3 languages spoken in movies released after 2010, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01'\nMATCH (m)-[spokenInLanguage:SPOKEN_IN_LANGUAGE]->(l:Language)\nRETURN l.name ORDER BY l.name LIMIT 3\n```\n\nThis query matches movies released after 2010, then retrieves the languages spoken in those movies, and finally orders and limits the results to the first 3 languages."
        ],
        "generated_cyphers": [
            "```cypher\nMATCH (m:Movie)-[r:SPOKEN_IN_LANGUAGE]->(l:Language)\nWHERE m.release_date > '2010-01-01'\nRETURN l.name\nLIMIT 3\n```",
            "```cypher\nMATCH (m:Movie)-[spoken_in_language:SPOKEN_IN_LANGUAGE]->(l:Language)\nWHERE m.release_date > '2010-01-01'\nRETURN l.name ORDER BY l.name LIMIT 3;\n```",
            "```cypher\nMATCH (m:Movie)-[rel:SPOKEN_IN_LANGUAGE]->(l:Language)\nWHERE m.release_date > '2010-01-01'\nRETURN l.name LIMIT 3\n```",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01'\nWITH m\nMATCH (m)-[r:SPOKEN_IN_LANGUAGE]->(l:Language)\nRETURN l.name ORDER BY l.name LIMIT 3\n```",
            "To list the first 3 languages spoken in movies released after 2010, you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date > '2010-01-01'\nMATCH (m)-[spokenInLanguage:SPOKEN_IN_LANGUAGE]->(l:Language)\nRETURN l.name ORDER BY l.name LIMIT 3\n```\n\nThis query matches movies released after 2010, then retrieves the languages spoken in those movies, and finally orders and limits the results to the first 3 languages."
        ]
    },
    {
        "question": "What are the top 5 movies with a release date on or after '2000-01-01'?",
        "schema": "Node properties:\n- **Movie**\n  - `average_vote`: FLOAT Example: \"7.7\"\n  - `overview`: STRING Example: \"Led by Woody, Andy's toys live happily in his room\"\n  - `revenue`: FLOAT Example: \"3.73554033E8\"\n  - `vote_count`: INTEGER Example: \"5415\"\n  - `tagline`: STRING Example: \"Roll the dice and unleash the excitement!\"\n  - `budget`: INTEGER Example: \"30000000\"\n  - `title`: STRING Example: \"Toy Story\"\n  - `poster_path`: STRING Example: \"/rhIRbceoE9lR4veEXuwCC2wARtG.jpg\"\n  - `imdb_id`: STRING Example: \"tt0114709\"\n  - `status`: STRING Example: \"Released\"\n  - `runtime`: FLOAT Example: \"81.0\"\n  - `popularity`: FLOAT Example: \"21.946943\"\n  - `homepage`: STRING Example: \"http://toystory.disney.com/toy-story\"\n  - `release_date`: DATE Example: \"1995-10-30\"\n  - `id`: INTEGER Min: 862, Max: 31357\n  - `original_title`: STRING Example: \"Toy Story\"\n  - `original_language`: STRING Example: \"en\"\n- **Language**\n  - `id`: STRING Example: \"en\"\n  - `name`: STRING Available options: ['', 'Gaeilge', 'Kiswahili', 'Az\u0259rbaycan', 'Somali', '\u0431\u0435\u043b\u0430\u0440\u0443\u0441\u043a\u0430\u044f \u043c\u043e\u0432\u0430', 'Fulfulde', 'Hausa']\n- **Country**\n  - `id`: STRING Example: \"US\"\n  - `name`: STRING Example: \"United States of America\"\n- **Genre**\n  - `id`: INTEGER Min: 12, Max: 10770\n  - `name`: STRING Example: \"Animation\"\n- **ProductionCompany**\n  - `id`: INTEGER Min: 3, Max: 10201\n  - `name`: STRING Example: \"Pixar Animation Studios\"\n- **Collection**\n  - `name`: STRING Example: \"Toy Story Collection\"\n  - `id`: INTEGER Min: 10, Max: 480160\n  - `backdrop_path`: STRING Example: \"/9FBwqcd9IRruEDUrTdcaafOMKUq.jpg\"\n  - `poster_path`: STRING Example: \"/7G9915LfUQ2lVfwMEEhDsn3kT4B.jpg\"\n- **Person**\n  - `gender`: INTEGER Example: \"2\"\n  - `profile_path`: STRING Example: \"/pQFoyx7rp09CJTAb932F2g8Nlho.jpg\"\n  - `id`: INTEGER Min: 31, Max: 12900\n  - `name`: STRING Example: \"Tom Hanks\"\n- **User**\n  - `id`: INTEGER Min: 27490cf6-22eb-495d-9dd6-902c0f89c627, Max: 4\n- **Keyword**\n  - `id`: INTEGER Min: 931, Max: 9713\n  - `name`: STRING Example: \"jealousy\"\n- **Video**\n  - `tagline`: STRING Example: \"Fresh Fish. Mixed Vegetables.\"\n  - `average_vote`: FLOAT Min: 0.0, Max: 10.0\n  - `overview`: STRING Example: \"Get ready as Bob the Tomato, Larry the Cucumber an\"\n  - `revenue`: FLOAT Min: 0.0, Max: 0.0\n  - `poster_path`: STRING Example: \"/iWahPsY3hsKOizZHgzQcAxv4O3B.jpg\"\n  - `vote_count`: INTEGER Min: 0, Max: 115\n  - `title`: STRING Example: \"Jonah: A VeggieTales Movie\"\n  - `release_date`: DATE Min: 1973-01-12, Max: 2017-03-17\n  - `status`: STRING Available options: ['Released']\n  - `budget`: INTEGER Min: 0, Max: 2219684\n  - `popularity`: FLOAT Min: 0.0, Max: 9.22546\n  - `imdb_id`: STRING Example: \"tt0298388\"\n  - `original_title`: STRING Example: \"Jonah: A VeggieTales Movie\"\n  - `id`: INTEGER Min: 13284, Max: 461088\n  - `runtime`: FLOAT Min: 0.0, Max: 583.0\n  - `original_language`: STRING Example: \"en\"\n  - `homepage`: STRING Example: \"http://www.loosechange911.com/\"\n- **Adult**\n  - `average_vote`: FLOAT Min: 0.0, Max: 6.3\n  - `overview`: STRING Available options: ['A sailor takes an American businessman and his gir', 'The FBI and Texas police make ready to storm the h', 'Electrical Girl centers around a horny young woman', '\u00c1gata suffers from a psychological disorder which ', \"Shane Ryan's sequel to the disturbing Amateur Porn\", 'Australian film about a fictional sub-par Australi', 'Olaf and his mother run a boarding house and a whi', 'A man who returns home to find his wife cheating o', 'An American scientific research facility opens a p']\n  - `revenue`: FLOAT Min: 0.0, Max: 0.0\n  - `poster_path`: STRING Available options: ['/tzVK7nTnzUiVeFSZhOAIHmrgXUS.jpg', '/1VzwIa8HTykNiCCW8PBaJnyTvO8.jpg', '/yTfqRQlJMTAuTNDG01XjNg5KPPg.jpg', '/oP2WvKIWxqSBVHjfYAizFHOqBLG.jpg', '/zpycBSiBFp5Uib6gWJpgEvfOgdn.jpg', '/e7CAc8OadcUoKNPIX86SEPSX7f.jpg', '/jjncR0vECvXVrBvr0A1vLghL4pN.jpg', '/pJLmZBruOmn2c9mYWe3h1xcXaA0.jpg', '/3uv9oaqOJkkdZiQp6r9lf24tkHW.jpg']\n  - `vote_count`: INTEGER Min: 0, Max: 16\n  - `title`: STRING Available options: ['Erotic Nights of the Living Dead', 'Standoff', 'Electrical Girl', 'Diet of Sex', 'Amateur Porn Star Killer 2', 'The Band', 'The Sinful Dwarf', 'Adulterers', 'Half -Life']\n  - `release_date`: DATE Min: 1973-12-20, Max: 2016-01-05\n  - `status`: STRING Available options: ['Released', 'In Production']\n  - `budget`: INTEGER Min: 0, Max: 750000\n  - `popularity`: FLOAT Min: 0.001803, Max: 6.889832\n  - `imdb_id`: STRING Available options: ['tt0079642', 'tt0119931', 'tt0322232', 'tt3094816', 'tt1161951', 'tt1153101', 'tt0070696', 'tt4044464', 'tt2697688']\n  - `original_title`: STRING Available options: ['Le notti erotiche dei morti viventi', 'Standoff', '\u767c\u96fb\u6084\u5b0c\u5a03', 'Diet of Sex', 'Amateur Porn Star Killer 2', 'The Band', 'Dv\u00e6rgen', 'Adulterers', 'Half -Life']\n  - `id`: INTEGER Min: 5422, Max: 448290\n  - `runtime`: FLOAT Min: 0.0, Max: 112.0\n  - `original_language`: STRING Available options: ['it', 'en', 'cn', 'es', 'da']\n  - `tagline`: STRING Available options: ['Trust Will Get You Killed', 'Comedy, food, drama and sex, a lot of sex', 'Humiliation. Rape. Murder. You know the drill.', \"Sex, drugs and Rock 'n Roll\", 'The Mother of all Dwarfsploitation films!', 'Love. Betrayal. Vengeance']\n  - `homepage`: STRING Available options: ['http://www.imdb.com/title/tt0119931/', 'http://www.dietofsex.com/']\n- **Package**\n  - `price`: FLOAT Min: 0.0, Max: 99.99\n  - `duration`: DURATION \n  - `id`: INTEGER Min: 0, Max: 6\n  - `name`: STRING Available options: ['Childrens', 'Bronze', 'Silver', 'Gold', 'Platinum', 'Ultimate', 'Free Trial']\n- **Subscription**\n  - `expiresAt`: DATE_TIME Min: 2020-08-23T16:20:52.383Z, Max: 2020-08-23T16:20:52.383Z\n  - `id`: STRING Available options: ['e74f7163-eace-4169-8043-41627f1fe236']\nRelationship properties:\n- **CAST_FOR**\n  - `credit_id: STRING` Example: \"52fe4459c3a36847f8090d7d\"\n  - `order: INTEGER` Example: \"0\"\n  - `character: STRING` Example: \"Charlie Wilson\"\n  - `cast_id: INTEGER` Example: \"12\"\n- **CREW_FOR**\n  - `credit_id: STRING` Example: \"55e4f0abc3a368140800047e\"\n  - `job: STRING` Example: \"Producer\"\n  - `department: STRING` Example: \"Production\"\n- **RATED**\n  - `timestamp: DATE_TIME` Example: \"2015-03-09T22:49:42Z\"\n  - `rating: FLOAT` Example: \"5.0\"\nThe relationships:\n(:Movie)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Movie)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Movie)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Movie)-[:IN_GENRE]->(:Genre)\n(:Movie)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Movie)-[:HAS_KEYWORD]->(:Keyword)\n(:Movie)-[:IN_COLLECTION]->(:Collection)\n(:Person)-[:CAST_FOR]->(:Movie)\n(:Person)-[:CREW_FOR]->(:Movie)\n(:Person)-[:CREW_FOR]->(:Video)\n(:User)-[:RATED]->(:Movie)\n(:User)-[:RATED]->(:Video)\n(:Video)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Video)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Video)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Video)-[:IN_GENRE]->(:Genre)\n(:Video)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Video)-[:HAS_KEYWORD]->(:Keyword)\n(:Video)-[:IN_COLLECTION]->(:Collection)\n(:Adult)-[:ORIGINAL_LANGUAGE]->(:Language)\n(:Adult)-[:SPOKEN_IN_LANGUAGE]->(:Language)\n(:Adult)-[:PRODUCED_IN_COUNTRY]->(:Country)\n(:Adult)-[:IN_GENRE]->(:Genre)\n(:Adult)-[:PRODUCED_BY]->(:ProductionCompany)\n(:Adult)-[:HAS_KEYWORD]->(:Keyword)\n(:Package)-[:PROVIDES_ACCESS_TO]->(:Genre)\n(:Subscription)-[:FOR_PACKAGE]->(:Package)",
        "gold_cypher": "MATCH (m:Movie) WHERE m.release_date >= date('2000-01-01') RETURN m.title, m.release_date ORDER BY m.popularity DESC LIMIT 5",
        "database": "eoflix",
        "full_responses": [
            "To find the top 5 movies with a release date on or after '2000-01-01', you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title, m.release_date, m.vote_count\nORDER BY m.vote_count DESC\nLIMIT 5;\n```\n\nThis query matches all nodes of type `Movie` and filters them to include only those with a `release_date` greater than or equal to '2000-01-01'. It then returns the title, release date, and vote count for each movie, ordering the results by the vote count in descending order and limiting the output to the top 5 movies.",
            "To find the top 5 movies with a release date on or after '2000-01-01', you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title AS Title, m.release_date AS ReleaseDate, m.vote_count AS VoteCount\nORDER BY m.vote_count DESC\nLIMIT 5;\n```\n\nThis query selects the top 5 movies based on the `vote_count` property, ensuring that movies with a release date on or after '2000-01-01' are considered. It returns the movie title, release date, and vote count for each of these movies.",
            "To answer the question \"What are the top 5 movies with a release date on or after '2000-01-01'?\", you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title AS Title, m.release_date AS ReleaseDate, m.vote_count AS VoteCount\nORDER BY m.vote_count DESC\nLIMIT 5;\n```\n\nThis query does the following:\n1. `MATCH (m:Movie)`: Matches all nodes of type `Movie`.\n2. `WHERE m.release_date >= '2000-01-01'`: Filters movies released on or after January 1, 2000.\n3. `RETURN m.title AS Title, m.release_date AS ReleaseDate, m.vote_count AS VoteCount`: Returns the movie title, release date, and vote count for each matching movie.\n4. `ORDER BY m.vote_count DESC`: Orders the results by the vote count in descending order.\n5. `LIMIT 5`: Limits the results to the top 5 movies.",
            "```cypher\nMATCH (m:Movie {release_date: {release_date}})\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title, m.release_date\nORDER BY m.release_date DESC\nLIMIT 5\n```",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title AS MovieTitle, m.release_date AS ReleaseDate ORDER BY m.release_date DESC LIMIT 5\n```"
        ],
        "generated_cyphers": [
            "To find the top 5 movies with a release date on or after '2000-01-01', you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title, m.release_date, m.vote_count\nORDER BY m.vote_count DESC\nLIMIT 5;\n```\n\nThis query matches all nodes of type `Movie` and filters them to include only those with a `release_date` greater than or equal to '2000-01-01'. It then returns the title, release date, and vote count for each movie, ordering the results by the vote count in descending order and limiting the output to the top 5 movies.",
            "To find the top 5 movies with a release date on or after '2000-01-01', you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title AS Title, m.release_date AS ReleaseDate, m.vote_count AS VoteCount\nORDER BY m.vote_count DESC\nLIMIT 5;\n```\n\nThis query selects the top 5 movies based on the `vote_count` property, ensuring that movies with a release date on or after '2000-01-01' are considered. It returns the movie title, release date, and vote count for each of these movies.",
            "To answer the question \"What are the top 5 movies with a release date on or after '2000-01-01'?\", you can use the following Cypher query:\n\n```cypher\nMATCH (m:Movie)\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title AS Title, m.release_date AS ReleaseDate, m.vote_count AS VoteCount\nORDER BY m.vote_count DESC\nLIMIT 5;\n```\n\nThis query does the following:\n1. `MATCH (m:Movie)`: Matches all nodes of type `Movie`.\n2. `WHERE m.release_date >= '2000-01-01'`: Filters movies released on or after January 1, 2000.\n3. `RETURN m.title AS Title, m.release_date AS ReleaseDate, m.vote_count AS VoteCount`: Returns the movie title, release date, and vote count for each matching movie.\n4. `ORDER BY m.vote_count DESC`: Orders the results by the vote count in descending order.\n5. `LIMIT 5`: Limits the results to the top 5 movies.",
            "```cypher\nMATCH (m:Movie {release_date: {release_date}})\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title, m.release_date\nORDER BY m.release_date DESC\nLIMIT 5\n```",
            "```cypher\nMATCH (m:Movie)\nWHERE m.release_date >= '2000-01-01'\nRETURN m.title AS MovieTitle, m.release_date AS ReleaseDate ORDER BY m.release_date DESC LIMIT 5\n```"
        ]
    }
]